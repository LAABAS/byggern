
bygger_gruppe_15.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000018a  00800100  000014ae  00001542  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  0080028a  0080028a  000016cc  2**0
                  ALLOC
  3 .debug_aranges 00000100  00000000  00000000  000016cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002e4  00000000  00000000  000017cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ddf  00000000  00000000  00001ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007db  00000000  00000000  0000288f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000f45  00000000  00000000  0000306a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002b0  00000000  00000000  00003fb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000448  00000000  00000000  00004260  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000002de  00000000  00000000  000046a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00004986  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
       4:	0c 94 be 02 	jmp	0x57c	; 0x57c <__vector_1>
       8:	0c 94 08 03 	jmp	0x610	; 0x610 <__vector_2>
       c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      10:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      14:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      18:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      1c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      20:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      24:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      28:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      2c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      30:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      34:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      38:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      3c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      40:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      44:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      48:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      4c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      50:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      54:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      58:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      5c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      60:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      64:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      68:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      6c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>

00000070 <__ctors_end>:
      70:	11 24       	eor	r1, r1
      72:	1f be       	out	0x3f, r1	; 63
      74:	cf ef       	ldi	r28, 0xFF	; 255
      76:	d4 e0       	ldi	r29, 0x04	; 4
      78:	de bf       	out	0x3e, r29	; 62
      7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
      7c:	12 e0       	ldi	r17, 0x02	; 2
      7e:	a0 e0       	ldi	r26, 0x00	; 0
      80:	b1 e0       	ldi	r27, 0x01	; 1
      82:	ee ea       	ldi	r30, 0xAE	; 174
      84:	f4 e1       	ldi	r31, 0x14	; 20
      86:	02 c0       	rjmp	.+4      	; 0x8c <.do_copy_data_start>

00000088 <.do_copy_data_loop>:
      88:	05 90       	lpm	r0, Z+
      8a:	0d 92       	st	X+, r0

0000008c <.do_copy_data_start>:
      8c:	aa 38       	cpi	r26, 0x8A	; 138
      8e:	b1 07       	cpc	r27, r17
      90:	d9 f7       	brne	.-10     	; 0x88 <.do_copy_data_loop>

00000092 <__do_clear_bss>:
      92:	12 e0       	ldi	r17, 0x02	; 2
      94:	aa e8       	ldi	r26, 0x8A	; 138
      96:	b2 e0       	ldi	r27, 0x02	; 2
      98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
      9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
      9c:	a4 39       	cpi	r26, 0x94	; 148
      9e:	b1 07       	cpc	r27, r17
      a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
      a2:	0e 94 57 00 	call	0xae	; 0xae <main>
      a6:	0c 94 55 0a 	jmp	0x14aa	; 0x14aa <_exit>

000000aa <__bad_interrupt>:
      aa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ae <main>:

#include "sram.h"
#include "joystick.h"
#include "butterfly_interface.h"

int main(void) {
      ae:	df 93       	push	r29
      b0:	cf 93       	push	r28
      b2:	cd b7       	in	r28, 0x3d	; 61
      b4:	de b7       	in	r29, 0x3e	; 62
	SPI_NoSlave();
      b6:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
	init_UART(BAUD);
      ba:	80 e8       	ldi	r24, 0x80	; 128
      bc:	95 e2       	ldi	r25, 0x25	; 37
      be:	0e 94 9c 00 	call	0x138	; 0x138 <init_UART>
	init_SRAM();
      c2:	0e 94 c4 00 	call	0x188	; 0x188 <init_SRAM>
	init_joystick();
      c6:	0e 94 06 01 	call	0x20c	; 0x20c <init_joystick>
	SPI_MasterInit();	
      ca:	0e 94 37 01 	call	0x26e	; 0x26e <SPI_MasterInit>
	CAN_init();
      ce:	0e 94 59 01 	call	0x2b2	; 0x2b2 <CAN_init>



	printf("Initialization complete\n");
      d2:	80 e0       	ldi	r24, 0x00	; 0
      d4:	91 e0       	ldi	r25, 0x01	; 1
      d6:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>


	printf("CAN_test: %d", CAN_test());
      da:	0e 94 c5 01 	call	0x38a	; 0x38a <CAN_test>
      de:	9c 01       	movw	r18, r24
      e0:	00 d0       	rcall	.+0      	; 0xe2 <main+0x34>
      e2:	00 d0       	rcall	.+0      	; 0xe4 <main+0x36>
      e4:	ed b7       	in	r30, 0x3d	; 61
      e6:	fe b7       	in	r31, 0x3e	; 62
      e8:	31 96       	adiw	r30, 0x01	; 1
      ea:	88 e1       	ldi	r24, 0x18	; 24
      ec:	91 e0       	ldi	r25, 0x01	; 1
      ee:	91 83       	std	Z+1, r25	; 0x01
      f0:	80 83       	st	Z, r24
      f2:	33 83       	std	Z+3, r19	; 0x03
      f4:	22 83       	std	Z+2, r18	; 0x02
      f6:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
      fa:	0f 90       	pop	r0
      fc:	0f 90       	pop	r0
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0

	
	
	

	butterfly_menu();
     102:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <butterfly_menu>

	return 0;	
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	90 e0       	ldi	r25, 0x00	; 0
	
}
     10a:	cf 91       	pop	r28
     10c:	df 91       	pop	r29
     10e:	08 95       	ret

00000110 <UART_put_char>:
	return 0;

} 

// Send char using UART (can be optimised using interrupt)
int UART_put_char(char c, FILE* dummy){
     110:	1f 93       	push	r17
     112:	18 2f       	mov	r17, r24
	if (c == '\n') UART_put_char('\r', dummy);
     114:	8a 30       	cpi	r24, 0x0A	; 10
     116:	19 f4       	brne	.+6      	; 0x11e <UART_put_char+0xe>
     118:	8d e0       	ldi	r24, 0x0D	; 13
     11a:	0e 94 88 00 	call	0x110	; 0x110 <UART_put_char>
	loop_until_bit_is_set(UCSR0A, UDRE0); 
     11e:	5d 9b       	sbis	0x0b, 5	; 11
     120:	fe cf       	rjmp	.-4      	; 0x11e <UART_put_char+0xe>
	//while ( !( UCSR0A & (1<<UDRE0)) );
	UDR0 = (unsigned char)c;
     122:	1c b9       	out	0x0c, r17	; 12
	return 0;
}
     124:	80 e0       	ldi	r24, 0x00	; 0
     126:	90 e0       	ldi	r25, 0x00	; 0
     128:	1f 91       	pop	r17
     12a:	08 95       	ret

0000012c <UART_get_char>:

// Receive char using UART (can be optimised using interrupt)
int UART_get_char(FILE* dummy){
	loop_until_bit_is_set(UCSR0A, RXC0);
     12c:	5f 9b       	sbis	0x0b, 7	; 11
     12e:	fe cf       	rjmp	.-4      	; 0x12c <UART_get_char>
	//while ( !(UCSR0A & (1<<RXC0)) );
	char c = UDR0;
     130:	8c b1       	in	r24, 0x0c	; 12
	if (c == '\r') c = '\n';
	return (int) UDR0;
     132:	8c b1       	in	r24, 0x0c	; 12
}
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	08 95       	ret

00000138 <init_UART>:
	
	//Enable Interrupts. Macro.
	//sei();

	unsigned long ubrr0 = baud;
	ubrr0 = (FOSC/(16*ubrr0)) - 1;
     138:	9c 01       	movw	r18, r24
     13a:	40 e0       	ldi	r20, 0x00	; 0
     13c:	50 e0       	ldi	r21, 0x00	; 0
     13e:	64 e0       	ldi	r22, 0x04	; 4
     140:	22 0f       	add	r18, r18
     142:	33 1f       	adc	r19, r19
     144:	44 1f       	adc	r20, r20
     146:	55 1f       	adc	r21, r21
     148:	6a 95       	dec	r22
     14a:	d1 f7       	brne	.-12     	; 0x140 <init_UART+0x8>
     14c:	6a ef       	ldi	r22, 0xFA	; 250
     14e:	70 e0       	ldi	r23, 0x00	; 0
     150:	8b e4       	ldi	r24, 0x4B	; 75
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <__udivmodsi4>
     158:	c9 01       	movw	r24, r18
     15a:	da 01       	movw	r26, r20
     15c:	01 97       	sbiw	r24, 0x01	; 1
     15e:	a1 09       	sbc	r26, r1
     160:	b1 09       	sbc	r27, r1
	buffer_start = 0;
	buffer_stop = 0;
	buffer_used = 0;*/

	/* Sette baud rate */
	UBRR0H = (unsigned char)(ubrr0>>8);
     162:	29 2f       	mov	r18, r25
     164:	3a 2f       	mov	r19, r26
     166:	4b 2f       	mov	r20, r27
     168:	55 27       	eor	r21, r21
     16a:	20 bd       	out	0x20, r18	; 32
	UBRR0L = (unsigned char)ubrr0;
     16c:	89 b9       	out	0x09, r24	; 9
	
	/* Enable receiver og transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
     16e:	88 e1       	ldi	r24, 0x18	; 24
     170:	8a b9       	out	0x0a, r24	; 10
	ucsr0c = ucsr0c | (1<<UPM01) | (0<<UPM00);

	/*URSEL0 must be set to 1 according to data sheet*/
	ucsr0c = ucsr0c | (1<<URSEL0);
		
	UCSR0C = ucsr0c;
     172:	86 ea       	ldi	r24, 0xA6	; 166
     174:	80 bd       	out	0x20, r24	; 32

	fdevopen(UART_put_char, UART_get_char);
     176:	88 e8       	ldi	r24, 0x88	; 136
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	66 e9       	ldi	r22, 0x96	; 150
     17c:	70 e0       	ldi	r23, 0x00	; 0
     17e:	0e 94 ba 05 	call	0xb74	; 0xb74 <fdevopen>

	return 0;

} 
     182:	80 e0       	ldi	r24, 0x00	; 0
     184:	90 e0       	ldi	r25, 0x00	; 0
     186:	08 95       	ret

00000188 <init_SRAM>:
#include "sram.h"

//Initialize the extended RAM
void init_SRAM(void)
{
	MCUCR =  MCUCR | (1<<SRW10) | (1<<SRE);// | (1<<SRW10));(1<<SRE)
     188:	85 b7       	in	r24, 0x35	; 53
     18a:	80 6c       	ori	r24, 0xC0	; 192
     18c:	85 bf       	out	0x35, r24	; 53
	EMCUCR =  EMCUCR | (1<<SRW00); 
     18e:	86 b7       	in	r24, 0x36	; 54
     190:	84 60       	ori	r24, 0x04	; 4
     192:	86 bf       	out	0x36, r24	; 54
	SFIOR =  SFIOR | (1<<XMM2);
     194:	80 b7       	in	r24, 0x30	; 48
     196:	80 62       	ori	r24, 0x20	; 32
     198:	80 bf       	out	0x30, r24	; 48
}
     19a:	08 95       	ret

0000019c <SRAM_test>:

//Function to test the extended RAM. Will print out Error!!! in the terminal
//if the content of the RAM is different from what it should be.
void SRAM_test(void)
{
     19c:	0f 93       	push	r16
     19e:	1f 93       	push	r17
     1a0:	cf 93       	push	r28
     1a2:	df 93       	push	r29
	unsigned char *ram_address = (unsigned char *) 0x1000;
	printf("Starting...\n");
     1a4:	85 e2       	ldi	r24, 0x25	; 37
     1a6:	91 e0       	ldi	r25, 0x01	; 1
     1a8:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>
     1ac:	e0 e0       	ldi	r30, 0x00	; 0
     1ae:	f0 e1       	ldi	r31, 0x10	; 16

	int i;
	for(i=0;i<0x800;i++)
	{
		ram_address[i] = (char)0x83;
     1b0:	43 e8       	ldi	r20, 0x83	; 131
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     1b2:	29 e9       	ldi	r18, 0x99	; 153
     1b4:	39 e0       	ldi	r19, 0x09	; 9
     1b6:	41 93       	st	Z+, r20
     1b8:	c9 01       	movw	r24, r18
     1ba:	01 97       	sbiw	r24, 0x01	; 1
     1bc:	f1 f7       	brne	.-4      	; 0x1ba <SRAM_test+0x1e>
{
	unsigned char *ram_address = (unsigned char *) 0x1000;
	printf("Starting...\n");

	int i;
	for(i=0;i<0x800;i++)
     1be:	88 e1       	ldi	r24, 0x18	; 24
     1c0:	e0 30       	cpi	r30, 0x00	; 0
     1c2:	f8 07       	cpc	r31, r24
     1c4:	c1 f7       	brne	.-16     	; 0x1b6 <SRAM_test+0x1a>
     1c6:	c0 e0       	ldi	r28, 0x00	; 0
     1c8:	d0 e0       	ldi	r29, 0x00	; 0
		//printf("Adresse: 0x%x ", i);
		//printf("Lest: 0x%x \n", j);
		
		if(ram_address[i] != (char)0x83)
		{
			printf("Error!!! RAM no. 0x%x ",i);
     1ca:	01 e3       	ldi	r16, 0x31	; 49
     1cc:	11 e0       	ldi	r17, 0x01	; 1
		int j = (int)c;
		
		//printf("Adresse: 0x%x ", i);
		//printf("Lest: 0x%x \n", j);
		
		if(ram_address[i] != (char)0x83)
     1ce:	c0 50       	subi	r28, 0x00	; 0
     1d0:	d0 4f       	sbci	r29, 0xF0	; 240
     1d2:	88 81       	ld	r24, Y
     1d4:	c0 50       	subi	r28, 0x00	; 0
     1d6:	d0 41       	sbci	r29, 0x10	; 16
     1d8:	83 38       	cpi	r24, 0x83	; 131
     1da:	71 f0       	breq	.+28     	; 0x1f8 <SRAM_test+0x5c>
		{
			printf("Error!!! RAM no. 0x%x ",i);
     1dc:	00 d0       	rcall	.+0      	; 0x1de <SRAM_test+0x42>
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <SRAM_test+0x44>
     1e0:	ed b7       	in	r30, 0x3d	; 61
     1e2:	fe b7       	in	r31, 0x3e	; 62
     1e4:	12 83       	std	Z+2, r17	; 0x02
     1e6:	01 83       	std	Z+1, r16	; 0x01
     1e8:	d4 83       	std	Z+4, r29	; 0x04
     1ea:	c3 83       	std	Z+3, r28	; 0x03
     1ec:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
     1f0:	0f 90       	pop	r0
     1f2:	0f 90       	pop	r0
     1f4:	0f 90       	pop	r0
     1f6:	0f 90       	pop	r0
		ram_address[i] = (char)0x83;
		_delay_ms(2);
	//	printf("skriver RAM no. 0x%x \n", i);
	}

	for(i=0;i<0x800;i++)
     1f8:	21 96       	adiw	r28, 0x01	; 1
     1fa:	f8 e0       	ldi	r31, 0x08	; 8
     1fc:	c0 30       	cpi	r28, 0x00	; 0
     1fe:	df 07       	cpc	r29, r31
     200:	31 f7       	brne	.-52     	; 0x1ce <SRAM_test+0x32>
			//printf("Written OK\n");
		}
		//_delay_ms(2);
	}

	printf("Finished!!!\n");
     202:	88 e4       	ldi	r24, 0x48	; 72
     204:	91 e0       	ldi	r25, 0x01	; 1
     206:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>
     20a:	ff cf       	rjmp	.-2      	; 0x20a <SRAM_test+0x6e>

0000020c <init_joystick>:


// Initialize the joystick
void init_joystick(){
	// set port B: in
	DDRB = 0x00; //inputs
     20c:	17 ba       	out	0x17, r1	; 23
	PORTB = 0xFF; //Pull-ups
     20e:	8f ef       	ldi	r24, 0xFF	; 255
     210:	88 bb       	out	0x18, r24	; 24
}
     212:	08 95       	ret

00000214 <read_axis>:

// Read joystick position, returns int8
int8_t read_axis(char axis) {
	volatile uint8_t *adc_address = (uint8_t *) 0x1800;
	
	if(axis == 'x'){
     214:	88 37       	cpi	r24, 0x78	; 120
     216:	79 f4       	brne	.+30     	; 0x236 <read_axis+0x22>
		adc_address[0] = 0x04;
     218:	84 e0       	ldi	r24, 0x04	; 4
     21a:	80 93 00 18 	sts	0x1800, r24
		loop_until_bit_is_clear(PINB, 0);
     21e:	b0 99       	sbic	0x16, 0	; 22
     220:	fe cf       	rjmp	.-4      	; 0x21e <read_axis+0xa>
		return (int8_t)eeprom_read_byte((uint8_t*)*adc_address);
     222:	80 91 00 18 	lds	r24, 0x1800
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     226:	e1 99       	sbic	0x1c, 1	; 28
     228:	fe cf       	rjmp	.-4      	; 0x226 <read_axis+0x12>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	9f bb       	out	0x1f, r25	; 31
     22e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     230:	e0 9a       	sbi	0x1c, 0	; 28
     232:	8d b3       	in	r24, 0x1d	; 29
     234:	08 95       	ret
	}
	else if(axis == 'y'){
     236:	89 37       	cpi	r24, 0x79	; 121
     238:	11 f0       	breq	.+4      	; 0x23e <read_axis+0x2a>
     23a:	8f ef       	ldi	r24, 0xFF	; 255
     23c:	08 95       	ret
		adc_address[0] = 0x06;
     23e:	86 e0       	ldi	r24, 0x06	; 6
     240:	80 93 00 18 	sts	0x1800, r24
		loop_until_bit_is_clear(PINB, 0);
     244:	b0 99       	sbic	0x16, 0	; 22
     246:	fe cf       	rjmp	.-4      	; 0x244 <read_axis+0x30>
		return (int8_t)eeprom_read_byte((uint8_t*)(*adc_address+256));
     248:	80 91 00 18 	lds	r24, 0x1800
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     24c:	e1 99       	sbic	0x1c, 1	; 28
     24e:	fe cf       	rjmp	.-4      	; 0x24c <read_axis+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	80 50       	subi	r24, 0x00	; 0
     254:	9f 4f       	sbci	r25, 0xFF	; 255
     256:	9f bb       	out	0x1f, r25	; 31
     258:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     25a:	e0 9a       	sbi	0x1c, 0	; 28
     25c:	8d b3       	in	r24, 0x1d	; 29
	}
	return -1;
	//evt. korrigering
}
     25e:	08 95       	ret

00000260 <read_buttons>:


// Read joystick buttons (Can be optimised with interrupt)
inline uint8_t read_buttons(){
	return (PINB & 0x6) >> 1;
     260:	86 b3       	in	r24, 0x16	; 22
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	86 70       	andi	r24, 0x06	; 6
     266:	90 70       	andi	r25, 0x00	; 0
     268:	95 95       	asr	r25
     26a:	87 95       	ror	r24
}
     26c:	08 95       	ret

0000026e <SPI_MasterInit>:

// Initialize the SPI Master interface
void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	DDRB = (DDRB & 0x0F) | ((1<<DDB5) | (1<<DDB7) | (1<<DDB3)| (1<<DDB4));
     26e:	87 b3       	in	r24, 0x17	; 23
     270:	87 70       	andi	r24, 0x07	; 7
     272:	88 6b       	ori	r24, 0xB8	; 184
     274:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     276:	81 e5       	ldi	r24, 0x51	; 81
     278:	8d b9       	out	0x0d, r24	; 13
}

// Disable chipselect on all SPI slaves (select no slave)
void SPI_NoSlave(void){
	/* Set SS high */	
	PORTB = PORTB | (1<<DDB4) | (1<<DDB3);
     27a:	88 b3       	in	r24, 0x18	; 24
     27c:	88 61       	ori	r24, 0x18	; 24
     27e:	88 bb       	out	0x18, r24	; 24
	/* Set MOSI and SCK output, all others input */
	DDRB = (DDRB & 0x0F) | ((1<<DDB5) | (1<<DDB7) | (1<<DDB3)| (1<<DDB4));
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
	SPI_NoSlave();
}
     280:	08 95       	ret

00000282 <SPI_MasterTransmit>:

// Transmit char over SPI
void SPI_MasterTransmit(char cData)
{
	/* Start transmission */
	SPDR = cData;
     282:	8f b9       	out	0x0f, r24	; 15
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     284:	77 9b       	sbis	0x0e, 7	; 14
     286:	fe cf       	rjmp	.-4      	; 0x284 <SPI_MasterTransmit+0x2>
}
     288:	08 95       	ret

0000028a <SPI_MasterReceive>:

// Transmit char over SPI
void SPI_MasterTransmit(char cData)
{
	/* Start transmission */
	SPDR = cData;
     28a:	80 e4       	ldi	r24, 0x40	; 64
     28c:	8f b9       	out	0x0f, r24	; 15
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     28e:	77 9b       	sbis	0x0e, 7	; 14
     290:	fe cf       	rjmp	.-4      	; 0x28e <SPI_MasterReceive+0x4>
{
	//send dummy char, to shift the SPDR
	SPI_MasterTransmit('@');
	
	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     292:	77 9b       	sbis	0x0e, 7	; 14
     294:	fe cf       	rjmp	.-4      	; 0x292 <SPI_MasterReceive+0x8>
	
	

	/* Return data register */
	return SPDR;
     296:	8f b1       	in	r24, 0x0f	; 15
}
     298:	08 95       	ret

0000029a <SPI_SelectSlave>:

// Select SPI slave to send data to
void SPI_SelectSlave(char slave){
	/* Slave select */
	if (slave == SPI_BUTTERFLY)
     29a:	82 36       	cpi	r24, 0x62	; 98
     29c:	11 f4       	brne	.+4      	; 0x2a2 <SPI_SelectSlave+0x8>
		PORTB = PORTB & ~(1<<DDB3) ; // set SS for butterfly low
     29e:	c3 98       	cbi	0x18, 3	; 24
     2a0:	08 95       	ret
	else if (slave == SPI_CAN)
     2a2:	83 37       	cpi	r24, 0x73	; 115
     2a4:	09 f4       	brne	.+2      	; 0x2a8 <SPI_SelectSlave+0xe>
		PORTB = PORTB & ~(1<<DDB4) ; // set SS for CAN low 
     2a6:	c4 98       	cbi	0x18, 4	; 24
     2a8:	08 95       	ret

000002aa <SPI_NoSlave>:
}

// Disable chipselect on all SPI slaves (select no slave)
void SPI_NoSlave(void){
	/* Set SS high */	
	PORTB = PORTB | (1<<DDB4) | (1<<DDB3);
     2aa:	88 b3       	in	r24, 0x18	; 24
     2ac:	88 61       	ori	r24, 0x18	; 24
     2ae:	88 bb       	out	0x18, r24	; 24
}
     2b0:	08 95       	ret

000002b2 <CAN_init>:
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/io.h>

//Initialize the CAN bus
void CAN_init(void){
     2b2:	df 93       	push	r29
     2b4:	cf 93       	push	r28
     2b6:	00 d0       	rcall	.+0      	; 0x2b8 <CAN_init+0x6>
     2b8:	cd b7       	in	r28, 0x3d	; 61
     2ba:	de b7       	in	r29, 0x3e	; 62

	CAN_reset();
     2bc:	0e 94 60 04 	call	0x8c0	; 0x8c0 <CAN_reset>

	uint8_t data[2];

	//Acceptance mask for RXB0 (all 11 bits counts)
	//dette filteret blokkerer alt?!?
	data[0] = 0b11111111;
     2c0:	8f ef       	ldi	r24, 0xFF	; 255
     2c2:	89 83       	std	Y+1, r24	; 0x01
	data[1] = 0b11100000;
     2c4:	80 ee       	ldi	r24, 0xE0	; 224
     2c6:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], MASK_RXF0);
     2c8:	89 81       	ldd	r24, Y+1	; 0x01
     2ca:	60 e2       	ldi	r22, 0x20	; 32
     2cc:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], MASK_RXF0+1);
     2d0:	8a 81       	ldd	r24, Y+2	; 0x02
     2d2:	61 e2       	ldi	r22, 0x21	; 33
     2d4:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>


	//RXF0
	//Receive filter 0 hits when id = 0x1F (exactly)	
	data[0] = 0b00000011;
     2d8:	83 e0       	ldi	r24, 0x03	; 3
     2da:	89 83       	std	Y+1, r24	; 0x01
	data[1] = 0b11100000;
     2dc:	80 ee       	ldi	r24, 0xE0	; 224
     2de:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], RXF0);
     2e0:	89 81       	ldd	r24, Y+1	; 0x01
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF0+1);
     2e8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ea:	61 e0       	ldi	r22, 0x01	; 1
     2ec:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF1+1);*/



	//Acceptance mask for RXB1 - accepts 1 2 3 8 9 only
	data[0] = 0b11111111;
     2f0:	8f ef       	ldi	r24, 0xFF	; 255
     2f2:	89 83       	std	Y+1, r24	; 0x01
	data[1] = 0b11100000;
     2f4:	80 ee       	ldi	r24, 0xE0	; 224
     2f6:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], MASK_RXF1);
     2f8:	89 81       	ldd	r24, Y+1	; 0x01
     2fa:	64 e2       	ldi	r22, 0x24	; 36
     2fc:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], MASK_RXF1+1);
     300:	8a 81       	ldd	r24, Y+2	; 0x02
     302:	65 e2       	ldi	r22, 0x25	; 37
     304:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>



	//RXF2
	//Receive filter 2 hits when id = 0 (exactly)
	data[0] = 0b00000000;
     308:	19 82       	std	Y+1, r1	; 0x01
	data[1] = 0b00000000;
     30a:	1a 82       	std	Y+2, r1	; 0x02
	CAN_write(data[0], RXF2);
     30c:	89 81       	ldd	r24, Y+1	; 0x01
     30e:	68 e0       	ldi	r22, 0x08	; 8
     310:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF2+1);
     314:	8a 81       	ldd	r24, Y+2	; 0x02
     316:	69 e0       	ldi	r22, 0x09	; 9
     318:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>

	//RXF3
	//Receive filter 3 hits when id = 1 (exactly)
	data[0] = 0b00000000;
     31c:	19 82       	std	Y+1, r1	; 0x01
	data[1] = 0b00100000;
     31e:	80 e2       	ldi	r24, 0x20	; 32
     320:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], RXF3);
     322:	89 81       	ldd	r24, Y+1	; 0x01
     324:	60 e1       	ldi	r22, 0x10	; 16
     326:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF3+1);
     32a:	8a 81       	ldd	r24, Y+2	; 0x02
     32c:	61 e1       	ldi	r22, 0x11	; 17
     32e:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>

	//RXF4
	//Receive filter 4 hits when id = 2 (exactly)
	data[0] = 0b00000000;
     332:	19 82       	std	Y+1, r1	; 0x01
	data[1] = 0b01000000;
     334:	80 e4       	ldi	r24, 0x40	; 64
     336:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], RXF4);
     338:	89 81       	ldd	r24, Y+1	; 0x01
     33a:	64 e1       	ldi	r22, 0x14	; 20
     33c:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF4+1);
     340:	8a 81       	ldd	r24, Y+2	; 0x02
     342:	65 e1       	ldi	r22, 0x15	; 21
     344:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>

	//RXF5
	//Receive filter 5 hits when id = 3 (exactly)
	data[0] = 0b00000000;
     348:	19 82       	std	Y+1, r1	; 0x01
	data[1] = 0b01100000;
     34a:	80 e6       	ldi	r24, 0x60	; 96
     34c:	8a 83       	std	Y+2, r24	; 0x02
	CAN_write(data[0], RXF5);
     34e:	89 81       	ldd	r24, Y+1	; 0x01
     350:	68 e1       	ldi	r22, 0x18	; 24
     352:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_write(data[1], RXF5+1);
     356:	8a 81       	ldd	r24, Y+2	; 0x02
     358:	69 e1       	ldi	r22, 0x19	; 25
     35a:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>


	CAN_bit_modify(CANCTRL, MASK_MODE, MODE_NORMAL); //set loopback mode
     35e:	8f e0       	ldi	r24, 0x0F	; 15
     360:	60 ee       	ldi	r22, 0xE0	; 224
     362:	40 e0       	ldi	r20, 0x00	; 0
     364:	0e 94 9a 05 	call	0xb34	; 0xb34 <CAN_bit_modify>
	CAN_bit_modify(RXB0CTRL, MASK_RECEIVE_ID_TYPE, ID_TYPE_STANDARD); // set no filter, set to 01 to accept only standard, 00 to accept accordig to filters
     368:	80 e6       	ldi	r24, 0x60	; 96
     36a:	60 e6       	ldi	r22, 0x60	; 96
     36c:	40 e2       	ldi	r20, 0x20	; 32
     36e:	0e 94 9a 05 	call	0xb34	; 0xb34 <CAN_bit_modify>
	CAN_bit_modify(BFPCTRL, 0x0f, 0xff);
     372:	8c e0       	ldi	r24, 0x0C	; 12
     374:	6f e0       	ldi	r22, 0x0F	; 15
     376:	4f ef       	ldi	r20, 0xFF	; 255
     378:	0e 94 9a 05 	call	0xb34	; 0xb34 <CAN_bit_modify>
	CAN_init_interrupt();
     37c:	0e 94 9b 02 	call	0x536	; 0x536 <CAN_init_interrupt>
}
     380:	0f 90       	pop	r0
     382:	0f 90       	pop	r0
     384:	cf 91       	pop	r28
     386:	df 91       	pop	r29
     388:	08 95       	ret

0000038a <CAN_test>:

// Test send and recieve in loopback mode, verify result from UART
int CAN_test(void){
     38a:	df 93       	push	r29
     38c:	cf 93       	push	r28
     38e:	cd b7       	in	r28, 0x3d	; 61
     390:	de b7       	in	r29, 0x3e	; 62
     392:	27 97       	sbiw	r28, 0x07	; 7
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	f8 94       	cli
     398:	de bf       	out	0x3e, r29	; 62
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	cd bf       	out	0x3d, r28	; 61
	printf("CAN_test started\n");
     39e:	84 e5       	ldi	r24, 0x54	; 84
     3a0:	91 e0       	ldi	r25, 0x01	; 1
     3a2:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>
	int i;
	

	CAN_message message;
	message.id = 0;
     3a6:	1c 82       	std	Y+4, r1	; 0x04
     3a8:	1b 82       	std	Y+3, r1	; 0x03
	message.length = 8;
     3aa:	88 e0       	ldi	r24, 0x08	; 8
     3ac:	8d 83       	std	Y+5, r24	; 0x05
	message.data = " ";
     3ae:	85 e6       	ldi	r24, 0x65	; 101
     3b0:	91 e0       	ldi	r25, 0x01	; 1
     3b2:	9f 83       	std	Y+7, r25	; 0x07
     3b4:	8e 83       	std	Y+6, r24	; 0x06
		printf("Sending string: %s", message.data);
		if (CAN_send(message.data, message.id) != 0){
			return -1;
		}
	}*/
	return 0;
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	90 e0       	ldi	r25, 0x00	; 0
}
     3ba:	27 96       	adiw	r28, 0x07	; 7
     3bc:	0f b6       	in	r0, 0x3f	; 63
     3be:	f8 94       	cli
     3c0:	de bf       	out	0x3e, r29	; 62
     3c2:	0f be       	out	0x3f, r0	; 63
     3c4:	cd bf       	out	0x3d, r28	; 61
     3c6:	cf 91       	pop	r28
     3c8:	df 91       	pop	r29
     3ca:	08 95       	ret

000003cc <CAN_send>:

// Send string using CAN bus
int CAN_send(char* str, int id){
     3cc:	df 93       	push	r29
     3ce:	cf 93       	push	r28
     3d0:	cd b7       	in	r28, 0x3d	; 61
     3d2:	de b7       	in	r29, 0x3e	; 62
     3d4:	2e 97       	sbiw	r28, 0x0e	; 14
     3d6:	0f b6       	in	r0, 0x3f	; 63
     3d8:	f8 94       	cli
     3da:	de bf       	out	0x3e, r29	; 62
     3dc:	0f be       	out	0x3f, r0	; 63
     3de:	cd bf       	out	0x3d, r28	; 61
     3e0:	9a 87       	std	Y+10, r25	; 0x0a
     3e2:	89 87       	std	Y+9, r24	; 0x09
     3e4:	7c 87       	std	Y+12, r23	; 0x0c
     3e6:	6b 87       	std	Y+11, r22	; 0x0b
	
	unsigned int part, i;
	int done = 0;
     3e8:	1c 82       	std	Y+4, r1	; 0x04
     3ea:	1b 82       	std	Y+3, r1	; 0x03

	char *messg = "\0\0\0\0\0\0\0";
     3ec:	87 e6       	ldi	r24, 0x67	; 103
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	9a 83       	std	Y+2, r25	; 0x02
     3f2:	89 83       	std	Y+1, r24	; 0x01
	for(i = 0; i < 8; i++){
     3f4:	1e 82       	std	Y+6, r1	; 0x06
     3f6:	1d 82       	std	Y+5, r1	; 0x05
     3f8:	1f c0       	rjmp	.+62     	; 0x438 <CAN_send+0x6c>
		messg[i] = str[i];
     3fa:	29 81       	ldd	r18, Y+1	; 0x01
     3fc:	3a 81       	ldd	r19, Y+2	; 0x02
     3fe:	8d 81       	ldd	r24, Y+5	; 0x05
     400:	9e 81       	ldd	r25, Y+6	; 0x06
     402:	d9 01       	movw	r26, r18
     404:	a8 0f       	add	r26, r24
     406:	b9 1f       	adc	r27, r25
     408:	29 85       	ldd	r18, Y+9	; 0x09
     40a:	3a 85       	ldd	r19, Y+10	; 0x0a
     40c:	8d 81       	ldd	r24, Y+5	; 0x05
     40e:	9e 81       	ldd	r25, Y+6	; 0x06
     410:	f9 01       	movw	r30, r18
     412:	e8 0f       	add	r30, r24
     414:	f9 1f       	adc	r31, r25
     416:	80 81       	ld	r24, Z
     418:	8c 93       	st	X, r24
		if (messg[i] == '\0') {
     41a:	29 81       	ldd	r18, Y+1	; 0x01
     41c:	3a 81       	ldd	r19, Y+2	; 0x02
     41e:	8d 81       	ldd	r24, Y+5	; 0x05
     420:	9e 81       	ldd	r25, Y+6	; 0x06
     422:	f9 01       	movw	r30, r18
     424:	e8 0f       	add	r30, r24
     426:	f9 1f       	adc	r31, r25
     428:	80 81       	ld	r24, Z
     42a:	88 23       	and	r24, r24
     42c:	51 f0       	breq	.+20     	; 0x442 <CAN_send+0x76>
	
	unsigned int part, i;
	int done = 0;

	char *messg = "\0\0\0\0\0\0\0";
	for(i = 0; i < 8; i++){
     42e:	8d 81       	ldd	r24, Y+5	; 0x05
     430:	9e 81       	ldd	r25, Y+6	; 0x06
     432:	01 96       	adiw	r24, 0x01	; 1
     434:	9e 83       	std	Y+6, r25	; 0x06
     436:	8d 83       	std	Y+5, r24	; 0x05
     438:	8d 81       	ldd	r24, Y+5	; 0x05
     43a:	9e 81       	ldd	r25, Y+6	; 0x06
     43c:	88 30       	cpi	r24, 0x08	; 8
     43e:	91 05       	cpc	r25, r1
     440:	e0 f2       	brcs	.-72     	; 0x3fa <CAN_send+0x2e>
		if (messg[i] == '\0') {
			break;
		}
	}

	cli(); // disable interrupts, to protect SPI-communication 
     442:	f8 94       	cli

	CAN_bit_modify(TXB0SIDH, 0xFF, (id>>3)); //transmit buffer 0 id high
     444:	8b 85       	ldd	r24, Y+11	; 0x0b
     446:	9c 85       	ldd	r25, Y+12	; 0x0c
     448:	95 95       	asr	r25
     44a:	87 95       	ror	r24
     44c:	95 95       	asr	r25
     44e:	87 95       	ror	r24
     450:	95 95       	asr	r25
     452:	87 95       	ror	r24
     454:	98 2f       	mov	r25, r24
     456:	81 e3       	ldi	r24, 0x31	; 49
     458:	6f ef       	ldi	r22, 0xFF	; 255
     45a:	49 2f       	mov	r20, r25
     45c:	0e 94 9a 05 	call	0xb34	; 0xb34 <CAN_bit_modify>
	CAN_bit_modify(TXB0SIDL, MASK_SIDL, (id<<5));//transmit buffer 0 id low
     460:	8b 85       	ldd	r24, Y+11	; 0x0b
     462:	98 2f       	mov	r25, r24
     464:	92 95       	swap	r25
     466:	99 0f       	add	r25, r25
     468:	90 7e       	andi	r25, 0xE0	; 224
     46a:	82 e3       	ldi	r24, 0x32	; 50
     46c:	60 ee       	ldi	r22, 0xE0	; 224
     46e:	49 2f       	mov	r20, r25
     470:	0e 94 9a 05 	call	0xb34	; 0xb34 <CAN_bit_modify>
	//CAN_write((char)messg.length, TXB0DLC);	// data length
	CAN_write((char)8, TXB0DLC);	// data length
     474:	88 e0       	ldi	r24, 0x08	; 8
     476:	65 e3       	ldi	r22, 0x35	; 53
     478:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <CAN_write>
	CAN_load_tx(messg, 0); //load transmit buffer from channel 0
     47c:	89 81       	ldd	r24, Y+1	; 0x01
     47e:	9a 81       	ldd	r25, Y+2	; 0x02
     480:	60 e0       	ldi	r22, 0x00	; 0
     482:	0e 94 18 05 	call	0xa30	; 0xa30 <CAN_load_tx>
	//printf("\n\n%s\n\n", messg.data);
	//_delay_ms(1);
	CAN_rts(0); //request to send
     486:	80 e0       	ldi	r24, 0x00	; 0
     488:	0e 94 59 05 	call	0xab2	; 0xab2 <CAN_rts>

	//wait for send OK ()
	for(i = 0; i < 0xffff; i++){
     48c:	1e 82       	std	Y+6, r1	; 0x06
     48e:	1d 82       	std	Y+5, r1	; 0x05
     490:	0d c0       	rjmp	.+26     	; 0x4ac <CAN_send+0xe0>
		if((CAN_read_status() & MASK_TXREQ0) == 0) break;
     492:	0e 94 7d 05 	call	0xafa	; 0xafa <CAN_read_status>
     496:	88 2f       	mov	r24, r24
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	84 70       	andi	r24, 0x04	; 4
     49c:	90 70       	andi	r25, 0x00	; 0
     49e:	00 97       	sbiw	r24, 0x00	; 0
     4a0:	59 f0       	breq	.+22     	; 0x4b8 <CAN_send+0xec>
	//printf("\n\n%s\n\n", messg.data);
	//_delay_ms(1);
	CAN_rts(0); //request to send

	//wait for send OK ()
	for(i = 0; i < 0xffff; i++){
     4a2:	8d 81       	ldd	r24, Y+5	; 0x05
     4a4:	9e 81       	ldd	r25, Y+6	; 0x06
     4a6:	01 96       	adiw	r24, 0x01	; 1
     4a8:	9e 83       	std	Y+6, r25	; 0x06
     4aa:	8d 83       	std	Y+5, r24	; 0x05
     4ac:	8d 81       	ldd	r24, Y+5	; 0x05
     4ae:	9e 81       	ldd	r25, Y+6	; 0x06
     4b0:	2f ef       	ldi	r18, 0xFF	; 255
     4b2:	8f 3f       	cpi	r24, 0xFF	; 255
     4b4:	92 07       	cpc	r25, r18
     4b6:	69 f7       	brne	.-38     	; 0x492 <CAN_send+0xc6>
		if((CAN_read_status() & MASK_TXREQ0) == 0) break;
	}
	sei(); // enable interrupts again
     4b8:	78 94       	sei
	if(i == 0xffff) return -1;
     4ba:	8d 81       	ldd	r24, Y+5	; 0x05
     4bc:	9e 81       	ldd	r25, Y+6	; 0x06
     4be:	2f ef       	ldi	r18, 0xFF	; 255
     4c0:	8f 3f       	cpi	r24, 0xFF	; 255
     4c2:	92 07       	cpc	r25, r18
     4c4:	29 f4       	brne	.+10     	; 0x4d0 <CAN_send+0x104>
     4c6:	8f ef       	ldi	r24, 0xFF	; 255
     4c8:	9f ef       	ldi	r25, 0xFF	; 255
     4ca:	9e 87       	std	Y+14, r25	; 0x0e
     4cc:	8d 87       	std	Y+13, r24	; 0x0d
     4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <CAN_send+0x108>
			if(i == 0xffff) return -1;
		}

		if(str[i] == '\0') break;
*/
	return 0;
     4d0:	1e 86       	std	Y+14, r1	; 0x0e
     4d2:	1d 86       	std	Y+13, r1	; 0x0d
     4d4:	8d 85       	ldd	r24, Y+13	; 0x0d
     4d6:	9e 85       	ldd	r25, Y+14	; 0x0e
}
     4d8:	2e 96       	adiw	r28, 0x0e	; 14
     4da:	0f b6       	in	r0, 0x3f	; 63
     4dc:	f8 94       	cli
     4de:	de bf       	out	0x3e, r29	; 62
     4e0:	0f be       	out	0x3f, r0	; 63
     4e2:	cd bf       	out	0x3d, r28	; 61
     4e4:	cf 91       	pop	r28
     4e6:	df 91       	pop	r29
     4e8:	08 95       	ret

000004ea <CAN_receive>:

// Recieve string from CAN recieve buffer
int CAN_receive(CAN_message* msg, int rx){
     4ea:	df 93       	push	r29
     4ec:	cf 93       	push	r28
     4ee:	00 d0       	rcall	.+0      	; 0x4f0 <CAN_receive+0x6>
     4f0:	00 d0       	rcall	.+0      	; 0x4f2 <CAN_receive+0x8>
     4f2:	cd b7       	in	r28, 0x3d	; 61
     4f4:	de b7       	in	r29, 0x3e	; 62
     4f6:	9a 83       	std	Y+2, r25	; 0x02
     4f8:	89 83       	std	Y+1, r24	; 0x01
     4fa:	7c 83       	std	Y+4, r23	; 0x04
     4fc:	6b 83       	std	Y+3, r22	; 0x03
	//FILHIT to check message type
	
	while((CAN_read_status() & MASK_CANINTF_RX0IF+2*rx) == 0); // loop until data received
     4fe:	0e 94 7d 05 	call	0xafa	; 0xafa <CAN_read_status>
     502:	28 2f       	mov	r18, r24
     504:	30 e0       	ldi	r19, 0x00	; 0
     506:	8b 81       	ldd	r24, Y+3	; 0x03
     508:	9c 81       	ldd	r25, Y+4	; 0x04
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	01 96       	adiw	r24, 0x01	; 1
     510:	82 23       	and	r24, r18
     512:	93 23       	and	r25, r19
     514:	00 97       	sbiw	r24, 0x00	; 0
     516:	99 f3       	breq	.-26     	; 0x4fe <CAN_receive+0x14>
	CAN_read_rx(msg, rx);
     518:	2b 81       	ldd	r18, Y+3	; 0x03
     51a:	89 81       	ldd	r24, Y+1	; 0x01
     51c:	9a 81       	ldd	r25, Y+2	; 0x02
     51e:	62 2f       	mov	r22, r18
     520:	0e 94 b0 04 	call	0x960	; 0x960 <CAN_read_rx>
	
	return 0;
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0

}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	0f 90       	pop	r0
     52e:	0f 90       	pop	r0
     530:	cf 91       	pop	r28
     532:	df 91       	pop	r29
     534:	08 95       	ret

00000536 <CAN_init_interrupt>:
	GICR = GICR | (1<<INT0);
	sei();
}*/


void CAN_init_interrupt(){
     536:	df 93       	push	r29
     538:	cf 93       	push	r28
     53a:	cd b7       	in	r28, 0x3d	; 61
     53c:	de b7       	in	r29, 0x3e	; 62
//interrupt init
	PORTD = PORTD | 0b00001100;
     53e:	a2 e3       	ldi	r26, 0x32	; 50
     540:	b0 e0       	ldi	r27, 0x00	; 0
     542:	e2 e3       	ldi	r30, 0x32	; 50
     544:	f0 e0       	ldi	r31, 0x00	; 0
     546:	80 81       	ld	r24, Z
     548:	8c 60       	ori	r24, 0x0C	; 12
     54a:	8c 93       	st	X, r24
	DDRD = DDRD & 	0b11110011;
     54c:	a1 e3       	ldi	r26, 0x31	; 49
     54e:	b0 e0       	ldi	r27, 0x00	; 0
     550:	e1 e3       	ldi	r30, 0x31	; 49
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	80 81       	ld	r24, Z
     556:	83 7f       	andi	r24, 0xF3	; 243
     558:	8c 93       	st	X, r24
	MCUCR = MCUCR | (0<<ISC01) | (0<<ISC00) | (0<<ISC11) | (0<<ISC10);
     55a:	a5 e5       	ldi	r26, 0x55	; 85
     55c:	b0 e0       	ldi	r27, 0x00	; 0
     55e:	e5 e5       	ldi	r30, 0x55	; 85
     560:	f0 e0       	ldi	r31, 0x00	; 0
     562:	80 81       	ld	r24, Z
     564:	8c 93       	st	X, r24
	GICR = GICR | (1<<INT0) | (1<<INT1);
     566:	ab e5       	ldi	r26, 0x5B	; 91
     568:	b0 e0       	ldi	r27, 0x00	; 0
     56a:	eb e5       	ldi	r30, 0x5B	; 91
     56c:	f0 e0       	ldi	r31, 0x00	; 0
     56e:	80 81       	ld	r24, Z
     570:	80 6c       	ori	r24, 0xC0	; 192
     572:	8c 93       	st	X, r24
	sei();
     574:	78 94       	sei
}
     576:	cf 91       	pop	r28
     578:	df 91       	pop	r29
     57a:	08 95       	ret

0000057c <__vector_1>:


SIGNAL(SIG_INTERRUPT0) {
     57c:	1f 92       	push	r1
     57e:	0f 92       	push	r0
     580:	0f b6       	in	r0, 0x3f	; 63
     582:	0f 92       	push	r0
     584:	11 24       	eor	r1, r1
     586:	2f 93       	push	r18
     588:	3f 93       	push	r19
     58a:	4f 93       	push	r20
     58c:	5f 93       	push	r21
     58e:	6f 93       	push	r22
     590:	7f 93       	push	r23
     592:	8f 93       	push	r24
     594:	9f 93       	push	r25
     596:	af 93       	push	r26
     598:	bf 93       	push	r27
     59a:	ef 93       	push	r30
     59c:	ff 93       	push	r31
     59e:	df 93       	push	r29
     5a0:	cf 93       	push	r28
     5a2:	00 d0       	rcall	.+0      	; 0x5a4 <__vector_1+0x28>
     5a4:	00 d0       	rcall	.+0      	; 0x5a6 <__vector_1+0x2a>
     5a6:	0f 92       	push	r0
     5a8:	cd b7       	in	r28, 0x3d	; 61
     5aa:	de b7       	in	r29, 0x3e	; 62
		
	CAN_message received;
	received.data = "\0\0\0\0\0\0\0\0";
     5ac:	8f e6       	ldi	r24, 0x6F	; 111
     5ae:	91 e0       	ldi	r25, 0x01	; 1
     5b0:	9d 83       	std	Y+5, r25	; 0x05
     5b2:	8c 83       	std	Y+4, r24	; 0x04

	printf("Received interrupt0: ");
     5b4:	00 d0       	rcall	.+0      	; 0x5b6 <__vector_1+0x3a>
     5b6:	ed b7       	in	r30, 0x3d	; 61
     5b8:	fe b7       	in	r31, 0x3e	; 62
     5ba:	31 96       	adiw	r30, 0x01	; 1
     5bc:	88 e7       	ldi	r24, 0x78	; 120
     5be:	91 e0       	ldi	r25, 0x01	; 1
     5c0:	91 83       	std	Z+1, r25	; 0x01
     5c2:	80 83       	st	Z, r24
     5c4:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
     5c8:	0f 90       	pop	r0
     5ca:	0f 90       	pop	r0
    CAN_receive(&received, 0);
     5cc:	ce 01       	movw	r24, r28
     5ce:	01 96       	adiw	r24, 0x01	; 1
     5d0:	60 e0       	ldi	r22, 0x00	; 0
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 75 02 	call	0x4ea	; 0x4ea <CAN_receive>
	printf("%s\n", received.data);
     5d8:	8c 81       	ldd	r24, Y+4	; 0x04
     5da:	9d 81       	ldd	r25, Y+5	; 0x05
     5dc:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>

}
     5e0:	0f 90       	pop	r0
     5e2:	0f 90       	pop	r0
     5e4:	0f 90       	pop	r0
     5e6:	0f 90       	pop	r0
     5e8:	0f 90       	pop	r0
     5ea:	cf 91       	pop	r28
     5ec:	df 91       	pop	r29
     5ee:	ff 91       	pop	r31
     5f0:	ef 91       	pop	r30
     5f2:	bf 91       	pop	r27
     5f4:	af 91       	pop	r26
     5f6:	9f 91       	pop	r25
     5f8:	8f 91       	pop	r24
     5fa:	7f 91       	pop	r23
     5fc:	6f 91       	pop	r22
     5fe:	5f 91       	pop	r21
     600:	4f 91       	pop	r20
     602:	3f 91       	pop	r19
     604:	2f 91       	pop	r18
     606:	0f 90       	pop	r0
     608:	0f be       	out	0x3f, r0	; 63
     60a:	0f 90       	pop	r0
     60c:	1f 90       	pop	r1
     60e:	18 95       	reti

00000610 <__vector_2>:

SIGNAL(SIG_INTERRUPT1) {
     610:	1f 92       	push	r1
     612:	0f 92       	push	r0
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	0f 92       	push	r0
     618:	11 24       	eor	r1, r1
     61a:	2f 93       	push	r18
     61c:	3f 93       	push	r19
     61e:	4f 93       	push	r20
     620:	5f 93       	push	r21
     622:	6f 93       	push	r22
     624:	7f 93       	push	r23
     626:	8f 93       	push	r24
     628:	9f 93       	push	r25
     62a:	af 93       	push	r26
     62c:	bf 93       	push	r27
     62e:	ef 93       	push	r30
     630:	ff 93       	push	r31
     632:	df 93       	push	r29
     634:	cf 93       	push	r28
     636:	00 d0       	rcall	.+0      	; 0x638 <__vector_2+0x28>
     638:	00 d0       	rcall	.+0      	; 0x63a <__vector_2+0x2a>
     63a:	0f 92       	push	r0
     63c:	cd b7       	in	r28, 0x3d	; 61
     63e:	de b7       	in	r29, 0x3e	; 62
		
	CAN_message received;
	received.data = "\0\0\0\0\0\0\0\0";
     640:	8f e6       	ldi	r24, 0x6F	; 111
     642:	91 e0       	ldi	r25, 0x01	; 1
     644:	9d 83       	std	Y+5, r25	; 0x05
     646:	8c 83       	std	Y+4, r24	; 0x04

	printf("Received interrupt1: ");
     648:	00 d0       	rcall	.+0      	; 0x64a <__vector_2+0x3a>
     64a:	ed b7       	in	r30, 0x3d	; 61
     64c:	fe b7       	in	r31, 0x3e	; 62
     64e:	31 96       	adiw	r30, 0x01	; 1
     650:	8e e8       	ldi	r24, 0x8E	; 142
     652:	91 e0       	ldi	r25, 0x01	; 1
     654:	91 83       	std	Z+1, r25	; 0x01
     656:	80 83       	st	Z, r24
     658:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
     65c:	0f 90       	pop	r0
     65e:	0f 90       	pop	r0
    CAN_receive(&received, 1);
     660:	ce 01       	movw	r24, r28
     662:	01 96       	adiw	r24, 0x01	; 1
     664:	61 e0       	ldi	r22, 0x01	; 1
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	0e 94 75 02 	call	0x4ea	; 0x4ea <CAN_receive>
	printf("%s\n", received.data);
     66c:	8c 81       	ldd	r24, Y+4	; 0x04
     66e:	9d 81       	ldd	r25, Y+5	; 0x05
     670:	0e 94 22 06 	call	0xc44	; 0xc44 <puts>
}
     674:	0f 90       	pop	r0
     676:	0f 90       	pop	r0
     678:	0f 90       	pop	r0
     67a:	0f 90       	pop	r0
     67c:	0f 90       	pop	r0
     67e:	cf 91       	pop	r28
     680:	df 91       	pop	r29
     682:	ff 91       	pop	r31
     684:	ef 91       	pop	r30
     686:	bf 91       	pop	r27
     688:	af 91       	pop	r26
     68a:	9f 91       	pop	r25
     68c:	8f 91       	pop	r24
     68e:	7f 91       	pop	r23
     690:	6f 91       	pop	r22
     692:	5f 91       	pop	r21
     694:	4f 91       	pop	r20
     696:	3f 91       	pop	r19
     698:	2f 91       	pop	r18
     69a:	0f 90       	pop	r0
     69c:	0f be       	out	0x3f, r0	; 63
     69e:	0f 90       	pop	r0
     6a0:	1f 90       	pop	r1
     6a2:	18 95       	reti

000006a4 <butterfly_poll_joystick>:
	

	sei(); //enable interrupts again
}

char butterfly_poll_joystick(){
     6a4:	1f 93       	push	r17
	char button;	

	cli(); //disable interrupts to protect SPI-communication
     6a6:	f8 94       	cli
	SPI_SelectSlave(SPI_BUTTERFLY);
     6a8:	82 e6       	ldi	r24, 0x62	; 98
     6aa:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
	SPI_MasterTransmit('.');
     6ae:	8e e2       	ldi	r24, 0x2E	; 46
     6b0:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	90 e3       	ldi	r25, 0x30	; 48
     6b8:	01 97       	sbiw	r24, 0x01	; 1
     6ba:	f1 f7       	brne	.-4      	; 0x6b8 <butterfly_poll_joystick+0x14>
	_delay_ms(10);
	button = SPI_MasterReceive();
     6bc:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_MasterReceive>
     6c0:	18 2f       	mov	r17, r24
	SPI_NoSlave();
     6c2:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>

	sei(); //enable interrupts again
     6c6:	78 94       	sei
	return button;
}
     6c8:	81 2f       	mov	r24, r17
     6ca:	1f 91       	pop	r17
     6cc:	08 95       	ret

000006ce <butterfly_print>:
			}
		}
	}
}

void butterfly_print(char * str){
     6ce:	0f 93       	push	r16
     6d0:	1f 93       	push	r17
     6d2:	cf 93       	push	r28
     6d4:	df 93       	push	r29
     6d6:	8c 01       	movw	r16, r24
	int i;
	cli(); //disable interrupts to protect SPI-communication
     6d8:	f8 94       	cli
	SPI_SelectSlave(SPI_BUTTERFLY);
     6da:	82 e6       	ldi	r24, 0x62	; 98
     6dc:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
     6e0:	c0 e0       	ldi	r28, 0x00	; 0
     6e2:	d0 e0       	ldi	r29, 0x00	; 0
	for (i = 0; i < TEXTBUFFER_SIZE-1; i++){ 
		if (str[i] == '\0') break;
     6e4:	f8 01       	movw	r30, r16
     6e6:	ec 0f       	add	r30, r28
     6e8:	fd 1f       	adc	r31, r29
     6ea:	80 81       	ld	r24, Z
     6ec:	88 23       	and	r24, r24
     6ee:	31 f0       	breq	.+12     	; 0x6fc <butterfly_print+0x2e>
		SPI_MasterTransmit(str[i]);
     6f0:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>

void butterfly_print(char * str){
	int i;
	cli(); //disable interrupts to protect SPI-communication
	SPI_SelectSlave(SPI_BUTTERFLY);
	for (i = 0; i < TEXTBUFFER_SIZE-1; i++){ 
     6f4:	21 96       	adiw	r28, 0x01	; 1
     6f6:	c8 31       	cpi	r28, 0x18	; 24
     6f8:	d1 05       	cpc	r29, r1
     6fa:	a1 f7       	brne	.-24     	; 0x6e4 <butterfly_print+0x16>
		if (str[i] == '\0') break;
		SPI_MasterTransmit(str[i]);
	}
	SPI_MasterTransmit('\0');
     6fc:	80 e0       	ldi	r24, 0x00	; 0
     6fe:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_NoSlave();
     702:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
	

	sei(); //enable interrupts again
     706:	78 94       	sei
}
     708:	df 91       	pop	r29
     70a:	cf 91       	pop	r28
     70c:	1f 91       	pop	r17
     70e:	0f 91       	pop	r16
     710:	08 95       	ret

00000712 <start_game>:
	sei(); //enable interrupts again
	return button;
}

void start_game(enum menu_state_enum menu_state){
	switch(menu_state) {
     712:	81 30       	cpi	r24, 0x01	; 1
     714:	69 f0       	breq	.+26     	; 0x730 <start_game+0x1e>
     716:	82 30       	cpi	r24, 0x02	; 2
     718:	1c f4       	brge	.+6      	; 0x720 <start_game+0xe>
     71a:	88 23       	and	r24, r24
     71c:	31 f0       	breq	.+12     	; 0x72a <start_game+0x18>
     71e:	08 95       	ret
     720:	82 30       	cpi	r24, 0x02	; 2
     722:	49 f0       	breq	.+18     	; 0x736 <start_game+0x24>
     724:	83 30       	cpi	r24, 0x03	; 3
     726:	b9 f4       	brne	.+46     	; 0x756 <start_game+0x44>
     728:	09 c0       	rjmp	.+18     	; 0x73c <start_game+0x2a>
		case START_SP_POINTS: 
			butterfly_print("enspiller poeng");
     72a:	84 ea       	ldi	r24, 0xA4	; 164
     72c:	91 e0       	ldi	r25, 0x01	; 1
     72e:	08 c0       	rjmp	.+16     	; 0x740 <start_game+0x2e>
			break;
		case START_SP_ETERNAL: 
			butterfly_print("enspiller evig");
     730:	84 eb       	ldi	r24, 0xB4	; 180
     732:	91 e0       	ldi	r25, 0x01	; 1
     734:	05 c0       	rjmp	.+10     	; 0x740 <start_game+0x2e>
			break;
		case START_MP_POINTS: 	
			butterfly_print("versus poeng");
     736:	83 ec       	ldi	r24, 0xC3	; 195
     738:	91 e0       	ldi	r25, 0x01	; 1
     73a:	02 c0       	rjmp	.+4      	; 0x740 <start_game+0x2e>
			break;
		case START_MP_ETERNAL: 	
			butterfly_print("versus evig");	
     73c:	80 ed       	ldi	r24, 0xD0	; 208
     73e:	91 e0       	ldi	r25, 0x01	; 1
     740:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     744:	80 e2       	ldi	r24, 0x20	; 32
     746:	9e e4       	ldi	r25, 0x4E	; 78
     748:	2a e7       	ldi	r18, 0x7A	; 122
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	f9 01       	movw	r30, r18
     74e:	31 97       	sbiw	r30, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <start_game+0x3c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     752:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     754:	d9 f7       	brne	.-10     	; 0x74c <start_game+0x3a>
     756:	08 95       	ret

00000758 <butterfly_joystick_test>:
			}
		}
	}	
}

void butterfly_joystick_test(){
     758:	0f 93       	push	r16
     75a:	1f 93       	push	r17
     75c:	00 e3       	ldi	r16, 0x30	; 48
     75e:	01 c0       	rjmp	.+2      	; 0x762 <butterfly_joystick_test+0xa>
     760:	01 2f       	mov	r16, r17
	char button = '0',last_button;

	while(1){
		last_button = button;
		
		button = butterfly_poll_joystick();
     762:	0e 94 52 03 	call	0x6a4	; 0x6a4 <butterfly_poll_joystick>
     766:	18 2f       	mov	r17, r24

		if(button != last_button){
     768:	80 17       	cp	r24, r16
     76a:	d1 f3       	breq	.-12     	; 0x760 <butterfly_joystick_test+0x8>
			switch(button) {
     76c:	85 36       	cpi	r24, 0x65	; 101
     76e:	c9 f0       	breq	.+50     	; 0x7a2 <butterfly_joystick_test+0x4a>
     770:	86 36       	cpi	r24, 0x66	; 102
     772:	28 f4       	brcc	.+10     	; 0x77e <butterfly_joystick_test+0x26>
     774:	80 33       	cpi	r24, 0x30	; 48
     776:	c1 f0       	breq	.+48     	; 0x7a8 <butterfly_joystick_test+0x50>
     778:	84 36       	cpi	r24, 0x64	; 100
     77a:	c9 f4       	brne	.+50     	; 0x7ae <butterfly_joystick_test+0x56>
     77c:	0f c0       	rjmp	.+30     	; 0x79c <butterfly_joystick_test+0x44>
     77e:	82 37       	cpi	r24, 0x72	; 114
     780:	39 f0       	breq	.+14     	; 0x790 <butterfly_joystick_test+0x38>
     782:	85 37       	cpi	r24, 0x75	; 117
     784:	41 f0       	breq	.+16     	; 0x796 <butterfly_joystick_test+0x3e>
     786:	8c 36       	cpi	r24, 0x6C	; 108
     788:	91 f4       	brne	.+36     	; 0x7ae <butterfly_joystick_test+0x56>
				case 'l': butterfly_print("left");		break;
     78a:	8c ed       	ldi	r24, 0xDC	; 220
     78c:	91 e0       	ldi	r25, 0x01	; 1
     78e:	11 c0       	rjmp	.+34     	; 0x7b2 <butterfly_joystick_test+0x5a>
				case 'r': butterfly_print("right");		break;
     790:	81 ee       	ldi	r24, 0xE1	; 225
     792:	91 e0       	ldi	r25, 0x01	; 1
     794:	0e c0       	rjmp	.+28     	; 0x7b2 <butterfly_joystick_test+0x5a>
				case 'u': butterfly_print("up");		break;
     796:	87 ee       	ldi	r24, 0xE7	; 231
     798:	91 e0       	ldi	r25, 0x01	; 1
     79a:	0b c0       	rjmp	.+22     	; 0x7b2 <butterfly_joystick_test+0x5a>
				case 'd': butterfly_print("down");		break;
     79c:	8a ee       	ldi	r24, 0xEA	; 234
     79e:	91 e0       	ldi	r25, 0x01	; 1
     7a0:	08 c0       	rjmp	.+16     	; 0x7b2 <butterfly_joystick_test+0x5a>
				case 'e': butterfly_print("enter");		break;
     7a2:	8f ee       	ldi	r24, 0xEF	; 239
     7a4:	91 e0       	ldi	r25, 0x01	; 1
     7a6:	05 c0       	rjmp	.+10     	; 0x7b2 <butterfly_joystick_test+0x5a>
				case '0': butterfly_print("center");	break;
     7a8:	85 ef       	ldi	r24, 0xF5	; 245
     7aa:	91 e0       	ldi	r25, 0x01	; 1
     7ac:	02 c0       	rjmp	.+4      	; 0x7b2 <butterfly_joystick_test+0x5a>
				default:  butterfly_print("error");		break;
     7ae:	8c ef       	ldi	r24, 0xFC	; 252
     7b0:	91 e0       	ldi	r25, 0x01	; 1
     7b2:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     7b6:	d4 cf       	rjmp	.-88     	; 0x760 <butterfly_joystick_test+0x8>

000007b8 <butterfly_menu>:

char butterfly_poll_joystick(void);

enum menu_state_enum {OVER_THE_TOP = -1, START_SP_POINTS, START_SP_ETERNAL, START_MP_POINTS, START_MP_ETERNAL, BELOW_THE_BOTTOM};

void butterfly_menu(){
     7b8:	af 92       	push	r10
     7ba:	bf 92       	push	r11
     7bc:	cf 92       	push	r12
     7be:	df 92       	push	r13
     7c0:	ff 92       	push	r15
     7c2:	0f 93       	push	r16
     7c4:	1f 93       	push	r17
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
	enum menu_state_enum menu_state = OVER_THE_TOP;
	char button = '0',last_button;

	butterfly_print("Velkommen");
     7ca:	82 e0       	ldi	r24, 0x02	; 2
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     7d2:	1f ef       	ldi	r17, 0xFF	; 255
     7d4:	20 e3       	ldi	r18, 0x30	; 48
     7d6:	f2 2e       	mov	r15, r18
		last_button = button;
		
		button = butterfly_poll_joystick();

		if(button != last_button){
			printf("state for: %d\n", menu_state);
     7d8:	9c e0       	ldi	r25, 0x0C	; 12
     7da:	a9 2e       	mov	r10, r25
     7dc:	92 e0       	ldi	r25, 0x02	; 2
     7de:	b9 2e       	mov	r11, r25
				case 'd': menu_state++;				break;
				case 'e': start_game(menu_state);	break;
				case '0': 							continue;
				default:  butterfly_print("error");	break;
			}
			printf("state etter: %d\n", menu_state);
     7e0:	8b e1       	ldi	r24, 0x1B	; 27
     7e2:	c8 2e       	mov	r12, r24
     7e4:	82 e0       	ldi	r24, 0x02	; 2
     7e6:	d8 2e       	mov	r13, r24
     7e8:	02 c0       	rjmp	.+4      	; 0x7ee <butterfly_menu+0x36>

void butterfly_menu(){
	enum menu_state_enum menu_state = OVER_THE_TOP;
	char button = '0',last_button;

	butterfly_print("Velkommen");
     7ea:	10 e0       	ldi	r17, 0x00	; 0
     7ec:	f0 2e       	mov	r15, r16

	while(1){
		last_button = button;
		
		button = butterfly_poll_joystick();
     7ee:	0e 94 52 03 	call	0x6a4	; 0x6a4 <butterfly_poll_joystick>
     7f2:	08 2f       	mov	r16, r24

		if(button != last_button){
     7f4:	8f 15       	cp	r24, r15
     7f6:	d1 f3       	breq	.-12     	; 0x7ec <butterfly_menu+0x34>
			printf("state for: %d\n", menu_state);
     7f8:	c1 2f       	mov	r28, r17
     7fa:	dd 27       	eor	r29, r29
     7fc:	c7 fd       	sbrc	r28, 7
     7fe:	d0 95       	com	r29
     800:	00 d0       	rcall	.+0      	; 0x802 <butterfly_menu+0x4a>
     802:	00 d0       	rcall	.+0      	; 0x804 <butterfly_menu+0x4c>
     804:	ed b7       	in	r30, 0x3d	; 61
     806:	fe b7       	in	r31, 0x3e	; 62
     808:	b2 82       	std	Z+2, r11	; 0x02
     80a:	a1 82       	std	Z+1, r10	; 0x01
     80c:	d4 83       	std	Z+4, r29	; 0x04
     80e:	c3 83       	std	Z+3, r28	; 0x03
     810:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
			switch(button) {
     814:	0f 90       	pop	r0
     816:	0f 90       	pop	r0
     818:	0f 90       	pop	r0
     81a:	0f 90       	pop	r0
     81c:	05 36       	cpi	r16, 0x65	; 101
     81e:	91 f0       	breq	.+36     	; 0x844 <butterfly_menu+0x8c>
     820:	06 36       	cpi	r16, 0x66	; 102
     822:	28 f4       	brcc	.+10     	; 0x82e <butterfly_menu+0x76>
     824:	00 33       	cpi	r16, 0x30	; 48
     826:	11 f3       	breq	.-60     	; 0x7ec <butterfly_menu+0x34>
     828:	04 36       	cpi	r16, 0x64	; 100
     82a:	81 f4       	brne	.+32     	; 0x84c <butterfly_menu+0x94>
     82c:	09 c0       	rjmp	.+18     	; 0x840 <butterfly_menu+0x88>
     82e:	02 37       	cpi	r16, 0x72	; 114
     830:	e9 f2       	breq	.-70     	; 0x7ec <butterfly_menu+0x34>
     832:	05 37       	cpi	r16, 0x75	; 117
     834:	19 f0       	breq	.+6      	; 0x83c <butterfly_menu+0x84>
     836:	0c 36       	cpi	r16, 0x6C	; 108
     838:	49 f4       	brne	.+18     	; 0x84c <butterfly_menu+0x94>
     83a:	d8 cf       	rjmp	.-80     	; 0x7ec <butterfly_menu+0x34>
				case 'l': 					
				case 'r': 							continue;
				case 'u': menu_state--;				break;
     83c:	11 50       	subi	r17, 0x01	; 1
     83e:	0a c0       	rjmp	.+20     	; 0x854 <butterfly_menu+0x9c>
				case 'd': menu_state++;				break;
     840:	1f 5f       	subi	r17, 0xFF	; 255
     842:	08 c0       	rjmp	.+16     	; 0x854 <butterfly_menu+0x9c>
				case 'e': start_game(menu_state);	break;
     844:	ce 01       	movw	r24, r28
     846:	0e 94 89 03 	call	0x712	; 0x712 <start_game>
     84a:	04 c0       	rjmp	.+8      	; 0x854 <butterfly_menu+0x9c>
				case '0': 							continue;
				default:  butterfly_print("error");	break;
     84c:	8c ef       	ldi	r24, 0xFC	; 252
     84e:	91 e0       	ldi	r25, 0x01	; 1
     850:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
			}
			printf("state etter: %d\n", menu_state);
     854:	00 d0       	rcall	.+0      	; 0x856 <butterfly_menu+0x9e>
     856:	00 d0       	rcall	.+0      	; 0x858 <butterfly_menu+0xa0>
     858:	ed b7       	in	r30, 0x3d	; 61
     85a:	fe b7       	in	r31, 0x3e	; 62
     85c:	d2 82       	std	Z+2, r13	; 0x02
     85e:	c1 82       	std	Z+1, r12	; 0x01
     860:	81 2f       	mov	r24, r17
     862:	99 27       	eor	r25, r25
     864:	87 fd       	sbrc	r24, 7
     866:	90 95       	com	r25
     868:	94 83       	std	Z+4, r25	; 0x04
     86a:	83 83       	std	Z+3, r24	; 0x03
     86c:	0e 94 06 06 	call	0xc0c	; 0xc0c <printf>
			if (menu_state <= OVER_THE_TOP) menu_state = BELOW_THE_BOTTOM-1;
     870:	0f 90       	pop	r0
     872:	0f 90       	pop	r0
     874:	0f 90       	pop	r0
     876:	0f 90       	pop	r0
     878:	17 fd       	sbrc	r17, 7
     87a:	1c c0       	rjmp	.+56     	; 0x8b4 <butterfly_menu+0xfc>
			if (menu_state >= BELOW_THE_BOTTOM) menu_state = OVER_THE_TOP+1;
     87c:	14 30       	cpi	r17, 0x04	; 4
     87e:	6c f4       	brge	.+26     	; 0x89a <butterfly_menu+0xe2>
			switch(menu_state) {
     880:	11 30       	cpi	r17, 0x01	; 1
     882:	81 f0       	breq	.+32     	; 0x8a4 <butterfly_menu+0xec>
     884:	12 30       	cpi	r17, 0x02	; 2
     886:	1c f4       	brge	.+6      	; 0x88e <butterfly_menu+0xd6>
     888:	11 23       	and	r17, r17
     88a:	39 f0       	breq	.+14     	; 0x89a <butterfly_menu+0xe2>
     88c:	ae cf       	rjmp	.-164    	; 0x7ea <butterfly_menu+0x32>
     88e:	12 30       	cpi	r17, 0x02	; 2
     890:	61 f0       	breq	.+24     	; 0x8aa <butterfly_menu+0xf2>
     892:	13 30       	cpi	r17, 0x03	; 3
     894:	09 f0       	breq	.+2      	; 0x898 <butterfly_menu+0xe0>
     896:	a9 cf       	rjmp	.-174    	; 0x7ea <butterfly_menu+0x32>
     898:	0d c0       	rjmp	.+26     	; 0x8b4 <butterfly_menu+0xfc>
				case START_SP_POINTS: 	butterfly_print("1 Start enspiller poeng");		break;
     89a:	8c e2       	ldi	r24, 0x2C	; 44
     89c:	92 e0       	ldi	r25, 0x02	; 2
     89e:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     8a2:	a3 cf       	rjmp	.-186    	; 0x7ea <butterfly_menu+0x32>
				case START_SP_ETERNAL: 	butterfly_print("2 Start enspiller evig");		break;
     8a4:	84 e4       	ldi	r24, 0x44	; 68
     8a6:	92 e0       	ldi	r25, 0x02	; 2
     8a8:	02 c0       	rjmp	.+4      	; 0x8ae <butterfly_menu+0xf6>
				case START_MP_POINTS: 	butterfly_print("3 Start flersp poeng");		break;
     8aa:	8b e5       	ldi	r24, 0x5B	; 91
     8ac:	92 e0       	ldi	r25, 0x02	; 2
     8ae:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     8b2:	9c cf       	rjmp	.-200    	; 0x7ec <butterfly_menu+0x34>
				case START_MP_ETERNAL: 	butterfly_print("4 Start flersp evig");		break;
     8b4:	80 e7       	ldi	r24, 0x70	; 112
     8b6:	92 e0       	ldi	r25, 0x02	; 2
     8b8:	0e 94 67 03 	call	0x6ce	; 0x6ce <butterfly_print>
     8bc:	13 e0       	ldi	r17, 0x03	; 3
     8be:	96 cf       	rjmp	.-212    	; 0x7ec <butterfly_menu+0x34>

000008c0 <CAN_reset>:
#include "mcp2515.h"
#include "spi.h"

// Reset the CAN chip
void CAN_reset(void){
     8c0:	df 93       	push	r29
     8c2:	cf 93       	push	r28
     8c4:	cd b7       	in	r28, 0x3d	; 61
     8c6:	de b7       	in	r29, 0x3e	; 62
	SPI_SelectSlave(SPI_CAN);
     8c8:	83 e7       	ldi	r24, 0x73	; 115
     8ca:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
	SPI_MasterTransmit(INS_RESET);
     8ce:	80 ec       	ldi	r24, 0xC0	; 192
     8d0:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_NoSlave();
     8d4:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
}
     8d8:	cf 91       	pop	r28
     8da:	df 91       	pop	r29
     8dc:	08 95       	ret

000008de <CAN_read>:

// Read
void CAN_read(char* data, uint8_t address , int data_count){
     8de:	0f 93       	push	r16
     8e0:	1f 93       	push	r17
     8e2:	df 93       	push	r29
     8e4:	cf 93       	push	r28
     8e6:	cd b7       	in	r28, 0x3d	; 61
     8e8:	de b7       	in	r29, 0x3e	; 62
     8ea:	27 97       	sbiw	r28, 0x07	; 7
     8ec:	0f b6       	in	r0, 0x3f	; 63
     8ee:	f8 94       	cli
     8f0:	de bf       	out	0x3e, r29	; 62
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	cd bf       	out	0x3d, r28	; 61
     8f6:	9c 83       	std	Y+4, r25	; 0x04
     8f8:	8b 83       	std	Y+3, r24	; 0x03
     8fa:	6d 83       	std	Y+5, r22	; 0x05
     8fc:	5f 83       	std	Y+7, r21	; 0x07
     8fe:	4e 83       	std	Y+6, r20	; 0x06
	int i;
	SPI_SelectSlave(SPI_CAN);	
     900:	83 e7       	ldi	r24, 0x73	; 115
     902:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_READ);
     906:	83 e0       	ldi	r24, 0x03	; 3
     908:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     90c:	8d 81       	ldd	r24, Y+5	; 0x05
     90e:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	for(i = 0; i < data_count; i++){
     912:	1a 82       	std	Y+2, r1	; 0x02
     914:	19 82       	std	Y+1, r1	; 0x01
     916:	10 c0       	rjmp	.+32     	; 0x938 <CAN_read+0x5a>
		data[i] = SPI_MasterReceive();
     918:	29 81       	ldd	r18, Y+1	; 0x01
     91a:	3a 81       	ldd	r19, Y+2	; 0x02
     91c:	8b 81       	ldd	r24, Y+3	; 0x03
     91e:	9c 81       	ldd	r25, Y+4	; 0x04
     920:	8c 01       	movw	r16, r24
     922:	02 0f       	add	r16, r18
     924:	13 1f       	adc	r17, r19
     926:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_MasterReceive>
     92a:	f8 01       	movw	r30, r16
     92c:	80 83       	st	Z, r24
	int i;
	SPI_SelectSlave(SPI_CAN);	

	SPI_MasterTransmit(INS_READ);
	SPI_MasterTransmit((char)address);
	for(i = 0; i < data_count; i++){
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	9a 81       	ldd	r25, Y+2	; 0x02
     932:	01 96       	adiw	r24, 0x01	; 1
     934:	9a 83       	std	Y+2, r25	; 0x02
     936:	89 83       	std	Y+1, r24	; 0x01
     938:	29 81       	ldd	r18, Y+1	; 0x01
     93a:	3a 81       	ldd	r19, Y+2	; 0x02
     93c:	8e 81       	ldd	r24, Y+6	; 0x06
     93e:	9f 81       	ldd	r25, Y+7	; 0x07
     940:	28 17       	cp	r18, r24
     942:	39 07       	cpc	r19, r25
     944:	4c f3       	brlt	.-46     	; 0x918 <CAN_read+0x3a>
		data[i] = SPI_MasterReceive();
	}

	SPI_NoSlave();
     946:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>

}
     94a:	27 96       	adiw	r28, 0x07	; 7
     94c:	0f b6       	in	r0, 0x3f	; 63
     94e:	f8 94       	cli
     950:	de bf       	out	0x3e, r29	; 62
     952:	0f be       	out	0x3f, r0	; 63
     954:	cd bf       	out	0x3d, r28	; 61
     956:	cf 91       	pop	r28
     958:	df 91       	pop	r29
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	08 95       	ret

00000960 <CAN_read_rx>:

void CAN_read_rx(CAN_message* msg, uint8_t rx){
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	df 93       	push	r29
     966:	cf 93       	push	r28
     968:	00 d0       	rcall	.+0      	; 0x96a <CAN_read_rx+0xa>
     96a:	00 d0       	rcall	.+0      	; 0x96c <CAN_read_rx+0xc>
     96c:	0f 92       	push	r0
     96e:	cd b7       	in	r28, 0x3d	; 61
     970:	de b7       	in	r29, 0x3e	; 62
     972:	9c 83       	std	Y+4, r25	; 0x04
     974:	8b 83       	std	Y+3, r24	; 0x03
     976:	6d 83       	std	Y+5, r22	; 0x05
	int i;
	if (rx>1)
     978:	8d 81       	ldd	r24, Y+5	; 0x05
     97a:	82 30       	cpi	r24, 0x02	; 2
     97c:	90 f5       	brcc	.+100    	; 0x9e2 <CAN_read_rx+0x82>
		return;
	if(rx == 0) rx = 1; //decode rx0 to word for "read from rxb0", standard frame
     97e:	8d 81       	ldd	r24, Y+5	; 0x05
     980:	88 23       	and	r24, r24
     982:	19 f4       	brne	.+6      	; 0x98a <CAN_read_rx+0x2a>
     984:	81 e0       	ldi	r24, 0x01	; 1
     986:	8d 83       	std	Y+5, r24	; 0x05
     988:	05 c0       	rjmp	.+10     	; 0x994 <CAN_read_rx+0x34>
	else if(rx == 1) rx = 3; //decode rx1 to intruction for "read from rxb1", standard frame
     98a:	8d 81       	ldd	r24, Y+5	; 0x05
     98c:	81 30       	cpi	r24, 0x01	; 1
     98e:	11 f4       	brne	.+4      	; 0x994 <CAN_read_rx+0x34>
     990:	83 e0       	ldi	r24, 0x03	; 3
     992:	8d 83       	std	Y+5, r24	; 0x05
	
	SPI_SelectSlave(SPI_CAN);	
     994:	83 e7       	ldi	r24, 0x73	; 115
     996:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
	SPI_MasterTransmit(INS_READ_RX | (rx<<1));
     99a:	8d 81       	ldd	r24, Y+5	; 0x05
     99c:	88 2f       	mov	r24, r24
     99e:	90 e0       	ldi	r25, 0x00	; 0
     9a0:	88 0f       	add	r24, r24
     9a2:	99 1f       	adc	r25, r25
     9a4:	80 69       	ori	r24, 0x90	; 144
     9a6:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	for (i = 0; i < 8; i++){
     9aa:	1a 82       	std	Y+2, r1	; 0x02
     9ac:	19 82       	std	Y+1, r1	; 0x01
     9ae:	12 c0       	rjmp	.+36     	; 0x9d4 <CAN_read_rx+0x74>
		msg->data[i] = SPI_MasterReceive();
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	23 81       	ldd	r18, Z+3	; 0x03
     9b6:	34 81       	ldd	r19, Z+4	; 0x04
     9b8:	89 81       	ldd	r24, Y+1	; 0x01
     9ba:	9a 81       	ldd	r25, Y+2	; 0x02
     9bc:	89 01       	movw	r16, r18
     9be:	08 0f       	add	r16, r24
     9c0:	19 1f       	adc	r17, r25
     9c2:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_MasterReceive>
     9c6:	f8 01       	movw	r30, r16
     9c8:	80 83       	st	Z, r24
	if(rx == 0) rx = 1; //decode rx0 to word for "read from rxb0", standard frame
	else if(rx == 1) rx = 3; //decode rx1 to intruction for "read from rxb1", standard frame
	
	SPI_SelectSlave(SPI_CAN);	
	SPI_MasterTransmit(INS_READ_RX | (rx<<1));
	for (i = 0; i < 8; i++){
     9ca:	89 81       	ldd	r24, Y+1	; 0x01
     9cc:	9a 81       	ldd	r25, Y+2	; 0x02
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	9a 83       	std	Y+2, r25	; 0x02
     9d2:	89 83       	std	Y+1, r24	; 0x01
     9d4:	89 81       	ldd	r24, Y+1	; 0x01
     9d6:	9a 81       	ldd	r25, Y+2	; 0x02
     9d8:	88 30       	cpi	r24, 0x08	; 8
     9da:	91 05       	cpc	r25, r1
     9dc:	4c f3       	brlt	.-46     	; 0x9b0 <CAN_read_rx+0x50>
		msg->data[i] = SPI_MasterReceive();
	}
	
	SPI_NoSlave();
     9de:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
}
     9e2:	0f 90       	pop	r0
     9e4:	0f 90       	pop	r0
     9e6:	0f 90       	pop	r0
     9e8:	0f 90       	pop	r0
     9ea:	0f 90       	pop	r0
     9ec:	cf 91       	pop	r28
     9ee:	df 91       	pop	r29
     9f0:	1f 91       	pop	r17
     9f2:	0f 91       	pop	r16
     9f4:	08 95       	ret

000009f6 <CAN_write>:

void CAN_write(char data, uint8_t address){
     9f6:	df 93       	push	r29
     9f8:	cf 93       	push	r28
     9fa:	00 d0       	rcall	.+0      	; 0x9fc <CAN_write+0x6>
     9fc:	00 d0       	rcall	.+0      	; 0x9fe <CAN_write+0x8>
     9fe:	cd b7       	in	r28, 0x3d	; 61
     a00:	de b7       	in	r29, 0x3e	; 62
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	6c 83       	std	Y+4, r22	; 0x04
	int i;
	SPI_SelectSlave(SPI_CAN);	
     a06:	83 e7       	ldi	r24, 0x73	; 115
     a08:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_WRITE);
     a0c:	82 e0       	ldi	r24, 0x02	; 2
     a0e:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     a12:	8c 81       	ldd	r24, Y+4	; 0x04
     a14:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
		SPI_MasterTransmit(data);
     a18:	8b 81       	ldd	r24, Y+3	; 0x03
     a1a:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>

	SPI_NoSlave();
     a1e:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>

}
     a22:	0f 90       	pop	r0
     a24:	0f 90       	pop	r0
     a26:	0f 90       	pop	r0
     a28:	0f 90       	pop	r0
     a2a:	cf 91       	pop	r28
     a2c:	df 91       	pop	r29
     a2e:	08 95       	ret

00000a30 <CAN_load_tx>:
//tx = "modul" (3 output "kanaler")
void CAN_load_tx(char* msg, uint8_t tx){
     a30:	df 93       	push	r29
     a32:	cf 93       	push	r28
     a34:	00 d0       	rcall	.+0      	; 0xa36 <CAN_load_tx+0x6>
     a36:	00 d0       	rcall	.+0      	; 0xa38 <CAN_load_tx+0x8>
     a38:	0f 92       	push	r0
     a3a:	cd b7       	in	r28, 0x3d	; 61
     a3c:	de b7       	in	r29, 0x3e	; 62
     a3e:	9c 83       	std	Y+4, r25	; 0x04
     a40:	8b 83       	std	Y+3, r24	; 0x03
     a42:	6d 83       	std	Y+5, r22	; 0x05
	int i;
	if (tx>2)
     a44:	8d 81       	ldd	r24, Y+5	; 0x05
     a46:	83 30       	cpi	r24, 0x03	; 3
     a48:	60 f5       	brcc	.+88     	; 0xaa2 <CAN_load_tx+0x72>
		return;
	tx = (tx+1)*2 - 1; //convert to abc-format as explained in table 12-5
     a4a:	8d 81       	ldd	r24, Y+5	; 0x05
     a4c:	88 2f       	mov	r24, r24
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	01 96       	adiw	r24, 0x01	; 1
     a52:	88 0f       	add	r24, r24
     a54:	99 1f       	adc	r25, r25
     a56:	81 50       	subi	r24, 0x01	; 1
     a58:	8d 83       	std	Y+5, r24	; 0x05
	SPI_SelectSlave(SPI_CAN);
     a5a:	83 e7       	ldi	r24, 0x73	; 115
     a5c:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
	
	SPI_MasterTransmit(INS_LOAD_TX | tx);
     a60:	8d 81       	ldd	r24, Y+5	; 0x05
     a62:	80 64       	ori	r24, 0x40	; 64
     a64:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	for(i = 0; i < 8; i++){
     a68:	1a 82       	std	Y+2, r1	; 0x02
     a6a:	19 82       	std	Y+1, r1	; 0x01
     a6c:	0f c0       	rjmp	.+30     	; 0xa8c <CAN_load_tx+0x5c>
		//printf("%c", data[i]);
		SPI_MasterTransmit(msg[i]);
     a6e:	29 81       	ldd	r18, Y+1	; 0x01
     a70:	3a 81       	ldd	r19, Y+2	; 0x02
     a72:	8b 81       	ldd	r24, Y+3	; 0x03
     a74:	9c 81       	ldd	r25, Y+4	; 0x04
     a76:	fc 01       	movw	r30, r24
     a78:	e2 0f       	add	r30, r18
     a7a:	f3 1f       	adc	r31, r19
     a7c:	80 81       	ld	r24, Z
     a7e:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
		return;
	tx = (tx+1)*2 - 1; //convert to abc-format as explained in table 12-5
	SPI_SelectSlave(SPI_CAN);
	
	SPI_MasterTransmit(INS_LOAD_TX | tx);
	for(i = 0; i < 8; i++){
     a82:	89 81       	ldd	r24, Y+1	; 0x01
     a84:	9a 81       	ldd	r25, Y+2	; 0x02
     a86:	01 96       	adiw	r24, 0x01	; 1
     a88:	9a 83       	std	Y+2, r25	; 0x02
     a8a:	89 83       	std	Y+1, r24	; 0x01
     a8c:	89 81       	ldd	r24, Y+1	; 0x01
     a8e:	9a 81       	ldd	r25, Y+2	; 0x02
     a90:	88 30       	cpi	r24, 0x08	; 8
     a92:	91 05       	cpc	r25, r1
     a94:	64 f3       	brlt	.-40     	; 0xa6e <CAN_load_tx+0x3e>
		//printf("%c", data[i]);
		SPI_MasterTransmit(msg[i]);
	}

	SPI_NoSlave();
     a96:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
	printf("\n");
     a9a:	8a e0       	ldi	r24, 0x0A	; 10
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	0e 94 1b 06 	call	0xc36	; 0xc36 <putchar>
}
     aa2:	0f 90       	pop	r0
     aa4:	0f 90       	pop	r0
     aa6:	0f 90       	pop	r0
     aa8:	0f 90       	pop	r0
     aaa:	0f 90       	pop	r0
     aac:	cf 91       	pop	r28
     aae:	df 91       	pop	r29
     ab0:	08 95       	ret

00000ab2 <CAN_rts>:

void CAN_rts(uint8_t tx){
     ab2:	df 93       	push	r29
     ab4:	cf 93       	push	r28
     ab6:	0f 92       	push	r0
     ab8:	cd b7       	in	r28, 0x3d	; 61
     aba:	de b7       	in	r29, 0x3e	; 62
     abc:	89 83       	std	Y+1, r24	; 0x01
	if (tx == 0) tx = 1;
     abe:	89 81       	ldd	r24, Y+1	; 0x01
     ac0:	88 23       	and	r24, r24
     ac2:	19 f4       	brne	.+6      	; 0xaca <CAN_rts+0x18>
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	89 83       	std	Y+1, r24	; 0x01
     ac8:	0b c0       	rjmp	.+22     	; 0xae0 <CAN_rts+0x2e>
	else if (tx == 1) tx = 2;
     aca:	89 81       	ldd	r24, Y+1	; 0x01
     acc:	81 30       	cpi	r24, 0x01	; 1
     ace:	19 f4       	brne	.+6      	; 0xad6 <CAN_rts+0x24>
     ad0:	82 e0       	ldi	r24, 0x02	; 2
     ad2:	89 83       	std	Y+1, r24	; 0x01
     ad4:	05 c0       	rjmp	.+10     	; 0xae0 <CAN_rts+0x2e>
	else if (tx == 2) tx = 4;
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	82 30       	cpi	r24, 0x02	; 2
     ada:	59 f4       	brne	.+22     	; 0xaf2 <CAN_rts+0x40>
     adc:	84 e0       	ldi	r24, 0x04	; 4
     ade:	89 83       	std	Y+1, r24	; 0x01
	else return;
	
	SPI_SelectSlave(SPI_CAN);
     ae0:	83 e7       	ldi	r24, 0x73	; 115
     ae2:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>
	//printf("Rts: 0x%x\n", (INS_RTS | tx));
	SPI_MasterTransmit(INS_RTS | tx);
     ae6:	89 81       	ldd	r24, Y+1	; 0x01
     ae8:	80 68       	ori	r24, 0x80	; 128
     aea:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>

	SPI_NoSlave();
     aee:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
}
     af2:	0f 90       	pop	r0
     af4:	cf 91       	pop	r28
     af6:	df 91       	pop	r29
     af8:	08 95       	ret

00000afa <CAN_read_status>:

uint8_t CAN_read_status(void){
     afa:	df 93       	push	r29
     afc:	cf 93       	push	r28
     afe:	0f 92       	push	r0
     b00:	cd b7       	in	r28, 0x3d	; 61
     b02:	de b7       	in	r29, 0x3e	; 62
	char status;
	SPI_SelectSlave(SPI_CAN);
     b04:	83 e7       	ldi	r24, 0x73	; 115
     b06:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_READ_STATUS);
     b0a:	80 ea       	ldi	r24, 0xA0	; 160
     b0c:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	status = SPI_MasterReceive();
     b10:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_MasterReceive>
     b14:	89 83       	std	Y+1, r24	; 0x01

	SPI_NoSlave();
     b16:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
	
	return (uint8_t) status;
     b1a:	89 81       	ldd	r24, Y+1	; 0x01

}
     b1c:	0f 90       	pop	r0
     b1e:	cf 91       	pop	r28
     b20:	df 91       	pop	r29
     b22:	08 95       	ret

00000b24 <CAN_rx_status>:

uint8_t CAN_rx_status(void){
     b24:	df 93       	push	r29
     b26:	cf 93       	push	r28
     b28:	cd b7       	in	r28, 0x3d	; 61
     b2a:	de b7       	in	r29, 0x3e	; 62
return 0;
     b2c:	80 e0       	ldi	r24, 0x00	; 0

}
     b2e:	cf 91       	pop	r28
     b30:	df 91       	pop	r29
     b32:	08 95       	ret

00000b34 <CAN_bit_modify>:
void CAN_bit_modify(uint8_t address, uint8_t mask, uint8_t data){
     b34:	df 93       	push	r29
     b36:	cf 93       	push	r28
     b38:	00 d0       	rcall	.+0      	; 0xb3a <CAN_bit_modify+0x6>
     b3a:	0f 92       	push	r0
     b3c:	cd b7       	in	r28, 0x3d	; 61
     b3e:	de b7       	in	r29, 0x3e	; 62
     b40:	89 83       	std	Y+1, r24	; 0x01
     b42:	6a 83       	std	Y+2, r22	; 0x02
     b44:	4b 83       	std	Y+3, r20	; 0x03
	SPI_SelectSlave(SPI_CAN);
     b46:	83 e7       	ldi	r24, 0x73	; 115
     b48:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_SelectSlave>


	SPI_MasterTransmit((char)INS_BIT_MODIFY);	
     b4c:	85 e0       	ldi	r24, 0x05	; 5
     b4e:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     b52:	89 81       	ldd	r24, Y+1	; 0x01
     b54:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)mask);
     b58:	8a 81       	ldd	r24, Y+2	; 0x02
     b5a:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)data);
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	0e 94 41 01 	call	0x282	; 0x282 <SPI_MasterTransmit>

	SPI_NoSlave();
     b64:	0e 94 55 01 	call	0x2aa	; 0x2aa <SPI_NoSlave>
}
     b68:	0f 90       	pop	r0
     b6a:	0f 90       	pop	r0
     b6c:	0f 90       	pop	r0
     b6e:	cf 91       	pop	r28
     b70:	df 91       	pop	r29
     b72:	08 95       	ret

00000b74 <fdevopen>:
     b74:	0f 93       	push	r16
     b76:	1f 93       	push	r17
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	8c 01       	movw	r16, r24
     b7e:	eb 01       	movw	r28, r22
     b80:	00 97       	sbiw	r24, 0x00	; 0
     b82:	31 f4       	brne	.+12     	; 0xb90 <fdevopen+0x1c>
     b84:	61 15       	cp	r22, r1
     b86:	71 05       	cpc	r23, r1
     b88:	19 f4       	brne	.+6      	; 0xb90 <fdevopen+0x1c>
     b8a:	20 e0       	ldi	r18, 0x00	; 0
     b8c:	30 e0       	ldi	r19, 0x00	; 0
     b8e:	38 c0       	rjmp	.+112    	; 0xc00 <fdevopen+0x8c>
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	90 e0       	ldi	r25, 0x00	; 0
     b94:	6e e0       	ldi	r22, 0x0E	; 14
     b96:	70 e0       	ldi	r23, 0x00	; 0
     b98:	0e 94 34 08 	call	0x1068	; 0x1068 <calloc>
     b9c:	fc 01       	movw	r30, r24
     b9e:	9c 01       	movw	r18, r24
     ba0:	00 97       	sbiw	r24, 0x00	; 0
     ba2:	71 f1       	breq	.+92     	; 0xc00 <fdevopen+0x8c>
     ba4:	80 e8       	ldi	r24, 0x80	; 128
     ba6:	83 83       	std	Z+3, r24	; 0x03
     ba8:	20 97       	sbiw	r28, 0x00	; 0
     baa:	71 f0       	breq	.+28     	; 0xbc8 <fdevopen+0x54>
     bac:	d3 87       	std	Z+11, r29	; 0x0b
     bae:	c2 87       	std	Z+10, r28	; 0x0a
     bb0:	81 e8       	ldi	r24, 0x81	; 129
     bb2:	83 83       	std	Z+3, r24	; 0x03
     bb4:	80 91 8a 02 	lds	r24, 0x028A
     bb8:	90 91 8b 02 	lds	r25, 0x028B
     bbc:	89 2b       	or	r24, r25
     bbe:	21 f4       	brne	.+8      	; 0xbc8 <fdevopen+0x54>
     bc0:	f0 93 8b 02 	sts	0x028B, r31
     bc4:	e0 93 8a 02 	sts	0x028A, r30
     bc8:	01 15       	cp	r16, r1
     bca:	11 05       	cpc	r17, r1
     bcc:	c9 f0       	breq	.+50     	; 0xc00 <fdevopen+0x8c>
     bce:	11 87       	std	Z+9, r17	; 0x09
     bd0:	00 87       	std	Z+8, r16	; 0x08
     bd2:	83 81       	ldd	r24, Z+3	; 0x03
     bd4:	82 60       	ori	r24, 0x02	; 2
     bd6:	83 83       	std	Z+3, r24	; 0x03
     bd8:	80 91 8c 02 	lds	r24, 0x028C
     bdc:	90 91 8d 02 	lds	r25, 0x028D
     be0:	89 2b       	or	r24, r25
     be2:	71 f4       	brne	.+28     	; 0xc00 <fdevopen+0x8c>
     be4:	f0 93 8d 02 	sts	0x028D, r31
     be8:	e0 93 8c 02 	sts	0x028C, r30
     bec:	80 91 8e 02 	lds	r24, 0x028E
     bf0:	90 91 8f 02 	lds	r25, 0x028F
     bf4:	89 2b       	or	r24, r25
     bf6:	21 f4       	brne	.+8      	; 0xc00 <fdevopen+0x8c>
     bf8:	f0 93 8f 02 	sts	0x028F, r31
     bfc:	e0 93 8e 02 	sts	0x028E, r30
     c00:	c9 01       	movw	r24, r18
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	08 95       	ret

00000c0c <printf>:
     c0c:	a0 e0       	ldi	r26, 0x00	; 0
     c0e:	b0 e0       	ldi	r27, 0x00	; 0
     c10:	ec e0       	ldi	r30, 0x0C	; 12
     c12:	f6 e0       	ldi	r31, 0x06	; 6
     c14:	0c 94 2e 0a 	jmp	0x145c	; 0x145c <__prologue_saves__+0x20>
     c18:	fe 01       	movw	r30, r28
     c1a:	35 96       	adiw	r30, 0x05	; 5
     c1c:	61 91       	ld	r22, Z+
     c1e:	71 91       	ld	r23, Z+
     c20:	80 91 8c 02 	lds	r24, 0x028C
     c24:	90 91 8d 02 	lds	r25, 0x028D
     c28:	af 01       	movw	r20, r30
     c2a:	0e 94 57 06 	call	0xcae	; 0xcae <vfprintf>
     c2e:	20 96       	adiw	r28, 0x00	; 0
     c30:	e2 e0       	ldi	r30, 0x02	; 2
     c32:	0c 94 4a 0a 	jmp	0x1494	; 0x1494 <__epilogue_restores__+0x20>

00000c36 <putchar>:
     c36:	60 91 8c 02 	lds	r22, 0x028C
     c3a:	70 91 8d 02 	lds	r23, 0x028D
     c3e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     c42:	08 95       	ret

00000c44 <puts>:
     c44:	0f 93       	push	r16
     c46:	1f 93       	push	r17
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
     c4c:	8c 01       	movw	r16, r24
     c4e:	e0 91 8c 02 	lds	r30, 0x028C
     c52:	f0 91 8d 02 	lds	r31, 0x028D
     c56:	83 81       	ldd	r24, Z+3	; 0x03
     c58:	81 ff       	sbrs	r24, 1
     c5a:	21 c0       	rjmp	.+66     	; 0xc9e <puts+0x5a>
     c5c:	c0 e0       	ldi	r28, 0x00	; 0
     c5e:	d0 e0       	ldi	r29, 0x00	; 0
     c60:	0d c0       	rjmp	.+26     	; 0xc7c <puts+0x38>
     c62:	e0 91 8c 02 	lds	r30, 0x028C
     c66:	f0 91 8d 02 	lds	r31, 0x028D
     c6a:	20 85       	ldd	r18, Z+8	; 0x08
     c6c:	31 85       	ldd	r19, Z+9	; 0x09
     c6e:	bf 01       	movw	r22, r30
     c70:	f9 01       	movw	r30, r18
     c72:	09 95       	icall
     c74:	89 2b       	or	r24, r25
     c76:	11 f0       	breq	.+4      	; 0xc7c <puts+0x38>
     c78:	cf ef       	ldi	r28, 0xFF	; 255
     c7a:	df ef       	ldi	r29, 0xFF	; 255
     c7c:	f8 01       	movw	r30, r16
     c7e:	81 91       	ld	r24, Z+
     c80:	8f 01       	movw	r16, r30
     c82:	88 23       	and	r24, r24
     c84:	71 f7       	brne	.-36     	; 0xc62 <puts+0x1e>
     c86:	e0 91 8c 02 	lds	r30, 0x028C
     c8a:	f0 91 8d 02 	lds	r31, 0x028D
     c8e:	20 85       	ldd	r18, Z+8	; 0x08
     c90:	31 85       	ldd	r19, Z+9	; 0x09
     c92:	8a e0       	ldi	r24, 0x0A	; 10
     c94:	bf 01       	movw	r22, r30
     c96:	f9 01       	movw	r30, r18
     c98:	09 95       	icall
     c9a:	89 2b       	or	r24, r25
     c9c:	11 f0       	breq	.+4      	; 0xca2 <puts+0x5e>
     c9e:	cf ef       	ldi	r28, 0xFF	; 255
     ca0:	df ef       	ldi	r29, 0xFF	; 255
     ca2:	ce 01       	movw	r24, r28
     ca4:	df 91       	pop	r29
     ca6:	cf 91       	pop	r28
     ca8:	1f 91       	pop	r17
     caa:	0f 91       	pop	r16
     cac:	08 95       	ret

00000cae <vfprintf>:
     cae:	ab e0       	ldi	r26, 0x0B	; 11
     cb0:	b0 e0       	ldi	r27, 0x00	; 0
     cb2:	ed e5       	ldi	r30, 0x5D	; 93
     cb4:	f6 e0       	ldi	r31, 0x06	; 6
     cb6:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <__prologue_saves__>
     cba:	3c 01       	movw	r6, r24
     cbc:	2b 01       	movw	r4, r22
     cbe:	5a 01       	movw	r10, r20
     cc0:	fc 01       	movw	r30, r24
     cc2:	17 82       	std	Z+7, r1	; 0x07
     cc4:	16 82       	std	Z+6, r1	; 0x06
     cc6:	83 81       	ldd	r24, Z+3	; 0x03
     cc8:	81 fd       	sbrc	r24, 1
     cca:	03 c0       	rjmp	.+6      	; 0xcd2 <vfprintf+0x24>
     ccc:	6f ef       	ldi	r22, 0xFF	; 255
     cce:	7f ef       	ldi	r23, 0xFF	; 255
     cd0:	c6 c1       	rjmp	.+908    	; 0x105e <vfprintf+0x3b0>
     cd2:	9a e0       	ldi	r25, 0x0A	; 10
     cd4:	89 2e       	mov	r8, r25
     cd6:	1e 01       	movw	r2, r28
     cd8:	08 94       	sec
     cda:	21 1c       	adc	r2, r1
     cdc:	31 1c       	adc	r3, r1
     cde:	f3 01       	movw	r30, r6
     ce0:	23 81       	ldd	r18, Z+3	; 0x03
     ce2:	f2 01       	movw	r30, r4
     ce4:	23 fd       	sbrc	r18, 3
     ce6:	85 91       	lpm	r24, Z+
     ce8:	23 ff       	sbrs	r18, 3
     cea:	81 91       	ld	r24, Z+
     cec:	2f 01       	movw	r4, r30
     cee:	88 23       	and	r24, r24
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <vfprintf+0x46>
     cf2:	b2 c1       	rjmp	.+868    	; 0x1058 <vfprintf+0x3aa>
     cf4:	85 32       	cpi	r24, 0x25	; 37
     cf6:	39 f4       	brne	.+14     	; 0xd06 <vfprintf+0x58>
     cf8:	23 fd       	sbrc	r18, 3
     cfa:	85 91       	lpm	r24, Z+
     cfc:	23 ff       	sbrs	r18, 3
     cfe:	81 91       	ld	r24, Z+
     d00:	2f 01       	movw	r4, r30
     d02:	85 32       	cpi	r24, 0x25	; 37
     d04:	29 f4       	brne	.+10     	; 0xd10 <vfprintf+0x62>
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	b3 01       	movw	r22, r6
     d0a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     d0e:	e7 cf       	rjmp	.-50     	; 0xcde <vfprintf+0x30>
     d10:	98 2f       	mov	r25, r24
     d12:	ff 24       	eor	r15, r15
     d14:	ee 24       	eor	r14, r14
     d16:	99 24       	eor	r9, r9
     d18:	ff e1       	ldi	r31, 0x1F	; 31
     d1a:	ff 15       	cp	r31, r15
     d1c:	d0 f0       	brcs	.+52     	; 0xd52 <vfprintf+0xa4>
     d1e:	9b 32       	cpi	r25, 0x2B	; 43
     d20:	69 f0       	breq	.+26     	; 0xd3c <vfprintf+0x8e>
     d22:	9c 32       	cpi	r25, 0x2C	; 44
     d24:	28 f4       	brcc	.+10     	; 0xd30 <vfprintf+0x82>
     d26:	90 32       	cpi	r25, 0x20	; 32
     d28:	59 f0       	breq	.+22     	; 0xd40 <vfprintf+0x92>
     d2a:	93 32       	cpi	r25, 0x23	; 35
     d2c:	91 f4       	brne	.+36     	; 0xd52 <vfprintf+0xa4>
     d2e:	0e c0       	rjmp	.+28     	; 0xd4c <vfprintf+0x9e>
     d30:	9d 32       	cpi	r25, 0x2D	; 45
     d32:	49 f0       	breq	.+18     	; 0xd46 <vfprintf+0x98>
     d34:	90 33       	cpi	r25, 0x30	; 48
     d36:	69 f4       	brne	.+26     	; 0xd52 <vfprintf+0xa4>
     d38:	41 e0       	ldi	r20, 0x01	; 1
     d3a:	24 c0       	rjmp	.+72     	; 0xd84 <vfprintf+0xd6>
     d3c:	52 e0       	ldi	r21, 0x02	; 2
     d3e:	f5 2a       	or	r15, r21
     d40:	84 e0       	ldi	r24, 0x04	; 4
     d42:	f8 2a       	or	r15, r24
     d44:	28 c0       	rjmp	.+80     	; 0xd96 <vfprintf+0xe8>
     d46:	98 e0       	ldi	r25, 0x08	; 8
     d48:	f9 2a       	or	r15, r25
     d4a:	25 c0       	rjmp	.+74     	; 0xd96 <vfprintf+0xe8>
     d4c:	e0 e1       	ldi	r30, 0x10	; 16
     d4e:	fe 2a       	or	r15, r30
     d50:	22 c0       	rjmp	.+68     	; 0xd96 <vfprintf+0xe8>
     d52:	f7 fc       	sbrc	r15, 7
     d54:	29 c0       	rjmp	.+82     	; 0xda8 <vfprintf+0xfa>
     d56:	89 2f       	mov	r24, r25
     d58:	80 53       	subi	r24, 0x30	; 48
     d5a:	8a 30       	cpi	r24, 0x0A	; 10
     d5c:	70 f4       	brcc	.+28     	; 0xd7a <vfprintf+0xcc>
     d5e:	f6 fe       	sbrs	r15, 6
     d60:	05 c0       	rjmp	.+10     	; 0xd6c <vfprintf+0xbe>
     d62:	98 9c       	mul	r9, r8
     d64:	90 2c       	mov	r9, r0
     d66:	11 24       	eor	r1, r1
     d68:	98 0e       	add	r9, r24
     d6a:	15 c0       	rjmp	.+42     	; 0xd96 <vfprintf+0xe8>
     d6c:	e8 9c       	mul	r14, r8
     d6e:	e0 2c       	mov	r14, r0
     d70:	11 24       	eor	r1, r1
     d72:	e8 0e       	add	r14, r24
     d74:	f0 e2       	ldi	r31, 0x20	; 32
     d76:	ff 2a       	or	r15, r31
     d78:	0e c0       	rjmp	.+28     	; 0xd96 <vfprintf+0xe8>
     d7a:	9e 32       	cpi	r25, 0x2E	; 46
     d7c:	29 f4       	brne	.+10     	; 0xd88 <vfprintf+0xda>
     d7e:	f6 fc       	sbrc	r15, 6
     d80:	6b c1       	rjmp	.+726    	; 0x1058 <vfprintf+0x3aa>
     d82:	40 e4       	ldi	r20, 0x40	; 64
     d84:	f4 2a       	or	r15, r20
     d86:	07 c0       	rjmp	.+14     	; 0xd96 <vfprintf+0xe8>
     d88:	9c 36       	cpi	r25, 0x6C	; 108
     d8a:	19 f4       	brne	.+6      	; 0xd92 <vfprintf+0xe4>
     d8c:	50 e8       	ldi	r21, 0x80	; 128
     d8e:	f5 2a       	or	r15, r21
     d90:	02 c0       	rjmp	.+4      	; 0xd96 <vfprintf+0xe8>
     d92:	98 36       	cpi	r25, 0x68	; 104
     d94:	49 f4       	brne	.+18     	; 0xda8 <vfprintf+0xfa>
     d96:	f2 01       	movw	r30, r4
     d98:	23 fd       	sbrc	r18, 3
     d9a:	95 91       	lpm	r25, Z+
     d9c:	23 ff       	sbrs	r18, 3
     d9e:	91 91       	ld	r25, Z+
     da0:	2f 01       	movw	r4, r30
     da2:	99 23       	and	r25, r25
     da4:	09 f0       	breq	.+2      	; 0xda8 <vfprintf+0xfa>
     da6:	b8 cf       	rjmp	.-144    	; 0xd18 <vfprintf+0x6a>
     da8:	89 2f       	mov	r24, r25
     daa:	85 54       	subi	r24, 0x45	; 69
     dac:	83 30       	cpi	r24, 0x03	; 3
     dae:	18 f0       	brcs	.+6      	; 0xdb6 <vfprintf+0x108>
     db0:	80 52       	subi	r24, 0x20	; 32
     db2:	83 30       	cpi	r24, 0x03	; 3
     db4:	38 f4       	brcc	.+14     	; 0xdc4 <vfprintf+0x116>
     db6:	44 e0       	ldi	r20, 0x04	; 4
     db8:	50 e0       	ldi	r21, 0x00	; 0
     dba:	a4 0e       	add	r10, r20
     dbc:	b5 1e       	adc	r11, r21
     dbe:	5f e3       	ldi	r21, 0x3F	; 63
     dc0:	59 83       	std	Y+1, r21	; 0x01
     dc2:	0f c0       	rjmp	.+30     	; 0xde2 <vfprintf+0x134>
     dc4:	93 36       	cpi	r25, 0x63	; 99
     dc6:	31 f0       	breq	.+12     	; 0xdd4 <vfprintf+0x126>
     dc8:	93 37       	cpi	r25, 0x73	; 115
     dca:	79 f0       	breq	.+30     	; 0xdea <vfprintf+0x13c>
     dcc:	93 35       	cpi	r25, 0x53	; 83
     dce:	09 f0       	breq	.+2      	; 0xdd2 <vfprintf+0x124>
     dd0:	56 c0       	rjmp	.+172    	; 0xe7e <vfprintf+0x1d0>
     dd2:	20 c0       	rjmp	.+64     	; 0xe14 <vfprintf+0x166>
     dd4:	f5 01       	movw	r30, r10
     dd6:	80 81       	ld	r24, Z
     dd8:	89 83       	std	Y+1, r24	; 0x01
     dda:	42 e0       	ldi	r20, 0x02	; 2
     ddc:	50 e0       	ldi	r21, 0x00	; 0
     dde:	a4 0e       	add	r10, r20
     de0:	b5 1e       	adc	r11, r21
     de2:	61 01       	movw	r12, r2
     de4:	01 e0       	ldi	r16, 0x01	; 1
     de6:	10 e0       	ldi	r17, 0x00	; 0
     de8:	12 c0       	rjmp	.+36     	; 0xe0e <vfprintf+0x160>
     dea:	f5 01       	movw	r30, r10
     dec:	c0 80       	ld	r12, Z
     dee:	d1 80       	ldd	r13, Z+1	; 0x01
     df0:	f6 fc       	sbrc	r15, 6
     df2:	03 c0       	rjmp	.+6      	; 0xdfa <vfprintf+0x14c>
     df4:	6f ef       	ldi	r22, 0xFF	; 255
     df6:	7f ef       	ldi	r23, 0xFF	; 255
     df8:	02 c0       	rjmp	.+4      	; 0xdfe <vfprintf+0x150>
     dfa:	69 2d       	mov	r22, r9
     dfc:	70 e0       	ldi	r23, 0x00	; 0
     dfe:	42 e0       	ldi	r20, 0x02	; 2
     e00:	50 e0       	ldi	r21, 0x00	; 0
     e02:	a4 0e       	add	r10, r20
     e04:	b5 1e       	adc	r11, r21
     e06:	c6 01       	movw	r24, r12
     e08:	0e 94 67 09 	call	0x12ce	; 0x12ce <strnlen>
     e0c:	8c 01       	movw	r16, r24
     e0e:	5f e7       	ldi	r21, 0x7F	; 127
     e10:	f5 22       	and	r15, r21
     e12:	14 c0       	rjmp	.+40     	; 0xe3c <vfprintf+0x18e>
     e14:	f5 01       	movw	r30, r10
     e16:	c0 80       	ld	r12, Z
     e18:	d1 80       	ldd	r13, Z+1	; 0x01
     e1a:	f6 fc       	sbrc	r15, 6
     e1c:	03 c0       	rjmp	.+6      	; 0xe24 <vfprintf+0x176>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <vfprintf+0x17a>
     e24:	69 2d       	mov	r22, r9
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	42 e0       	ldi	r20, 0x02	; 2
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	a4 0e       	add	r10, r20
     e2e:	b5 1e       	adc	r11, r21
     e30:	c6 01       	movw	r24, r12
     e32:	0e 94 55 09 	call	0x12aa	; 0x12aa <strnlen_P>
     e36:	8c 01       	movw	r16, r24
     e38:	50 e8       	ldi	r21, 0x80	; 128
     e3a:	f5 2a       	or	r15, r21
     e3c:	f3 fe       	sbrs	r15, 3
     e3e:	07 c0       	rjmp	.+14     	; 0xe4e <vfprintf+0x1a0>
     e40:	1a c0       	rjmp	.+52     	; 0xe76 <vfprintf+0x1c8>
     e42:	80 e2       	ldi	r24, 0x20	; 32
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	b3 01       	movw	r22, r6
     e48:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     e4c:	ea 94       	dec	r14
     e4e:	8e 2d       	mov	r24, r14
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	08 17       	cp	r16, r24
     e54:	19 07       	cpc	r17, r25
     e56:	a8 f3       	brcs	.-22     	; 0xe42 <vfprintf+0x194>
     e58:	0e c0       	rjmp	.+28     	; 0xe76 <vfprintf+0x1c8>
     e5a:	f6 01       	movw	r30, r12
     e5c:	f7 fc       	sbrc	r15, 7
     e5e:	85 91       	lpm	r24, Z+
     e60:	f7 fe       	sbrs	r15, 7
     e62:	81 91       	ld	r24, Z+
     e64:	6f 01       	movw	r12, r30
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	b3 01       	movw	r22, r6
     e6a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     e6e:	e1 10       	cpse	r14, r1
     e70:	ea 94       	dec	r14
     e72:	01 50       	subi	r16, 0x01	; 1
     e74:	10 40       	sbci	r17, 0x00	; 0
     e76:	01 15       	cp	r16, r1
     e78:	11 05       	cpc	r17, r1
     e7a:	79 f7       	brne	.-34     	; 0xe5a <vfprintf+0x1ac>
     e7c:	ea c0       	rjmp	.+468    	; 0x1052 <vfprintf+0x3a4>
     e7e:	94 36       	cpi	r25, 0x64	; 100
     e80:	11 f0       	breq	.+4      	; 0xe86 <vfprintf+0x1d8>
     e82:	99 36       	cpi	r25, 0x69	; 105
     e84:	69 f5       	brne	.+90     	; 0xee0 <vfprintf+0x232>
     e86:	f7 fe       	sbrs	r15, 7
     e88:	08 c0       	rjmp	.+16     	; 0xe9a <vfprintf+0x1ec>
     e8a:	f5 01       	movw	r30, r10
     e8c:	20 81       	ld	r18, Z
     e8e:	31 81       	ldd	r19, Z+1	; 0x01
     e90:	42 81       	ldd	r20, Z+2	; 0x02
     e92:	53 81       	ldd	r21, Z+3	; 0x03
     e94:	84 e0       	ldi	r24, 0x04	; 4
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	0a c0       	rjmp	.+20     	; 0xeae <vfprintf+0x200>
     e9a:	f5 01       	movw	r30, r10
     e9c:	80 81       	ld	r24, Z
     e9e:	91 81       	ldd	r25, Z+1	; 0x01
     ea0:	9c 01       	movw	r18, r24
     ea2:	44 27       	eor	r20, r20
     ea4:	37 fd       	sbrc	r19, 7
     ea6:	40 95       	com	r20
     ea8:	54 2f       	mov	r21, r20
     eaa:	82 e0       	ldi	r24, 0x02	; 2
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	a8 0e       	add	r10, r24
     eb0:	b9 1e       	adc	r11, r25
     eb2:	9f e6       	ldi	r25, 0x6F	; 111
     eb4:	f9 22       	and	r15, r25
     eb6:	57 ff       	sbrs	r21, 7
     eb8:	09 c0       	rjmp	.+18     	; 0xecc <vfprintf+0x21e>
     eba:	50 95       	com	r21
     ebc:	40 95       	com	r20
     ebe:	30 95       	com	r19
     ec0:	21 95       	neg	r18
     ec2:	3f 4f       	sbci	r19, 0xFF	; 255
     ec4:	4f 4f       	sbci	r20, 0xFF	; 255
     ec6:	5f 4f       	sbci	r21, 0xFF	; 255
     ec8:	e0 e8       	ldi	r30, 0x80	; 128
     eca:	fe 2a       	or	r15, r30
     ecc:	ca 01       	movw	r24, r20
     ece:	b9 01       	movw	r22, r18
     ed0:	a1 01       	movw	r20, r2
     ed2:	2a e0       	ldi	r18, 0x0A	; 10
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	0e 94 9e 09 	call	0x133c	; 0x133c <__ultoa_invert>
     eda:	d8 2e       	mov	r13, r24
     edc:	d2 18       	sub	r13, r2
     ede:	40 c0       	rjmp	.+128    	; 0xf60 <vfprintf+0x2b2>
     ee0:	95 37       	cpi	r25, 0x75	; 117
     ee2:	29 f4       	brne	.+10     	; 0xeee <vfprintf+0x240>
     ee4:	1f 2d       	mov	r17, r15
     ee6:	1f 7e       	andi	r17, 0xEF	; 239
     ee8:	2a e0       	ldi	r18, 0x0A	; 10
     eea:	30 e0       	ldi	r19, 0x00	; 0
     eec:	1d c0       	rjmp	.+58     	; 0xf28 <vfprintf+0x27a>
     eee:	1f 2d       	mov	r17, r15
     ef0:	19 7f       	andi	r17, 0xF9	; 249
     ef2:	9f 36       	cpi	r25, 0x6F	; 111
     ef4:	61 f0       	breq	.+24     	; 0xf0e <vfprintf+0x260>
     ef6:	90 37       	cpi	r25, 0x70	; 112
     ef8:	20 f4       	brcc	.+8      	; 0xf02 <vfprintf+0x254>
     efa:	98 35       	cpi	r25, 0x58	; 88
     efc:	09 f0       	breq	.+2      	; 0xf00 <vfprintf+0x252>
     efe:	ac c0       	rjmp	.+344    	; 0x1058 <vfprintf+0x3aa>
     f00:	0f c0       	rjmp	.+30     	; 0xf20 <vfprintf+0x272>
     f02:	90 37       	cpi	r25, 0x70	; 112
     f04:	39 f0       	breq	.+14     	; 0xf14 <vfprintf+0x266>
     f06:	98 37       	cpi	r25, 0x78	; 120
     f08:	09 f0       	breq	.+2      	; 0xf0c <vfprintf+0x25e>
     f0a:	a6 c0       	rjmp	.+332    	; 0x1058 <vfprintf+0x3aa>
     f0c:	04 c0       	rjmp	.+8      	; 0xf16 <vfprintf+0x268>
     f0e:	28 e0       	ldi	r18, 0x08	; 8
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	0a c0       	rjmp	.+20     	; 0xf28 <vfprintf+0x27a>
     f14:	10 61       	ori	r17, 0x10	; 16
     f16:	14 fd       	sbrc	r17, 4
     f18:	14 60       	ori	r17, 0x04	; 4
     f1a:	20 e1       	ldi	r18, 0x10	; 16
     f1c:	30 e0       	ldi	r19, 0x00	; 0
     f1e:	04 c0       	rjmp	.+8      	; 0xf28 <vfprintf+0x27a>
     f20:	14 fd       	sbrc	r17, 4
     f22:	16 60       	ori	r17, 0x06	; 6
     f24:	20 e1       	ldi	r18, 0x10	; 16
     f26:	32 e0       	ldi	r19, 0x02	; 2
     f28:	17 ff       	sbrs	r17, 7
     f2a:	08 c0       	rjmp	.+16     	; 0xf3c <vfprintf+0x28e>
     f2c:	f5 01       	movw	r30, r10
     f2e:	60 81       	ld	r22, Z
     f30:	71 81       	ldd	r23, Z+1	; 0x01
     f32:	82 81       	ldd	r24, Z+2	; 0x02
     f34:	93 81       	ldd	r25, Z+3	; 0x03
     f36:	44 e0       	ldi	r20, 0x04	; 4
     f38:	50 e0       	ldi	r21, 0x00	; 0
     f3a:	08 c0       	rjmp	.+16     	; 0xf4c <vfprintf+0x29e>
     f3c:	f5 01       	movw	r30, r10
     f3e:	80 81       	ld	r24, Z
     f40:	91 81       	ldd	r25, Z+1	; 0x01
     f42:	bc 01       	movw	r22, r24
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	90 e0       	ldi	r25, 0x00	; 0
     f48:	42 e0       	ldi	r20, 0x02	; 2
     f4a:	50 e0       	ldi	r21, 0x00	; 0
     f4c:	a4 0e       	add	r10, r20
     f4e:	b5 1e       	adc	r11, r21
     f50:	a1 01       	movw	r20, r2
     f52:	0e 94 9e 09 	call	0x133c	; 0x133c <__ultoa_invert>
     f56:	d8 2e       	mov	r13, r24
     f58:	d2 18       	sub	r13, r2
     f5a:	8f e7       	ldi	r24, 0x7F	; 127
     f5c:	f8 2e       	mov	r15, r24
     f5e:	f1 22       	and	r15, r17
     f60:	f6 fe       	sbrs	r15, 6
     f62:	0b c0       	rjmp	.+22     	; 0xf7a <vfprintf+0x2cc>
     f64:	5e ef       	ldi	r21, 0xFE	; 254
     f66:	f5 22       	and	r15, r21
     f68:	d9 14       	cp	r13, r9
     f6a:	38 f4       	brcc	.+14     	; 0xf7a <vfprintf+0x2cc>
     f6c:	f4 fe       	sbrs	r15, 4
     f6e:	07 c0       	rjmp	.+14     	; 0xf7e <vfprintf+0x2d0>
     f70:	f2 fc       	sbrc	r15, 2
     f72:	05 c0       	rjmp	.+10     	; 0xf7e <vfprintf+0x2d0>
     f74:	8f ee       	ldi	r24, 0xEF	; 239
     f76:	f8 22       	and	r15, r24
     f78:	02 c0       	rjmp	.+4      	; 0xf7e <vfprintf+0x2d0>
     f7a:	1d 2d       	mov	r17, r13
     f7c:	01 c0       	rjmp	.+2      	; 0xf80 <vfprintf+0x2d2>
     f7e:	19 2d       	mov	r17, r9
     f80:	f4 fe       	sbrs	r15, 4
     f82:	0d c0       	rjmp	.+26     	; 0xf9e <vfprintf+0x2f0>
     f84:	fe 01       	movw	r30, r28
     f86:	ed 0d       	add	r30, r13
     f88:	f1 1d       	adc	r31, r1
     f8a:	80 81       	ld	r24, Z
     f8c:	80 33       	cpi	r24, 0x30	; 48
     f8e:	19 f4       	brne	.+6      	; 0xf96 <vfprintf+0x2e8>
     f90:	99 ee       	ldi	r25, 0xE9	; 233
     f92:	f9 22       	and	r15, r25
     f94:	08 c0       	rjmp	.+16     	; 0xfa6 <vfprintf+0x2f8>
     f96:	1f 5f       	subi	r17, 0xFF	; 255
     f98:	f2 fe       	sbrs	r15, 2
     f9a:	05 c0       	rjmp	.+10     	; 0xfa6 <vfprintf+0x2f8>
     f9c:	03 c0       	rjmp	.+6      	; 0xfa4 <vfprintf+0x2f6>
     f9e:	8f 2d       	mov	r24, r15
     fa0:	86 78       	andi	r24, 0x86	; 134
     fa2:	09 f0       	breq	.+2      	; 0xfa6 <vfprintf+0x2f8>
     fa4:	1f 5f       	subi	r17, 0xFF	; 255
     fa6:	0f 2d       	mov	r16, r15
     fa8:	f3 fc       	sbrc	r15, 3
     faa:	14 c0       	rjmp	.+40     	; 0xfd4 <vfprintf+0x326>
     fac:	f0 fe       	sbrs	r15, 0
     fae:	0f c0       	rjmp	.+30     	; 0xfce <vfprintf+0x320>
     fb0:	1e 15       	cp	r17, r14
     fb2:	10 f0       	brcs	.+4      	; 0xfb8 <vfprintf+0x30a>
     fb4:	9d 2c       	mov	r9, r13
     fb6:	0b c0       	rjmp	.+22     	; 0xfce <vfprintf+0x320>
     fb8:	9d 2c       	mov	r9, r13
     fba:	9e 0c       	add	r9, r14
     fbc:	91 1a       	sub	r9, r17
     fbe:	1e 2d       	mov	r17, r14
     fc0:	06 c0       	rjmp	.+12     	; 0xfce <vfprintf+0x320>
     fc2:	80 e2       	ldi	r24, 0x20	; 32
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	b3 01       	movw	r22, r6
     fc8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     fcc:	1f 5f       	subi	r17, 0xFF	; 255
     fce:	1e 15       	cp	r17, r14
     fd0:	c0 f3       	brcs	.-16     	; 0xfc2 <vfprintf+0x314>
     fd2:	04 c0       	rjmp	.+8      	; 0xfdc <vfprintf+0x32e>
     fd4:	1e 15       	cp	r17, r14
     fd6:	10 f4       	brcc	.+4      	; 0xfdc <vfprintf+0x32e>
     fd8:	e1 1a       	sub	r14, r17
     fda:	01 c0       	rjmp	.+2      	; 0xfde <vfprintf+0x330>
     fdc:	ee 24       	eor	r14, r14
     fde:	04 ff       	sbrs	r16, 4
     fe0:	0f c0       	rjmp	.+30     	; 0x1000 <vfprintf+0x352>
     fe2:	80 e3       	ldi	r24, 0x30	; 48
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	b3 01       	movw	r22, r6
     fe8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
     fec:	02 ff       	sbrs	r16, 2
     fee:	1d c0       	rjmp	.+58     	; 0x102a <vfprintf+0x37c>
     ff0:	01 fd       	sbrc	r16, 1
     ff2:	03 c0       	rjmp	.+6      	; 0xffa <vfprintf+0x34c>
     ff4:	88 e7       	ldi	r24, 0x78	; 120
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	0e c0       	rjmp	.+28     	; 0x1016 <vfprintf+0x368>
     ffa:	88 e5       	ldi	r24, 0x58	; 88
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0b c0       	rjmp	.+22     	; 0x1016 <vfprintf+0x368>
    1000:	80 2f       	mov	r24, r16
    1002:	86 78       	andi	r24, 0x86	; 134
    1004:	91 f0       	breq	.+36     	; 0x102a <vfprintf+0x37c>
    1006:	01 ff       	sbrs	r16, 1
    1008:	02 c0       	rjmp	.+4      	; 0x100e <vfprintf+0x360>
    100a:	8b e2       	ldi	r24, 0x2B	; 43
    100c:	01 c0       	rjmp	.+2      	; 0x1010 <vfprintf+0x362>
    100e:	80 e2       	ldi	r24, 0x20	; 32
    1010:	f7 fc       	sbrc	r15, 7
    1012:	8d e2       	ldi	r24, 0x2D	; 45
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	b3 01       	movw	r22, r6
    1018:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
    101c:	06 c0       	rjmp	.+12     	; 0x102a <vfprintf+0x37c>
    101e:	80 e3       	ldi	r24, 0x30	; 48
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	b3 01       	movw	r22, r6
    1024:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
    1028:	9a 94       	dec	r9
    102a:	d9 14       	cp	r13, r9
    102c:	c0 f3       	brcs	.-16     	; 0x101e <vfprintf+0x370>
    102e:	da 94       	dec	r13
    1030:	f1 01       	movw	r30, r2
    1032:	ed 0d       	add	r30, r13
    1034:	f1 1d       	adc	r31, r1
    1036:	80 81       	ld	r24, Z
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	b3 01       	movw	r22, r6
    103c:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
    1040:	dd 20       	and	r13, r13
    1042:	a9 f7       	brne	.-22     	; 0x102e <vfprintf+0x380>
    1044:	06 c0       	rjmp	.+12     	; 0x1052 <vfprintf+0x3a4>
    1046:	80 e2       	ldi	r24, 0x20	; 32
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	b3 01       	movw	r22, r6
    104c:	0e 94 72 09 	call	0x12e4	; 0x12e4 <fputc>
    1050:	ea 94       	dec	r14
    1052:	ee 20       	and	r14, r14
    1054:	c1 f7       	brne	.-16     	; 0x1046 <vfprintf+0x398>
    1056:	43 ce       	rjmp	.-890    	; 0xcde <vfprintf+0x30>
    1058:	f3 01       	movw	r30, r6
    105a:	66 81       	ldd	r22, Z+6	; 0x06
    105c:	77 81       	ldd	r23, Z+7	; 0x07
    105e:	cb 01       	movw	r24, r22
    1060:	2b 96       	adiw	r28, 0x0b	; 11
    1062:	e2 e1       	ldi	r30, 0x12	; 18
    1064:	0c 94 3a 0a 	jmp	0x1474	; 0x1474 <__epilogue_restores__>

00001068 <calloc>:
    1068:	0f 93       	push	r16
    106a:	1f 93       	push	r17
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	68 9f       	mul	r22, r24
    1072:	80 01       	movw	r16, r0
    1074:	69 9f       	mul	r22, r25
    1076:	10 0d       	add	r17, r0
    1078:	78 9f       	mul	r23, r24
    107a:	10 0d       	add	r17, r0
    107c:	11 24       	eor	r1, r1
    107e:	c8 01       	movw	r24, r16
    1080:	0e 94 50 08 	call	0x10a0	; 0x10a0 <malloc>
    1084:	ec 01       	movw	r28, r24
    1086:	00 97       	sbiw	r24, 0x00	; 0
    1088:	29 f0       	breq	.+10     	; 0x1094 <calloc+0x2c>
    108a:	60 e0       	ldi	r22, 0x00	; 0
    108c:	70 e0       	ldi	r23, 0x00	; 0
    108e:	a8 01       	movw	r20, r16
    1090:	0e 94 60 09 	call	0x12c0	; 0x12c0 <memset>
    1094:	ce 01       	movw	r24, r28
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	1f 91       	pop	r17
    109c:	0f 91       	pop	r16
    109e:	08 95       	ret

000010a0 <malloc>:
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	bc 01       	movw	r22, r24
    10a6:	82 30       	cpi	r24, 0x02	; 2
    10a8:	91 05       	cpc	r25, r1
    10aa:	10 f4       	brcc	.+4      	; 0x10b0 <malloc+0x10>
    10ac:	62 e0       	ldi	r22, 0x02	; 2
    10ae:	70 e0       	ldi	r23, 0x00	; 0
    10b0:	a0 91 92 02 	lds	r26, 0x0292
    10b4:	b0 91 93 02 	lds	r27, 0x0293
    10b8:	ed 01       	movw	r28, r26
    10ba:	e0 e0       	ldi	r30, 0x00	; 0
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	40 e0       	ldi	r20, 0x00	; 0
    10c0:	50 e0       	ldi	r21, 0x00	; 0
    10c2:	21 c0       	rjmp	.+66     	; 0x1106 <malloc+0x66>
    10c4:	88 81       	ld	r24, Y
    10c6:	99 81       	ldd	r25, Y+1	; 0x01
    10c8:	86 17       	cp	r24, r22
    10ca:	97 07       	cpc	r25, r23
    10cc:	69 f4       	brne	.+26     	; 0x10e8 <malloc+0x48>
    10ce:	8a 81       	ldd	r24, Y+2	; 0x02
    10d0:	9b 81       	ldd	r25, Y+3	; 0x03
    10d2:	30 97       	sbiw	r30, 0x00	; 0
    10d4:	19 f0       	breq	.+6      	; 0x10dc <malloc+0x3c>
    10d6:	93 83       	std	Z+3, r25	; 0x03
    10d8:	82 83       	std	Z+2, r24	; 0x02
    10da:	04 c0       	rjmp	.+8      	; 0x10e4 <malloc+0x44>
    10dc:	90 93 93 02 	sts	0x0293, r25
    10e0:	80 93 92 02 	sts	0x0292, r24
    10e4:	fe 01       	movw	r30, r28
    10e6:	34 c0       	rjmp	.+104    	; 0x1150 <malloc+0xb0>
    10e8:	68 17       	cp	r22, r24
    10ea:	79 07       	cpc	r23, r25
    10ec:	38 f4       	brcc	.+14     	; 0x10fc <malloc+0x5c>
    10ee:	41 15       	cp	r20, r1
    10f0:	51 05       	cpc	r21, r1
    10f2:	19 f0       	breq	.+6      	; 0x10fa <malloc+0x5a>
    10f4:	84 17       	cp	r24, r20
    10f6:	95 07       	cpc	r25, r21
    10f8:	08 f4       	brcc	.+2      	; 0x10fc <malloc+0x5c>
    10fa:	ac 01       	movw	r20, r24
    10fc:	fe 01       	movw	r30, r28
    10fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1100:	9b 81       	ldd	r25, Y+3	; 0x03
    1102:	9c 01       	movw	r18, r24
    1104:	e9 01       	movw	r28, r18
    1106:	20 97       	sbiw	r28, 0x00	; 0
    1108:	e9 f6       	brne	.-70     	; 0x10c4 <malloc+0x24>
    110a:	41 15       	cp	r20, r1
    110c:	51 05       	cpc	r21, r1
    110e:	a9 f1       	breq	.+106    	; 0x117a <malloc+0xda>
    1110:	ca 01       	movw	r24, r20
    1112:	86 1b       	sub	r24, r22
    1114:	97 0b       	sbc	r25, r23
    1116:	04 97       	sbiw	r24, 0x04	; 4
    1118:	08 f4       	brcc	.+2      	; 0x111c <malloc+0x7c>
    111a:	ba 01       	movw	r22, r20
    111c:	e0 e0       	ldi	r30, 0x00	; 0
    111e:	f0 e0       	ldi	r31, 0x00	; 0
    1120:	2a c0       	rjmp	.+84     	; 0x1176 <malloc+0xd6>
    1122:	8d 91       	ld	r24, X+
    1124:	9c 91       	ld	r25, X
    1126:	11 97       	sbiw	r26, 0x01	; 1
    1128:	84 17       	cp	r24, r20
    112a:	95 07       	cpc	r25, r21
    112c:	f9 f4       	brne	.+62     	; 0x116c <malloc+0xcc>
    112e:	64 17       	cp	r22, r20
    1130:	75 07       	cpc	r23, r21
    1132:	81 f4       	brne	.+32     	; 0x1154 <malloc+0xb4>
    1134:	12 96       	adiw	r26, 0x02	; 2
    1136:	8d 91       	ld	r24, X+
    1138:	9c 91       	ld	r25, X
    113a:	13 97       	sbiw	r26, 0x03	; 3
    113c:	30 97       	sbiw	r30, 0x00	; 0
    113e:	19 f0       	breq	.+6      	; 0x1146 <malloc+0xa6>
    1140:	93 83       	std	Z+3, r25	; 0x03
    1142:	82 83       	std	Z+2, r24	; 0x02
    1144:	04 c0       	rjmp	.+8      	; 0x114e <malloc+0xae>
    1146:	90 93 93 02 	sts	0x0293, r25
    114a:	80 93 92 02 	sts	0x0292, r24
    114e:	fd 01       	movw	r30, r26
    1150:	32 96       	adiw	r30, 0x02	; 2
    1152:	4f c0       	rjmp	.+158    	; 0x11f2 <malloc+0x152>
    1154:	ca 01       	movw	r24, r20
    1156:	86 1b       	sub	r24, r22
    1158:	97 0b       	sbc	r25, r23
    115a:	fd 01       	movw	r30, r26
    115c:	e8 0f       	add	r30, r24
    115e:	f9 1f       	adc	r31, r25
    1160:	61 93       	st	Z+, r22
    1162:	71 93       	st	Z+, r23
    1164:	02 97       	sbiw	r24, 0x02	; 2
    1166:	8d 93       	st	X+, r24
    1168:	9c 93       	st	X, r25
    116a:	43 c0       	rjmp	.+134    	; 0x11f2 <malloc+0x152>
    116c:	fd 01       	movw	r30, r26
    116e:	82 81       	ldd	r24, Z+2	; 0x02
    1170:	93 81       	ldd	r25, Z+3	; 0x03
    1172:	9c 01       	movw	r18, r24
    1174:	d9 01       	movw	r26, r18
    1176:	10 97       	sbiw	r26, 0x00	; 0
    1178:	a1 f6       	brne	.-88     	; 0x1122 <malloc+0x82>
    117a:	80 91 90 02 	lds	r24, 0x0290
    117e:	90 91 91 02 	lds	r25, 0x0291
    1182:	89 2b       	or	r24, r25
    1184:	41 f4       	brne	.+16     	; 0x1196 <malloc+0xf6>
    1186:	80 91 86 02 	lds	r24, 0x0286
    118a:	90 91 87 02 	lds	r25, 0x0287
    118e:	90 93 91 02 	sts	0x0291, r25
    1192:	80 93 90 02 	sts	0x0290, r24
    1196:	40 91 88 02 	lds	r20, 0x0288
    119a:	50 91 89 02 	lds	r21, 0x0289
    119e:	41 15       	cp	r20, r1
    11a0:	51 05       	cpc	r21, r1
    11a2:	41 f4       	brne	.+16     	; 0x11b4 <malloc+0x114>
    11a4:	4d b7       	in	r20, 0x3d	; 61
    11a6:	5e b7       	in	r21, 0x3e	; 62
    11a8:	80 91 84 02 	lds	r24, 0x0284
    11ac:	90 91 85 02 	lds	r25, 0x0285
    11b0:	48 1b       	sub	r20, r24
    11b2:	59 0b       	sbc	r21, r25
    11b4:	20 91 90 02 	lds	r18, 0x0290
    11b8:	30 91 91 02 	lds	r19, 0x0291
    11bc:	24 17       	cp	r18, r20
    11be:	35 07       	cpc	r19, r21
    11c0:	b0 f4       	brcc	.+44     	; 0x11ee <malloc+0x14e>
    11c2:	ca 01       	movw	r24, r20
    11c4:	82 1b       	sub	r24, r18
    11c6:	93 0b       	sbc	r25, r19
    11c8:	86 17       	cp	r24, r22
    11ca:	97 07       	cpc	r25, r23
    11cc:	80 f0       	brcs	.+32     	; 0x11ee <malloc+0x14e>
    11ce:	ab 01       	movw	r20, r22
    11d0:	4e 5f       	subi	r20, 0xFE	; 254
    11d2:	5f 4f       	sbci	r21, 0xFF	; 255
    11d4:	84 17       	cp	r24, r20
    11d6:	95 07       	cpc	r25, r21
    11d8:	50 f0       	brcs	.+20     	; 0x11ee <malloc+0x14e>
    11da:	42 0f       	add	r20, r18
    11dc:	53 1f       	adc	r21, r19
    11de:	50 93 91 02 	sts	0x0291, r21
    11e2:	40 93 90 02 	sts	0x0290, r20
    11e6:	f9 01       	movw	r30, r18
    11e8:	61 93       	st	Z+, r22
    11ea:	71 93       	st	Z+, r23
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <malloc+0x152>
    11ee:	e0 e0       	ldi	r30, 0x00	; 0
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	cf 01       	movw	r24, r30
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	08 95       	ret

000011fa <free>:
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	00 97       	sbiw	r24, 0x00	; 0
    1200:	09 f4       	brne	.+2      	; 0x1204 <free+0xa>
    1202:	50 c0       	rjmp	.+160    	; 0x12a4 <free+0xaa>
    1204:	ec 01       	movw	r28, r24
    1206:	22 97       	sbiw	r28, 0x02	; 2
    1208:	1b 82       	std	Y+3, r1	; 0x03
    120a:	1a 82       	std	Y+2, r1	; 0x02
    120c:	a0 91 92 02 	lds	r26, 0x0292
    1210:	b0 91 93 02 	lds	r27, 0x0293
    1214:	10 97       	sbiw	r26, 0x00	; 0
    1216:	09 f1       	breq	.+66     	; 0x125a <free+0x60>
    1218:	40 e0       	ldi	r20, 0x00	; 0
    121a:	50 e0       	ldi	r21, 0x00	; 0
    121c:	ac 17       	cp	r26, r28
    121e:	bd 07       	cpc	r27, r29
    1220:	08 f1       	brcs	.+66     	; 0x1264 <free+0x6a>
    1222:	bb 83       	std	Y+3, r27	; 0x03
    1224:	aa 83       	std	Y+2, r26	; 0x02
    1226:	fe 01       	movw	r30, r28
    1228:	21 91       	ld	r18, Z+
    122a:	31 91       	ld	r19, Z+
    122c:	e2 0f       	add	r30, r18
    122e:	f3 1f       	adc	r31, r19
    1230:	ae 17       	cp	r26, r30
    1232:	bf 07       	cpc	r27, r31
    1234:	79 f4       	brne	.+30     	; 0x1254 <free+0x5a>
    1236:	8d 91       	ld	r24, X+
    1238:	9c 91       	ld	r25, X
    123a:	11 97       	sbiw	r26, 0x01	; 1
    123c:	28 0f       	add	r18, r24
    123e:	39 1f       	adc	r19, r25
    1240:	2e 5f       	subi	r18, 0xFE	; 254
    1242:	3f 4f       	sbci	r19, 0xFF	; 255
    1244:	39 83       	std	Y+1, r19	; 0x01
    1246:	28 83       	st	Y, r18
    1248:	12 96       	adiw	r26, 0x02	; 2
    124a:	8d 91       	ld	r24, X+
    124c:	9c 91       	ld	r25, X
    124e:	13 97       	sbiw	r26, 0x03	; 3
    1250:	9b 83       	std	Y+3, r25	; 0x03
    1252:	8a 83       	std	Y+2, r24	; 0x02
    1254:	41 15       	cp	r20, r1
    1256:	51 05       	cpc	r21, r1
    1258:	71 f4       	brne	.+28     	; 0x1276 <free+0x7c>
    125a:	d0 93 93 02 	sts	0x0293, r29
    125e:	c0 93 92 02 	sts	0x0292, r28
    1262:	20 c0       	rjmp	.+64     	; 0x12a4 <free+0xaa>
    1264:	12 96       	adiw	r26, 0x02	; 2
    1266:	8d 91       	ld	r24, X+
    1268:	9c 91       	ld	r25, X
    126a:	13 97       	sbiw	r26, 0x03	; 3
    126c:	ad 01       	movw	r20, r26
    126e:	00 97       	sbiw	r24, 0x00	; 0
    1270:	11 f0       	breq	.+4      	; 0x1276 <free+0x7c>
    1272:	dc 01       	movw	r26, r24
    1274:	d3 cf       	rjmp	.-90     	; 0x121c <free+0x22>
    1276:	fa 01       	movw	r30, r20
    1278:	d3 83       	std	Z+3, r29	; 0x03
    127a:	c2 83       	std	Z+2, r28	; 0x02
    127c:	21 91       	ld	r18, Z+
    127e:	31 91       	ld	r19, Z+
    1280:	e2 0f       	add	r30, r18
    1282:	f3 1f       	adc	r31, r19
    1284:	ce 17       	cp	r28, r30
    1286:	df 07       	cpc	r29, r31
    1288:	69 f4       	brne	.+26     	; 0x12a4 <free+0xaa>
    128a:	88 81       	ld	r24, Y
    128c:	99 81       	ldd	r25, Y+1	; 0x01
    128e:	28 0f       	add	r18, r24
    1290:	39 1f       	adc	r19, r25
    1292:	2e 5f       	subi	r18, 0xFE	; 254
    1294:	3f 4f       	sbci	r19, 0xFF	; 255
    1296:	fa 01       	movw	r30, r20
    1298:	31 83       	std	Z+1, r19	; 0x01
    129a:	20 83       	st	Z, r18
    129c:	8a 81       	ldd	r24, Y+2	; 0x02
    129e:	9b 81       	ldd	r25, Y+3	; 0x03
    12a0:	93 83       	std	Z+3, r25	; 0x03
    12a2:	82 83       	std	Z+2, r24	; 0x02
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	08 95       	ret

000012aa <strnlen_P>:
    12aa:	fc 01       	movw	r30, r24
    12ac:	05 90       	lpm	r0, Z+
    12ae:	61 50       	subi	r22, 0x01	; 1
    12b0:	70 40       	sbci	r23, 0x00	; 0
    12b2:	01 10       	cpse	r0, r1
    12b4:	d8 f7       	brcc	.-10     	; 0x12ac <strnlen_P+0x2>
    12b6:	80 95       	com	r24
    12b8:	90 95       	com	r25
    12ba:	8e 0f       	add	r24, r30
    12bc:	9f 1f       	adc	r25, r31
    12be:	08 95       	ret

000012c0 <memset>:
    12c0:	dc 01       	movw	r26, r24
    12c2:	01 c0       	rjmp	.+2      	; 0x12c6 <memset+0x6>
    12c4:	6d 93       	st	X+, r22
    12c6:	41 50       	subi	r20, 0x01	; 1
    12c8:	50 40       	sbci	r21, 0x00	; 0
    12ca:	e0 f7       	brcc	.-8      	; 0x12c4 <memset+0x4>
    12cc:	08 95       	ret

000012ce <strnlen>:
    12ce:	fc 01       	movw	r30, r24
    12d0:	61 50       	subi	r22, 0x01	; 1
    12d2:	70 40       	sbci	r23, 0x00	; 0
    12d4:	01 90       	ld	r0, Z+
    12d6:	01 10       	cpse	r0, r1
    12d8:	d8 f7       	brcc	.-10     	; 0x12d0 <strnlen+0x2>
    12da:	80 95       	com	r24
    12dc:	90 95       	com	r25
    12de:	8e 0f       	add	r24, r30
    12e0:	9f 1f       	adc	r25, r31
    12e2:	08 95       	ret

000012e4 <fputc>:
    12e4:	0f 93       	push	r16
    12e6:	1f 93       	push	r17
    12e8:	cf 93       	push	r28
    12ea:	df 93       	push	r29
    12ec:	8c 01       	movw	r16, r24
    12ee:	eb 01       	movw	r28, r22
    12f0:	8b 81       	ldd	r24, Y+3	; 0x03
    12f2:	81 ff       	sbrs	r24, 1
    12f4:	1b c0       	rjmp	.+54     	; 0x132c <fputc+0x48>
    12f6:	82 ff       	sbrs	r24, 2
    12f8:	0d c0       	rjmp	.+26     	; 0x1314 <fputc+0x30>
    12fa:	2e 81       	ldd	r18, Y+6	; 0x06
    12fc:	3f 81       	ldd	r19, Y+7	; 0x07
    12fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1300:	9d 81       	ldd	r25, Y+5	; 0x05
    1302:	28 17       	cp	r18, r24
    1304:	39 07       	cpc	r19, r25
    1306:	64 f4       	brge	.+24     	; 0x1320 <fputc+0x3c>
    1308:	e8 81       	ld	r30, Y
    130a:	f9 81       	ldd	r31, Y+1	; 0x01
    130c:	01 93       	st	Z+, r16
    130e:	f9 83       	std	Y+1, r31	; 0x01
    1310:	e8 83       	st	Y, r30
    1312:	06 c0       	rjmp	.+12     	; 0x1320 <fputc+0x3c>
    1314:	e8 85       	ldd	r30, Y+8	; 0x08
    1316:	f9 85       	ldd	r31, Y+9	; 0x09
    1318:	80 2f       	mov	r24, r16
    131a:	09 95       	icall
    131c:	89 2b       	or	r24, r25
    131e:	31 f4       	brne	.+12     	; 0x132c <fputc+0x48>
    1320:	8e 81       	ldd	r24, Y+6	; 0x06
    1322:	9f 81       	ldd	r25, Y+7	; 0x07
    1324:	01 96       	adiw	r24, 0x01	; 1
    1326:	9f 83       	std	Y+7, r25	; 0x07
    1328:	8e 83       	std	Y+6, r24	; 0x06
    132a:	02 c0       	rjmp	.+4      	; 0x1330 <fputc+0x4c>
    132c:	0f ef       	ldi	r16, 0xFF	; 255
    132e:	1f ef       	ldi	r17, 0xFF	; 255
    1330:	c8 01       	movw	r24, r16
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	08 95       	ret

0000133c <__ultoa_invert>:
    133c:	fa 01       	movw	r30, r20
    133e:	aa 27       	eor	r26, r26
    1340:	28 30       	cpi	r18, 0x08	; 8
    1342:	51 f1       	breq	.+84     	; 0x1398 <__ultoa_invert+0x5c>
    1344:	20 31       	cpi	r18, 0x10	; 16
    1346:	81 f1       	breq	.+96     	; 0x13a8 <__ultoa_invert+0x6c>
    1348:	e8 94       	clt
    134a:	6f 93       	push	r22
    134c:	6e 7f       	andi	r22, 0xFE	; 254
    134e:	6e 5f       	subi	r22, 0xFE	; 254
    1350:	7f 4f       	sbci	r23, 0xFF	; 255
    1352:	8f 4f       	sbci	r24, 0xFF	; 255
    1354:	9f 4f       	sbci	r25, 0xFF	; 255
    1356:	af 4f       	sbci	r26, 0xFF	; 255
    1358:	b1 e0       	ldi	r27, 0x01	; 1
    135a:	3e d0       	rcall	.+124    	; 0x13d8 <__ultoa_invert+0x9c>
    135c:	b4 e0       	ldi	r27, 0x04	; 4
    135e:	3c d0       	rcall	.+120    	; 0x13d8 <__ultoa_invert+0x9c>
    1360:	67 0f       	add	r22, r23
    1362:	78 1f       	adc	r23, r24
    1364:	89 1f       	adc	r24, r25
    1366:	9a 1f       	adc	r25, r26
    1368:	a1 1d       	adc	r26, r1
    136a:	68 0f       	add	r22, r24
    136c:	79 1f       	adc	r23, r25
    136e:	8a 1f       	adc	r24, r26
    1370:	91 1d       	adc	r25, r1
    1372:	a1 1d       	adc	r26, r1
    1374:	6a 0f       	add	r22, r26
    1376:	71 1d       	adc	r23, r1
    1378:	81 1d       	adc	r24, r1
    137a:	91 1d       	adc	r25, r1
    137c:	a1 1d       	adc	r26, r1
    137e:	20 d0       	rcall	.+64     	; 0x13c0 <__ultoa_invert+0x84>
    1380:	09 f4       	brne	.+2      	; 0x1384 <__ultoa_invert+0x48>
    1382:	68 94       	set
    1384:	3f 91       	pop	r19
    1386:	2a e0       	ldi	r18, 0x0A	; 10
    1388:	26 9f       	mul	r18, r22
    138a:	11 24       	eor	r1, r1
    138c:	30 19       	sub	r19, r0
    138e:	30 5d       	subi	r19, 0xD0	; 208
    1390:	31 93       	st	Z+, r19
    1392:	de f6       	brtc	.-74     	; 0x134a <__ultoa_invert+0xe>
    1394:	cf 01       	movw	r24, r30
    1396:	08 95       	ret
    1398:	46 2f       	mov	r20, r22
    139a:	47 70       	andi	r20, 0x07	; 7
    139c:	40 5d       	subi	r20, 0xD0	; 208
    139e:	41 93       	st	Z+, r20
    13a0:	b3 e0       	ldi	r27, 0x03	; 3
    13a2:	0f d0       	rcall	.+30     	; 0x13c2 <__ultoa_invert+0x86>
    13a4:	c9 f7       	brne	.-14     	; 0x1398 <__ultoa_invert+0x5c>
    13a6:	f6 cf       	rjmp	.-20     	; 0x1394 <__ultoa_invert+0x58>
    13a8:	46 2f       	mov	r20, r22
    13aa:	4f 70       	andi	r20, 0x0F	; 15
    13ac:	40 5d       	subi	r20, 0xD0	; 208
    13ae:	4a 33       	cpi	r20, 0x3A	; 58
    13b0:	18 f0       	brcs	.+6      	; 0x13b8 <__ultoa_invert+0x7c>
    13b2:	49 5d       	subi	r20, 0xD9	; 217
    13b4:	31 fd       	sbrc	r19, 1
    13b6:	40 52       	subi	r20, 0x20	; 32
    13b8:	41 93       	st	Z+, r20
    13ba:	02 d0       	rcall	.+4      	; 0x13c0 <__ultoa_invert+0x84>
    13bc:	a9 f7       	brne	.-22     	; 0x13a8 <__ultoa_invert+0x6c>
    13be:	ea cf       	rjmp	.-44     	; 0x1394 <__ultoa_invert+0x58>
    13c0:	b4 e0       	ldi	r27, 0x04	; 4
    13c2:	a6 95       	lsr	r26
    13c4:	97 95       	ror	r25
    13c6:	87 95       	ror	r24
    13c8:	77 95       	ror	r23
    13ca:	67 95       	ror	r22
    13cc:	ba 95       	dec	r27
    13ce:	c9 f7       	brne	.-14     	; 0x13c2 <__ultoa_invert+0x86>
    13d0:	00 97       	sbiw	r24, 0x00	; 0
    13d2:	61 05       	cpc	r22, r1
    13d4:	71 05       	cpc	r23, r1
    13d6:	08 95       	ret
    13d8:	9b 01       	movw	r18, r22
    13da:	ac 01       	movw	r20, r24
    13dc:	0a 2e       	mov	r0, r26
    13de:	06 94       	lsr	r0
    13e0:	57 95       	ror	r21
    13e2:	47 95       	ror	r20
    13e4:	37 95       	ror	r19
    13e6:	27 95       	ror	r18
    13e8:	ba 95       	dec	r27
    13ea:	c9 f7       	brne	.-14     	; 0x13de <__ultoa_invert+0xa2>
    13ec:	62 0f       	add	r22, r18
    13ee:	73 1f       	adc	r23, r19
    13f0:	84 1f       	adc	r24, r20
    13f2:	95 1f       	adc	r25, r21
    13f4:	a0 1d       	adc	r26, r0
    13f6:	08 95       	ret

000013f8 <__udivmodsi4>:
    13f8:	a1 e2       	ldi	r26, 0x21	; 33
    13fa:	1a 2e       	mov	r1, r26
    13fc:	aa 1b       	sub	r26, r26
    13fe:	bb 1b       	sub	r27, r27
    1400:	fd 01       	movw	r30, r26
    1402:	0d c0       	rjmp	.+26     	; 0x141e <__udivmodsi4_ep>

00001404 <__udivmodsi4_loop>:
    1404:	aa 1f       	adc	r26, r26
    1406:	bb 1f       	adc	r27, r27
    1408:	ee 1f       	adc	r30, r30
    140a:	ff 1f       	adc	r31, r31
    140c:	a2 17       	cp	r26, r18
    140e:	b3 07       	cpc	r27, r19
    1410:	e4 07       	cpc	r30, r20
    1412:	f5 07       	cpc	r31, r21
    1414:	20 f0       	brcs	.+8      	; 0x141e <__udivmodsi4_ep>
    1416:	a2 1b       	sub	r26, r18
    1418:	b3 0b       	sbc	r27, r19
    141a:	e4 0b       	sbc	r30, r20
    141c:	f5 0b       	sbc	r31, r21

0000141e <__udivmodsi4_ep>:
    141e:	66 1f       	adc	r22, r22
    1420:	77 1f       	adc	r23, r23
    1422:	88 1f       	adc	r24, r24
    1424:	99 1f       	adc	r25, r25
    1426:	1a 94       	dec	r1
    1428:	69 f7       	brne	.-38     	; 0x1404 <__udivmodsi4_loop>
    142a:	60 95       	com	r22
    142c:	70 95       	com	r23
    142e:	80 95       	com	r24
    1430:	90 95       	com	r25
    1432:	9b 01       	movw	r18, r22
    1434:	ac 01       	movw	r20, r24
    1436:	bd 01       	movw	r22, r26
    1438:	cf 01       	movw	r24, r30
    143a:	08 95       	ret

0000143c <__prologue_saves__>:
    143c:	2f 92       	push	r2
    143e:	3f 92       	push	r3
    1440:	4f 92       	push	r4
    1442:	5f 92       	push	r5
    1444:	6f 92       	push	r6
    1446:	7f 92       	push	r7
    1448:	8f 92       	push	r8
    144a:	9f 92       	push	r9
    144c:	af 92       	push	r10
    144e:	bf 92       	push	r11
    1450:	cf 92       	push	r12
    1452:	df 92       	push	r13
    1454:	ef 92       	push	r14
    1456:	ff 92       	push	r15
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	cd b7       	in	r28, 0x3d	; 61
    1462:	de b7       	in	r29, 0x3e	; 62
    1464:	ca 1b       	sub	r28, r26
    1466:	db 0b       	sbc	r29, r27
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	de bf       	out	0x3e, r29	; 62
    146e:	0f be       	out	0x3f, r0	; 63
    1470:	cd bf       	out	0x3d, r28	; 61
    1472:	09 94       	ijmp

00001474 <__epilogue_restores__>:
    1474:	2a 88       	ldd	r2, Y+18	; 0x12
    1476:	39 88       	ldd	r3, Y+17	; 0x11
    1478:	48 88       	ldd	r4, Y+16	; 0x10
    147a:	5f 84       	ldd	r5, Y+15	; 0x0f
    147c:	6e 84       	ldd	r6, Y+14	; 0x0e
    147e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1480:	8c 84       	ldd	r8, Y+12	; 0x0c
    1482:	9b 84       	ldd	r9, Y+11	; 0x0b
    1484:	aa 84       	ldd	r10, Y+10	; 0x0a
    1486:	b9 84       	ldd	r11, Y+9	; 0x09
    1488:	c8 84       	ldd	r12, Y+8	; 0x08
    148a:	df 80       	ldd	r13, Y+7	; 0x07
    148c:	ee 80       	ldd	r14, Y+6	; 0x06
    148e:	fd 80       	ldd	r15, Y+5	; 0x05
    1490:	0c 81       	ldd	r16, Y+4	; 0x04
    1492:	1b 81       	ldd	r17, Y+3	; 0x03
    1494:	aa 81       	ldd	r26, Y+2	; 0x02
    1496:	b9 81       	ldd	r27, Y+1	; 0x01
    1498:	ce 0f       	add	r28, r30
    149a:	d1 1d       	adc	r29, r1
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	f8 94       	cli
    14a0:	de bf       	out	0x3e, r29	; 62
    14a2:	0f be       	out	0x3f, r0	; 63
    14a4:	cd bf       	out	0x3d, r28	; 61
    14a6:	ed 01       	movw	r28, r26
    14a8:	08 95       	ret

000014aa <_exit>:
    14aa:	f8 94       	cli

000014ac <__stop_program>:
    14ac:	ff cf       	rjmp	.-2      	; 0x14ac <__stop_program>
