
bygger_gruppe_15.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000192  00800100  00001252  000012e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001252  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  00800292  00800292  00001478  2**0
                  ALLOC
  3 .debug_aranges 00000100  00000000  00000000  00001478  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002d5  00000000  00000000  00001578  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000dac  00000000  00000000  0000184d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007f2  00000000  00000000  000025f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000e49  00000000  00000000  00002deb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002a0  00000000  00000000  00003c34  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000440  00000000  00000000  00003ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000065f  00000000  00000000  00004314  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00004973  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
       4:	0c 94 71 01 	jmp	0x2e2	; 0x2e2 <__vector_1>
       8:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
       c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      10:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      14:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      18:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      1c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      20:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      24:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      28:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      2c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      30:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      34:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      38:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      3c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      40:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      44:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      48:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      4c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      50:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      54:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      58:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      5c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      60:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      64:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      68:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
      6c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>

00000070 <__ctors_end>:
      70:	11 24       	eor	r1, r1
      72:	1f be       	out	0x3f, r1	; 63
      74:	cf ef       	ldi	r28, 0xFF	; 255
      76:	d4 e0       	ldi	r29, 0x04	; 4
      78:	de bf       	out	0x3e, r29	; 62
      7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
      7c:	12 e0       	ldi	r17, 0x02	; 2
      7e:	a0 e0       	ldi	r26, 0x00	; 0
      80:	b1 e0       	ldi	r27, 0x01	; 1
      82:	e2 e5       	ldi	r30, 0x52	; 82
      84:	f2 e1       	ldi	r31, 0x12	; 18
      86:	02 c0       	rjmp	.+4      	; 0x8c <.do_copy_data_start>

00000088 <.do_copy_data_loop>:
      88:	05 90       	lpm	r0, Z+
      8a:	0d 92       	st	X+, r0

0000008c <.do_copy_data_start>:
      8c:	a2 39       	cpi	r26, 0x92	; 146
      8e:	b1 07       	cpc	r27, r17
      90:	d9 f7       	brne	.-10     	; 0x88 <.do_copy_data_loop>

00000092 <__do_clear_bss>:
      92:	12 e0       	ldi	r17, 0x02	; 2
      94:	a2 e9       	ldi	r26, 0x92	; 146
      96:	b2 e0       	ldi	r27, 0x02	; 2
      98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
      9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
      9c:	ac 39       	cpi	r26, 0x9C	; 156
      9e:	b1 07       	cpc	r27, r17
      a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
      a2:	0e 94 57 00 	call	0xae	; 0xae <main>
      a6:	0c 94 27 09 	jmp	0x124e	; 0x124e <_exit>

000000aa <__bad_interrupt>:
      aa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ae <main>:
#include "sram.h"
#include "joystick.h"
#include "butterfly_interface.h"

int main(void) {
	SPI_NoSlave();
      ae:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
	init_UART(BAUD);
      b2:	80 e8       	ldi	r24, 0x80	; 128
      b4:	95 e2       	ldi	r25, 0x25	; 37
      b6:	0e 94 94 00 	call	0x128	; 0x128 <init_UART>
	init_SRAM();
      ba:	0e 94 bc 00 	call	0x178	; 0x178 <init_SRAM>
	init_joystick();
      be:	0e 94 fe 00 	call	0x1fc	; 0x1fc <init_joystick>
	SPI_MasterInit();	
      c2:	0e 94 2f 01 	call	0x25e	; 0x25e <SPI_MasterInit>
	CAN_init();
      c6:	0e 94 6f 02 	call	0x4de	; 0x4de <CAN_init>



	printf("Initialization complete\n");
      ca:	80 e0       	ldi	r24, 0x00	; 0
      cc:	91 e0       	ldi	r25, 0x01	; 1
      ce:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <puts>


	printf("CAN_test: %d", CAN_test());
      d2:	0e 94 36 02 	call	0x46c	; 0x46c <CAN_test>
      d6:	00 d0       	rcall	.+0      	; 0xd8 <main+0x2a>
      d8:	00 d0       	rcall	.+0      	; 0xda <main+0x2c>
      da:	28 e1       	ldi	r18, 0x18	; 24
      dc:	31 e0       	ldi	r19, 0x01	; 1
      de:	ed b7       	in	r30, 0x3d	; 61
      e0:	fe b7       	in	r31, 0x3e	; 62
      e2:	32 83       	std	Z+2, r19	; 0x02
      e4:	21 83       	std	Z+1, r18	; 0x01
      e6:	94 83       	std	Z+4, r25	; 0x04
      e8:	83 83       	std	Z+3, r24	; 0x03
      ea:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>

	
	
	

	butterfly_menu();
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	0e 94 17 03 	call	0x62e	; 0x62e <butterfly_menu>

	return 0;	
	
}
      fa:	80 e0       	ldi	r24, 0x00	; 0
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	08 95       	ret

00000100 <UART_put_char>:
	return 0;

} 

// Send char using UART (can be optimised using interrupt)
int UART_put_char(char c, FILE* dummy){
     100:	1f 93       	push	r17
     102:	18 2f       	mov	r17, r24
	if (c == '\n') UART_put_char('\r', dummy);
     104:	8a 30       	cpi	r24, 0x0A	; 10
     106:	19 f4       	brne	.+6      	; 0x10e <UART_put_char+0xe>
     108:	8d e0       	ldi	r24, 0x0D	; 13
     10a:	0e 94 80 00 	call	0x100	; 0x100 <UART_put_char>
	loop_until_bit_is_set(UCSR0A, UDRE0); 
     10e:	5d 9b       	sbis	0x0b, 5	; 11
     110:	fe cf       	rjmp	.-4      	; 0x10e <UART_put_char+0xe>
	//while ( !( UCSR0A & (1<<UDRE0)) );
	UDR0 = (unsigned char)c;
     112:	1c b9       	out	0x0c, r17	; 12
	return 0;
}
     114:	80 e0       	ldi	r24, 0x00	; 0
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	1f 91       	pop	r17
     11a:	08 95       	ret

0000011c <UART_get_char>:

// Receive char using UART (can be optimised using interrupt)
int UART_get_char(FILE* dummy){
	loop_until_bit_is_set(UCSR0A, RXC0);
     11c:	5f 9b       	sbis	0x0b, 7	; 11
     11e:	fe cf       	rjmp	.-4      	; 0x11c <UART_get_char>
	//while ( !(UCSR0A & (1<<RXC0)) );
	char c = UDR0;
     120:	8c b1       	in	r24, 0x0c	; 12
	if (c == '\r') c = '\n';
	return (int) UDR0;
     122:	8c b1       	in	r24, 0x0c	; 12
}
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	08 95       	ret

00000128 <init_UART>:
	
	//Enable Interrupts. Macro.
	//sei();

	unsigned long ubrr0 = baud;
	ubrr0 = (FOSC/(16*ubrr0)) - 1;
     128:	9c 01       	movw	r18, r24
     12a:	40 e0       	ldi	r20, 0x00	; 0
     12c:	50 e0       	ldi	r21, 0x00	; 0
     12e:	64 e0       	ldi	r22, 0x04	; 4
     130:	22 0f       	add	r18, r18
     132:	33 1f       	adc	r19, r19
     134:	44 1f       	adc	r20, r20
     136:	55 1f       	adc	r21, r21
     138:	6a 95       	dec	r22
     13a:	d1 f7       	brne	.-12     	; 0x130 <init_UART+0x8>
     13c:	6a ef       	ldi	r22, 0xFA	; 250
     13e:	70 e0       	ldi	r23, 0x00	; 0
     140:	8b e4       	ldi	r24, 0x4B	; 75
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	0e 94 ce 08 	call	0x119c	; 0x119c <__udivmodsi4>
     148:	c9 01       	movw	r24, r18
     14a:	da 01       	movw	r26, r20
     14c:	01 97       	sbiw	r24, 0x01	; 1
     14e:	a1 09       	sbc	r26, r1
     150:	b1 09       	sbc	r27, r1
	buffer_start = 0;
	buffer_stop = 0;
	buffer_used = 0;*/

	/* Sette baud rate */
	UBRR0H = (unsigned char)(ubrr0>>8);
     152:	29 2f       	mov	r18, r25
     154:	3a 2f       	mov	r19, r26
     156:	4b 2f       	mov	r20, r27
     158:	55 27       	eor	r21, r21
     15a:	20 bd       	out	0x20, r18	; 32
	UBRR0L = (unsigned char)ubrr0;
     15c:	89 b9       	out	0x09, r24	; 9
	
	/* Enable receiver og transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
     15e:	88 e1       	ldi	r24, 0x18	; 24
     160:	8a b9       	out	0x0a, r24	; 10
	ucsr0c = ucsr0c | (1<<UPM01) | (0<<UPM00);

	/*URSEL0 must be set to 1 according to data sheet*/
	ucsr0c = ucsr0c | (1<<URSEL0);
		
	UCSR0C = ucsr0c;
     162:	86 ea       	ldi	r24, 0xA6	; 166
     164:	80 bd       	out	0x20, r24	; 32

	fdevopen(UART_put_char, UART_get_char);
     166:	80 e8       	ldi	r24, 0x80	; 128
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	6e e8       	ldi	r22, 0x8E	; 142
     16c:	70 e0       	ldi	r23, 0x00	; 0
     16e:	0e 94 8c 04 	call	0x918	; 0x918 <fdevopen>

	return 0;

} 
     172:	80 e0       	ldi	r24, 0x00	; 0
     174:	90 e0       	ldi	r25, 0x00	; 0
     176:	08 95       	ret

00000178 <init_SRAM>:
#include "sram.h"

//Initialize the extended RAM
void init_SRAM(void)
{
	MCUCR =  MCUCR | (1<<SRW10) | (1<<SRE);// | (1<<SRW10));(1<<SRE)
     178:	85 b7       	in	r24, 0x35	; 53
     17a:	80 6c       	ori	r24, 0xC0	; 192
     17c:	85 bf       	out	0x35, r24	; 53
	EMCUCR =  EMCUCR | (1<<SRW00); 
     17e:	86 b7       	in	r24, 0x36	; 54
     180:	84 60       	ori	r24, 0x04	; 4
     182:	86 bf       	out	0x36, r24	; 54
	SFIOR =  SFIOR | (1<<XMM2);
     184:	80 b7       	in	r24, 0x30	; 48
     186:	80 62       	ori	r24, 0x20	; 32
     188:	80 bf       	out	0x30, r24	; 48
}
     18a:	08 95       	ret

0000018c <SRAM_test>:

//Function to test the extended RAM. Will print out Error!!! in the terminal
//if the content of the RAM is different from what it should be.
void SRAM_test(void)
{
     18c:	0f 93       	push	r16
     18e:	1f 93       	push	r17
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
	unsigned char *ram_address = (unsigned char *) 0x1000;
	printf("Starting...\n");
     194:	85 e2       	ldi	r24, 0x25	; 37
     196:	91 e0       	ldi	r25, 0x01	; 1
     198:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <puts>
     19c:	e0 e0       	ldi	r30, 0x00	; 0
     19e:	f0 e1       	ldi	r31, 0x10	; 16

	int i;
	for(i=0;i<0x800;i++)
	{
		ram_address[i] = (char)0x83;
     1a0:	43 e8       	ldi	r20, 0x83	; 131
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     1a2:	29 e9       	ldi	r18, 0x99	; 153
     1a4:	39 e0       	ldi	r19, 0x09	; 9
     1a6:	41 93       	st	Z+, r20
     1a8:	c9 01       	movw	r24, r18
     1aa:	01 97       	sbiw	r24, 0x01	; 1
     1ac:	f1 f7       	brne	.-4      	; 0x1aa <SRAM_test+0x1e>
{
	unsigned char *ram_address = (unsigned char *) 0x1000;
	printf("Starting...\n");

	int i;
	for(i=0;i<0x800;i++)
     1ae:	88 e1       	ldi	r24, 0x18	; 24
     1b0:	e0 30       	cpi	r30, 0x00	; 0
     1b2:	f8 07       	cpc	r31, r24
     1b4:	c1 f7       	brne	.-16     	; 0x1a6 <SRAM_test+0x1a>
     1b6:	c0 e0       	ldi	r28, 0x00	; 0
     1b8:	d0 e0       	ldi	r29, 0x00	; 0
		//printf("Adresse: 0x%x ", i);
		//printf("Lest: 0x%x \n", j);
		
		if(ram_address[i] != (char)0x83)
		{
			printf("Error!!! RAM no. 0x%x ",i);
     1ba:	01 e3       	ldi	r16, 0x31	; 49
     1bc:	11 e0       	ldi	r17, 0x01	; 1
		int j = (int)c;
		
		//printf("Adresse: 0x%x ", i);
		//printf("Lest: 0x%x \n", j);
		
		if(ram_address[i] != (char)0x83)
     1be:	c0 50       	subi	r28, 0x00	; 0
     1c0:	d0 4f       	sbci	r29, 0xF0	; 240
     1c2:	88 81       	ld	r24, Y
     1c4:	c0 50       	subi	r28, 0x00	; 0
     1c6:	d0 41       	sbci	r29, 0x10	; 16
     1c8:	83 38       	cpi	r24, 0x83	; 131
     1ca:	71 f0       	breq	.+28     	; 0x1e8 <SRAM_test+0x5c>
		{
			printf("Error!!! RAM no. 0x%x ",i);
     1cc:	00 d0       	rcall	.+0      	; 0x1ce <SRAM_test+0x42>
     1ce:	00 d0       	rcall	.+0      	; 0x1d0 <SRAM_test+0x44>
     1d0:	ed b7       	in	r30, 0x3d	; 61
     1d2:	fe b7       	in	r31, 0x3e	; 62
     1d4:	12 83       	std	Z+2, r17	; 0x02
     1d6:	01 83       	std	Z+1, r16	; 0x01
     1d8:	d4 83       	std	Z+4, r29	; 0x04
     1da:	c3 83       	std	Z+3, r28	; 0x03
     1dc:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>
     1e0:	0f 90       	pop	r0
     1e2:	0f 90       	pop	r0
     1e4:	0f 90       	pop	r0
     1e6:	0f 90       	pop	r0
		ram_address[i] = (char)0x83;
		_delay_ms(2);
	//	printf("skriver RAM no. 0x%x \n", i);
	}

	for(i=0;i<0x800;i++)
     1e8:	21 96       	adiw	r28, 0x01	; 1
     1ea:	f8 e0       	ldi	r31, 0x08	; 8
     1ec:	c0 30       	cpi	r28, 0x00	; 0
     1ee:	df 07       	cpc	r29, r31
     1f0:	31 f7       	brne	.-52     	; 0x1be <SRAM_test+0x32>
			//printf("Written OK\n");
		}
		//_delay_ms(2);
	}

	printf("Finished!!!\n");
     1f2:	88 e4       	ldi	r24, 0x48	; 72
     1f4:	91 e0       	ldi	r25, 0x01	; 1
     1f6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <puts>
     1fa:	ff cf       	rjmp	.-2      	; 0x1fa <SRAM_test+0x6e>

000001fc <init_joystick>:


// Initialize the joystick
void init_joystick(){
	// set port B: in
	DDRB = 0x00; //inputs
     1fc:	17 ba       	out	0x17, r1	; 23
	PORTB = 0xFF; //Pull-ups
     1fe:	8f ef       	ldi	r24, 0xFF	; 255
     200:	88 bb       	out	0x18, r24	; 24
}
     202:	08 95       	ret

00000204 <read_axis>:

// Read joystick position, returns int8
int8_t read_axis(char axis) {
	volatile uint8_t *adc_address = (uint8_t *) 0x1800;
	
	if(axis == 'x'){
     204:	88 37       	cpi	r24, 0x78	; 120
     206:	79 f4       	brne	.+30     	; 0x226 <read_axis+0x22>
		adc_address[0] = 0x04;
     208:	84 e0       	ldi	r24, 0x04	; 4
     20a:	80 93 00 18 	sts	0x1800, r24
		loop_until_bit_is_clear(PINB, 0);
     20e:	b0 99       	sbic	0x16, 0	; 22
     210:	fe cf       	rjmp	.-4      	; 0x20e <read_axis+0xa>
		return (int8_t)eeprom_read_byte((uint8_t*)*adc_address);
     212:	80 91 00 18 	lds	r24, 0x1800
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     216:	e1 99       	sbic	0x1c, 1	; 28
     218:	fe cf       	rjmp	.-4      	; 0x216 <read_axis+0x12>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     21a:	90 e0       	ldi	r25, 0x00	; 0
     21c:	9f bb       	out	0x1f, r25	; 31
     21e:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     220:	e0 9a       	sbi	0x1c, 0	; 28
     222:	8d b3       	in	r24, 0x1d	; 29
     224:	08 95       	ret
	}
	else if(axis == 'y'){
     226:	89 37       	cpi	r24, 0x79	; 121
     228:	11 f0       	breq	.+4      	; 0x22e <read_axis+0x2a>
     22a:	8f ef       	ldi	r24, 0xFF	; 255
     22c:	08 95       	ret
		adc_address[0] = 0x06;
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	80 93 00 18 	sts	0x1800, r24
		loop_until_bit_is_clear(PINB, 0);
     234:	b0 99       	sbic	0x16, 0	; 22
     236:	fe cf       	rjmp	.-4      	; 0x234 <read_axis+0x30>
		return (int8_t)eeprom_read_byte((uint8_t*)(*adc_address+256));
     238:	80 91 00 18 	lds	r24, 0x1800
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     23c:	e1 99       	sbic	0x1c, 1	; 28
     23e:	fe cf       	rjmp	.-4      	; 0x23c <read_axis+0x38>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	80 50       	subi	r24, 0x00	; 0
     244:	9f 4f       	sbci	r25, 0xFF	; 255
     246:	9f bb       	out	0x1f, r25	; 31
     248:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     24a:	e0 9a       	sbi	0x1c, 0	; 28
     24c:	8d b3       	in	r24, 0x1d	; 29
	}
	return -1;
	//evt. korrigering
}
     24e:	08 95       	ret

00000250 <read_buttons>:


// Read joystick buttons (Can be optimised with interrupt)
inline uint8_t read_buttons(){
	return (PINB & 0x6) >> 1;
     250:	86 b3       	in	r24, 0x16	; 22
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	86 70       	andi	r24, 0x06	; 6
     256:	90 70       	andi	r25, 0x00	; 0
     258:	95 95       	asr	r25
     25a:	87 95       	ror	r24
}
     25c:	08 95       	ret

0000025e <SPI_MasterInit>:

// Initialize the SPI Master interface
void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	DDRB = (DDRB & 0x0F) | ((1<<DDB5) | (1<<DDB7) | (1<<DDB3)| (1<<DDB4));
     25e:	87 b3       	in	r24, 0x17	; 23
     260:	87 70       	andi	r24, 0x07	; 7
     262:	88 6b       	ori	r24, 0xB8	; 184
     264:	87 bb       	out	0x17, r24	; 23
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     266:	81 e5       	ldi	r24, 0x51	; 81
     268:	8d b9       	out	0x0d, r24	; 13
}

// Disable chipselect on all SPI slaves (select no slave)
void SPI_NoSlave(void){
	/* Set SS high */	
	PORTB = PORTB | (1<<DDB4) | (1<<DDB3);
     26a:	88 b3       	in	r24, 0x18	; 24
     26c:	88 61       	ori	r24, 0x18	; 24
     26e:	88 bb       	out	0x18, r24	; 24
	/* Set MOSI and SCK output, all others input */
	DDRB = (DDRB & 0x0F) | ((1<<DDB5) | (1<<DDB7) | (1<<DDB3)| (1<<DDB4));
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
	SPI_NoSlave();
}
     270:	08 95       	ret

00000272 <SPI_MasterTransmit>:

// Transmit char over SPI
void SPI_MasterTransmit(char cData)
{
	/* Start transmission */
	SPDR = cData;
     272:	8f b9       	out	0x0f, r24	; 15
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     274:	77 9b       	sbis	0x0e, 7	; 14
     276:	fe cf       	rjmp	.-4      	; 0x274 <SPI_MasterTransmit+0x2>
}
     278:	08 95       	ret

0000027a <SPI_MasterReceive>:

// Transmit char over SPI
void SPI_MasterTransmit(char cData)
{
	/* Start transmission */
	SPDR = cData;
     27a:	80 e4       	ldi	r24, 0x40	; 64
     27c:	8f b9       	out	0x0f, r24	; 15
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     27e:	77 9b       	sbis	0x0e, 7	; 14
     280:	fe cf       	rjmp	.-4      	; 0x27e <SPI_MasterReceive+0x4>
{
	//send dummy char, to shift the SPDR
	SPI_MasterTransmit('@');
	
	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     282:	77 9b       	sbis	0x0e, 7	; 14
     284:	fe cf       	rjmp	.-4      	; 0x282 <SPI_MasterReceive+0x8>
	
	

	/* Return data register */
	return SPDR;
     286:	8f b1       	in	r24, 0x0f	; 15
}
     288:	08 95       	ret

0000028a <SPI_SelectSlave>:

// Select SPI slave to send data to
void SPI_SelectSlave(char slave){
	/* Slave select */
	if (slave == SPI_BUTTERFLY)
     28a:	82 36       	cpi	r24, 0x62	; 98
     28c:	11 f4       	brne	.+4      	; 0x292 <SPI_SelectSlave+0x8>
		PORTB = PORTB & ~(1<<DDB3) ; // set SS for butterfly low
     28e:	c3 98       	cbi	0x18, 3	; 24
     290:	08 95       	ret
	else if (slave == SPI_CAN)
     292:	83 37       	cpi	r24, 0x73	; 115
     294:	09 f4       	brne	.+2      	; 0x298 <SPI_SelectSlave+0xe>
		PORTB = PORTB & ~(1<<DDB4) ; // set SS for CAN low 
     296:	c4 98       	cbi	0x18, 4	; 24
     298:	08 95       	ret

0000029a <SPI_NoSlave>:
}

// Disable chipselect on all SPI slaves (select no slave)
void SPI_NoSlave(void){
	/* Set SS high */	
	PORTB = PORTB | (1<<DDB4) | (1<<DDB3);
     29a:	88 b3       	in	r24, 0x18	; 24
     29c:	88 61       	ori	r24, 0x18	; 24
     29e:	88 bb       	out	0x18, r24	; 24
}
     2a0:	08 95       	ret

000002a2 <CAN_init_interrupt>:
}*/


void CAN_init_interrupt(){
//interrupt init
	PORTD = PORTD | 0b00001100;
     2a2:	82 b3       	in	r24, 0x12	; 18
     2a4:	8c 60       	ori	r24, 0x0C	; 12
     2a6:	82 bb       	out	0x12, r24	; 18
	DDRD = DDRD & 	0b11110011;
     2a8:	81 b3       	in	r24, 0x11	; 17
     2aa:	83 7f       	andi	r24, 0xF3	; 243
     2ac:	81 bb       	out	0x11, r24	; 17
	MCUCR = MCUCR | (0<<ISC01) | (0<<ISC00) | (0<<ISC11) | (0<<ISC10);
     2ae:	85 b7       	in	r24, 0x35	; 53
     2b0:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | (1<<INT0) | (1<<INT1);
     2b2:	8b b7       	in	r24, 0x3b	; 59
     2b4:	80 6c       	ori	r24, 0xC0	; 192
     2b6:	8b bf       	out	0x3b, r24	; 59
	sei();
     2b8:	78 94       	sei
}
     2ba:	08 95       	ret

000002bc <CAN_receive>:
*/
	return 0;
}

// Recieve string from CAN recieve buffer
int CAN_receive(CAN_message* msg, int rx){
     2bc:	1f 93       	push	r17
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	ec 01       	movw	r28, r24
     2c4:	16 2f       	mov	r17, r22
	//FILHIT to check message type
	
	while((CAN_read_status() & MASK_CANINTF_RX0IF) == 0); // loop until data received
     2c6:	0e 94 ed 03 	call	0x7da	; 0x7da <CAN_read_status>
     2ca:	80 ff       	sbrs	r24, 0
     2cc:	fc cf       	rjmp	.-8      	; 0x2c6 <CAN_receive+0xa>
	CAN_read_rx(msg, rx);
     2ce:	ce 01       	movw	r24, r28
     2d0:	61 2f       	mov	r22, r17
     2d2:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <CAN_read_rx>
	
	return 0;

}
     2d6:	80 e0       	ldi	r24, 0x00	; 0
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	1f 91       	pop	r17
     2e0:	08 95       	ret

000002e2 <__vector_1>:
	GICR = GICR | (1<<INT0) | (1<<INT1);
	sei();
}


SIGNAL(SIG_INTERRUPT0) {
     2e2:	1f 92       	push	r1
     2e4:	0f 92       	push	r0
     2e6:	0f b6       	in	r0, 0x3f	; 63
     2e8:	0f 92       	push	r0
     2ea:	11 24       	eor	r1, r1
     2ec:	2f 93       	push	r18
     2ee:	3f 93       	push	r19
     2f0:	4f 93       	push	r20
     2f2:	5f 93       	push	r21
     2f4:	6f 93       	push	r22
     2f6:	7f 93       	push	r23
     2f8:	8f 93       	push	r24
     2fa:	9f 93       	push	r25
     2fc:	af 93       	push	r26
     2fe:	bf 93       	push	r27
     300:	ef 93       	push	r30
     302:	ff 93       	push	r31
     304:	df 93       	push	r29
     306:	cf 93       	push	r28
     308:	00 d0       	rcall	.+0      	; 0x30a <__vector_1+0x28>
     30a:	00 d0       	rcall	.+0      	; 0x30c <__vector_1+0x2a>
     30c:	0f 92       	push	r0
     30e:	cd b7       	in	r28, 0x3d	; 61
     310:	de b7       	in	r29, 0x3e	; 62
		
	CAN_message received;
	received.data = "\0\0\0\0\0\0\0\0";
     312:	84 e5       	ldi	r24, 0x54	; 84
     314:	91 e0       	ldi	r25, 0x01	; 1
     316:	9d 83       	std	Y+5, r25	; 0x05
     318:	8c 83       	std	Y+4, r24	; 0x04

	printf("Received: ");
     31a:	00 d0       	rcall	.+0      	; 0x31c <__vector_1+0x3a>
     31c:	8d e5       	ldi	r24, 0x5D	; 93
     31e:	91 e0       	ldi	r25, 0x01	; 1
     320:	ed b7       	in	r30, 0x3d	; 61
     322:	fe b7       	in	r31, 0x3e	; 62
     324:	92 83       	std	Z+2, r25	; 0x02
     326:	81 83       	std	Z+1, r24	; 0x01
     328:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>
    CAN_receive(&received, 0);
     32c:	0f 90       	pop	r0
     32e:	0f 90       	pop	r0
     330:	ce 01       	movw	r24, r28
     332:	01 96       	adiw	r24, 0x01	; 1
     334:	60 e0       	ldi	r22, 0x00	; 0
     336:	70 e0       	ldi	r23, 0x00	; 0
     338:	0e 94 5e 01 	call	0x2bc	; 0x2bc <CAN_receive>
	printf("%s\n", received.data);
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	9d 81       	ldd	r25, Y+5	; 0x05
     340:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <puts>

}
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	0f 90       	pop	r0
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	ff 91       	pop	r31
     354:	ef 91       	pop	r30
     356:	bf 91       	pop	r27
     358:	af 91       	pop	r26
     35a:	9f 91       	pop	r25
     35c:	8f 91       	pop	r24
     35e:	7f 91       	pop	r23
     360:	6f 91       	pop	r22
     362:	5f 91       	pop	r21
     364:	4f 91       	pop	r20
     366:	3f 91       	pop	r19
     368:	2f 91       	pop	r18
     36a:	0f 90       	pop	r0
     36c:	0f be       	out	0x3f, r0	; 63
     36e:	0f 90       	pop	r0
     370:	1f 90       	pop	r1
     372:	18 95       	reti

00000374 <CAN_send>:

	return 0;
}

// Send string using CAN bus
int CAN_send(char* str, int id){
     374:	af 92       	push	r10
     376:	bf 92       	push	r11
     378:	cf 92       	push	r12
     37a:	df 92       	push	r13
     37c:	ef 92       	push	r14
     37e:	ff 92       	push	r15
     380:	0f 93       	push	r16
     382:	1f 93       	push	r17
     384:	df 93       	push	r29
     386:	cf 93       	push	r28
     388:	00 d0       	rcall	.+0      	; 0x38a <CAN_send+0x16>
     38a:	00 d0       	rcall	.+0      	; 0x38c <CAN_send+0x18>
     38c:	0f 92       	push	r0
     38e:	cd b7       	in	r28, 0x3d	; 61
     390:	de b7       	in	r29, 0x3e	; 62
	
	unsigned int part, i;
	int done = 0;

	CAN_message messg;
	messg.id = id;
     392:	7a 83       	std	Y+2, r23	; 0x02
     394:	69 83       	std	Y+1, r22	; 0x01
     396:	7c 01       	movw	r14, r24
		cli(); // disable interrupts, to protect SPI-communication 

		CAN_bit_modify(TXB0SIDH, 0xFF, (messg.id<<13)); //transmit buffer 0 id high
		CAN_bit_modify(TXB0SIDL, MASK_SIDL, (messg.id<<5));//transmit buffer 0 id low
		CAN_write((char)messg.length, TXB0DLC);	// data length
		CAN_load_tx(&messg, 0); //load transmit buffer from channel 0
     398:	5e 01       	movw	r10, r28
     39a:	08 94       	sec
     39c:	a1 1c       	adc	r10, r1
     39e:	b1 1c       	adc	r11, r1
     3a0:	4e c0       	rjmp	.+156    	; 0x43e <CAN_send+0xca>

	CAN_message messg;
	messg.id = id;
	for (part = 0; !done; part += 8){
		for(i = 0; i < 8; i++){
			messg.data[i] = str[part+i];
     3a2:	ec 81       	ldd	r30, Y+4	; 0x04
     3a4:	fd 81       	ldd	r31, Y+5	; 0x05
     3a6:	e2 0f       	add	r30, r18
     3a8:	f3 1f       	adc	r31, r19
     3aa:	8c 91       	ld	r24, X
     3ac:	80 83       	st	Z, r24
			if (messg.data[i] == '\0') {
     3ae:	ec 81       	ldd	r30, Y+4	; 0x04
     3b0:	fd 81       	ldd	r31, Y+5	; 0x05
     3b2:	e2 0f       	add	r30, r18
     3b4:	f3 1f       	adc	r31, r19
     3b6:	80 81       	ld	r24, Z
     3b8:	a9 01       	movw	r20, r18
     3ba:	4f 5f       	subi	r20, 0xFF	; 255
     3bc:	5f 4f       	sbci	r21, 0xFF	; 255
     3be:	88 23       	and	r24, r24
     3c0:	21 f4       	brne	.+8      	; 0x3ca <CAN_send+0x56>
				done = 1;
				i++;
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	c8 2e       	mov	r12, r24
     3c6:	d1 2c       	mov	r13, r1
     3c8:	07 c0       	rjmp	.+14     	; 0x3d8 <CAN_send+0x64>
	int done = 0;

	CAN_message messg;
	messg.id = id;
	for (part = 0; !done; part += 8){
		for(i = 0; i < 8; i++){
     3ca:	9a 01       	movw	r18, r20
     3cc:	11 96       	adiw	r26, 0x01	; 1
     3ce:	48 30       	cpi	r20, 0x08	; 8
     3d0:	51 05       	cpc	r21, r1
     3d2:	39 f7       	brne	.-50     	; 0x3a2 <CAN_send+0x2e>
     3d4:	cc 24       	eor	r12, r12
     3d6:	dd 24       	eor	r13, r13
				i++;
				break;
			}
		}

		messg.length = i;
     3d8:	4b 83       	std	Y+3, r20	; 0x03
		cli(); // disable interrupts, to protect SPI-communication 
     3da:	f8 94       	cli

		CAN_bit_modify(TXB0SIDH, 0xFF, (messg.id<<13)); //transmit buffer 0 id high
     3dc:	81 e3       	ldi	r24, 0x31	; 49
     3de:	6f ef       	ldi	r22, 0xFF	; 255
     3e0:	40 e0       	ldi	r20, 0x00	; 0
     3e2:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
		CAN_bit_modify(TXB0SIDL, MASK_SIDL, (messg.id<<5));//transmit buffer 0 id low
     3e6:	49 81       	ldd	r20, Y+1	; 0x01
     3e8:	42 95       	swap	r20
     3ea:	44 0f       	add	r20, r20
     3ec:	40 7e       	andi	r20, 0xE0	; 224
     3ee:	82 e3       	ldi	r24, 0x32	; 50
     3f0:	60 ee       	ldi	r22, 0xE0	; 224
     3f2:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
		CAN_write((char)messg.length, TXB0DLC);	// data length
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	65 e3       	ldi	r22, 0x35	; 53
     3fa:	0e 94 cf 03 	call	0x79e	; 0x79e <CAN_write>
		CAN_load_tx(&messg, 0); //load transmit buffer from channel 0
     3fe:	c5 01       	movw	r24, r10
     400:	60 e0       	ldi	r22, 0x00	; 0
     402:	0e 94 54 04 	call	0x8a8	; 0x8a8 <CAN_load_tx>
		//printf("\n\n%s\n\n", messg.data);
		//_delay_ms(1);
		CAN_rts(0); //request to send
     406:	80 e0       	ldi	r24, 0x00	; 0
     408:	0e 94 b8 03 	call	0x770	; 0x770 <CAN_rts>
     40c:	00 e0       	ldi	r16, 0x00	; 0
     40e:	10 e0       	ldi	r17, 0x00	; 0

		//WHYY; BUT WHYYYYY?
		//wait for send OK ()
		for(i = 0; i < 0xffff; i++){
			if((CAN_read_status() & MASK_TXREQ0) == 0) break;
     410:	0e 94 ed 03 	call	0x7da	; 0x7da <CAN_read_status>
     414:	82 ff       	sbrs	r24, 2
     416:	06 c0       	rjmp	.+12     	; 0x424 <CAN_send+0xb0>
		//_delay_ms(1);
		CAN_rts(0); //request to send

		//WHYY; BUT WHYYYYY?
		//wait for send OK ()
		for(i = 0; i < 0xffff; i++){
     418:	0f 5f       	subi	r16, 0xFF	; 255
     41a:	1f 4f       	sbci	r17, 0xFF	; 255
     41c:	8f ef       	ldi	r24, 0xFF	; 255
     41e:	0f 3f       	cpi	r16, 0xFF	; 255
     420:	18 07       	cpc	r17, r24
     422:	b1 f7       	brne	.-20     	; 0x410 <CAN_send+0x9c>
			if((CAN_read_status() & MASK_TXREQ0) == 0) break;
		}
		sei(); // enable interrupts again
     424:	78 94       	sei
		if(i == 0xffff) return -1;
     426:	0f 5f       	subi	r16, 0xFF	; 255
     428:	1f 4f       	sbci	r17, 0xFF	; 255
     42a:	69 f0       	breq	.+26     	; 0x446 <CAN_send+0xd2>
     42c:	88 e0       	ldi	r24, 0x08	; 8
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	e8 0e       	add	r14, r24
     432:	f9 1e       	adc	r15, r25
	unsigned int part, i;
	int done = 0;

	CAN_message messg;
	messg.id = id;
	for (part = 0; !done; part += 8){
     434:	cd 28       	or	r12, r13
     436:	19 f0       	breq	.+6      	; 0x43e <CAN_send+0xca>
     438:	20 e0       	ldi	r18, 0x00	; 0
     43a:	30 e0       	ldi	r19, 0x00	; 0
     43c:	06 c0       	rjmp	.+12     	; 0x44a <CAN_send+0xd6>
     43e:	d7 01       	movw	r26, r14
     440:	20 e0       	ldi	r18, 0x00	; 0
     442:	30 e0       	ldi	r19, 0x00	; 0
     444:	ae cf       	rjmp	.-164    	; 0x3a2 <CAN_send+0x2e>
     446:	2f ef       	ldi	r18, 0xFF	; 255
     448:	3f ef       	ldi	r19, 0xFF	; 255
		}

		if(str[i] == '\0') break;
*/
	return 0;
}
     44a:	c9 01       	movw	r24, r18
     44c:	0f 90       	pop	r0
     44e:	0f 90       	pop	r0
     450:	0f 90       	pop	r0
     452:	0f 90       	pop	r0
     454:	0f 90       	pop	r0
     456:	cf 91       	pop	r28
     458:	df 91       	pop	r29
     45a:	1f 91       	pop	r17
     45c:	0f 91       	pop	r16
     45e:	ff 90       	pop	r15
     460:	ef 90       	pop	r14
     462:	df 90       	pop	r13
     464:	cf 90       	pop	r12
     466:	bf 90       	pop	r11
     468:	af 90       	pop	r10
     46a:	08 95       	ret

0000046c <CAN_test>:
	CAN_bit_modify(BFPCTRL, 0x0f, 0xff);
	CAN_init_interrupt();
}

// Test send and recieve in loopback mode, verify result from UART
int CAN_test(void){
     46c:	0f 93       	push	r16
     46e:	1f 93       	push	r17
	printf("CAN_test started\n");
     470:	88 e6       	ldi	r24, 0x68	; 104
     472:	91 e0       	ldi	r25, 0x01	; 1
     474:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <puts>
	message.length = 8;
	message.data = "1324567891011121314151617181920";
	

	// Reset will move into configuration mode
	CAN_reset();
     478:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <CAN_reset>
	CAN_bit_modify(CANCTRL, MASK_MODE, MODE_LOOPBACK); //set loopback mode
     47c:	8f e0       	ldi	r24, 0x0F	; 15
     47e:	60 ee       	ldi	r22, 0xE0	; 224
     480:	40 e4       	ldi	r20, 0x40	; 64
     482:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
	CAN_bit_modify(RXB0CTRL, MASK_RECEIVE_ID_TYPE, ID_TYPE_STANDARD);
     486:	80 e6       	ldi	r24, 0x60	; 96
     488:	60 e6       	ldi	r22, 0x60	; 96
     48a:	40 e2       	ldi	r20, 0x20	; 32
     48c:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
	CAN_bit_modify(BFPCTRL, 0x0f, 0xff);
     490:	8c e0       	ldi	r24, 0x0C	; 12
     492:	6f e0       	ldi	r22, 0x0F	; 15
     494:	4f ef       	ldi	r20, 0xFF	; 255
     496:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
	/*// Blanking out recieved buffer (really needed??)
	for (i = 0;(i < 9); i++)
		received[i] = '\0';	*/

	// Sending data in CAN bus
	printf("Sending string: %s", message.data);
     49a:	00 d0       	rcall	.+0      	; 0x49c <CAN_test+0x30>
     49c:	00 d0       	rcall	.+0      	; 0x49e <CAN_test+0x32>
     49e:	89 e7       	ldi	r24, 0x79	; 121
     4a0:	91 e0       	ldi	r25, 0x01	; 1
     4a2:	ed b7       	in	r30, 0x3d	; 61
     4a4:	fe b7       	in	r31, 0x3e	; 62
     4a6:	92 83       	std	Z+2, r25	; 0x02
     4a8:	81 83       	std	Z+1, r24	; 0x01
     4aa:	0c e8       	ldi	r16, 0x8C	; 140
     4ac:	11 e0       	ldi	r17, 0x01	; 1
     4ae:	14 83       	std	Z+4, r17	; 0x04
     4b0:	03 83       	std	Z+3, r16	; 0x03
     4b2:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>
	if (CAN_send(message.data, 0) != 0){
     4b6:	0f 90       	pop	r0
     4b8:	0f 90       	pop	r0
     4ba:	0f 90       	pop	r0
     4bc:	0f 90       	pop	r0
     4be:	c8 01       	movw	r24, r16
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 ba 01 	call	0x374	; 0x374 <CAN_send>
     4c8:	89 2b       	or	r24, r25
     4ca:	19 f4       	brne	.+6      	; 0x4d2 <CAN_test+0x66>
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	02 c0       	rjmp	.+4      	; 0x4d6 <CAN_test+0x6a>
     4d2:	2f ef       	ldi	r18, 0xFF	; 255
     4d4:	3f ef       	ldi	r19, 0xFF	; 255
		return -1;
	}

	return 0;
}
     4d6:	c9 01       	movw	r24, r18
     4d8:	1f 91       	pop	r17
     4da:	0f 91       	pop	r16
     4dc:	08 95       	ret

000004de <CAN_init>:
#include <avr/io.h>

//Initialize the CAN bus
void CAN_init(void){

	CAN_reset();
     4de:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <CAN_reset>

	CAN_bit_modify(CANCTRL, MASK_MODE, MODE_LOOPBACK); //set loopback mode
     4e2:	8f e0       	ldi	r24, 0x0F	; 15
     4e4:	60 ee       	ldi	r22, 0xE0	; 224
     4e6:	40 e4       	ldi	r20, 0x40	; 64
     4e8:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
	CAN_bit_modify(RXB0CTRL, MASK_RECEIVE_ID_TYPE, ID_TYPE_STANDARD); // set no filter, set to 01 to accept only standard, 00 to accept accordig to filters
     4ec:	80 e6       	ldi	r24, 0x60	; 96
     4ee:	60 e6       	ldi	r22, 0x60	; 96
     4f0:	40 e2       	ldi	r20, 0x20	; 32
     4f2:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
	CAN_bit_modify(BFPCTRL, 0x0f, 0xff);
     4f6:	8c e0       	ldi	r24, 0x0C	; 12
     4f8:	6f e0       	ldi	r22, 0x0F	; 15
     4fa:	4f ef       	ldi	r20, 0xFF	; 255
     4fc:	0e 94 9d 03 	call	0x73a	; 0x73a <CAN_bit_modify>
}*/


void CAN_init_interrupt(){
//interrupt init
	PORTD = PORTD | 0b00001100;
     500:	82 b3       	in	r24, 0x12	; 18
     502:	8c 60       	ori	r24, 0x0C	; 12
     504:	82 bb       	out	0x12, r24	; 18
	DDRD = DDRD & 	0b11110011;
     506:	81 b3       	in	r24, 0x11	; 17
     508:	83 7f       	andi	r24, 0xF3	; 243
     50a:	81 bb       	out	0x11, r24	; 17
	MCUCR = MCUCR | (0<<ISC01) | (0<<ISC00) | (0<<ISC11) | (0<<ISC10);
     50c:	85 b7       	in	r24, 0x35	; 53
     50e:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | (1<<INT0) | (1<<INT1);
     510:	8b b7       	in	r24, 0x3b	; 59
     512:	80 6c       	ori	r24, 0xC0	; 192
     514:	8b bf       	out	0x3b, r24	; 59
	sei();
     516:	78 94       	sei

	CAN_bit_modify(CANCTRL, MASK_MODE, MODE_LOOPBACK); //set loopback mode
	CAN_bit_modify(RXB0CTRL, MASK_RECEIVE_ID_TYPE, ID_TYPE_STANDARD); // set no filter, set to 01 to accept only standard, 00 to accept accordig to filters
	CAN_bit_modify(BFPCTRL, 0x0f, 0xff);
	CAN_init_interrupt();
}
     518:	08 95       	ret

0000051a <butterfly_poll_joystick>:
	

	sei(); //enable interrupts again
}

char butterfly_poll_joystick(){
     51a:	1f 93       	push	r17
	char button;	

	cli(); //disable interrupts to protect SPI-communication
     51c:	f8 94       	cli
	SPI_SelectSlave(SPI_BUTTERFLY);
     51e:	82 e6       	ldi	r24, 0x62	; 98
     520:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
	SPI_MasterTransmit('.');
     524:	8e e2       	ldi	r24, 0x2E	; 46
     526:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	90 e3       	ldi	r25, 0x30	; 48
     52e:	01 97       	sbiw	r24, 0x01	; 1
     530:	f1 f7       	brne	.-4      	; 0x52e <butterfly_poll_joystick+0x14>
	_delay_ms(10);
	button = SPI_MasterReceive();
     532:	0e 94 3d 01 	call	0x27a	; 0x27a <SPI_MasterReceive>
     536:	18 2f       	mov	r17, r24
	SPI_NoSlave();
     538:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>

	sei(); //enable interrupts again
     53c:	78 94       	sei
	return button;
}
     53e:	81 2f       	mov	r24, r17
     540:	1f 91       	pop	r17
     542:	08 95       	ret

00000544 <butterfly_print>:
			}
		}
	}
}

void butterfly_print(char * str){
     544:	0f 93       	push	r16
     546:	1f 93       	push	r17
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
     54c:	8c 01       	movw	r16, r24
	int i;
	cli(); //disable interrupts to protect SPI-communication
     54e:	f8 94       	cli
	SPI_SelectSlave(SPI_BUTTERFLY);
     550:	82 e6       	ldi	r24, 0x62	; 98
     552:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
     556:	c0 e0       	ldi	r28, 0x00	; 0
     558:	d0 e0       	ldi	r29, 0x00	; 0
	for (i = 0; i < TEXTBUFFER_SIZE-1; i++){ 
		if (str[i] == '\0') break;
     55a:	f8 01       	movw	r30, r16
     55c:	ec 0f       	add	r30, r28
     55e:	fd 1f       	adc	r31, r29
     560:	80 81       	ld	r24, Z
     562:	88 23       	and	r24, r24
     564:	31 f0       	breq	.+12     	; 0x572 <butterfly_print+0x2e>
		SPI_MasterTransmit(str[i]);
     566:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>

void butterfly_print(char * str){
	int i;
	cli(); //disable interrupts to protect SPI-communication
	SPI_SelectSlave(SPI_BUTTERFLY);
	for (i = 0; i < TEXTBUFFER_SIZE-1; i++){ 
     56a:	21 96       	adiw	r28, 0x01	; 1
     56c:	c8 31       	cpi	r28, 0x18	; 24
     56e:	d1 05       	cpc	r29, r1
     570:	a1 f7       	brne	.-24     	; 0x55a <butterfly_print+0x16>
		if (str[i] == '\0') break;
		SPI_MasterTransmit(str[i]);
	}
	SPI_MasterTransmit('\0');
     572:	80 e0       	ldi	r24, 0x00	; 0
     574:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_NoSlave();
     578:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
	

	sei(); //enable interrupts again
     57c:	78 94       	sei
}
     57e:	df 91       	pop	r29
     580:	cf 91       	pop	r28
     582:	1f 91       	pop	r17
     584:	0f 91       	pop	r16
     586:	08 95       	ret

00000588 <start_game>:
	sei(); //enable interrupts again
	return button;
}

void start_game(enum menu_state_enum menu_state){
	switch(menu_state) {
     588:	81 30       	cpi	r24, 0x01	; 1
     58a:	69 f0       	breq	.+26     	; 0x5a6 <start_game+0x1e>
     58c:	82 30       	cpi	r24, 0x02	; 2
     58e:	1c f4       	brge	.+6      	; 0x596 <start_game+0xe>
     590:	88 23       	and	r24, r24
     592:	31 f0       	breq	.+12     	; 0x5a0 <start_game+0x18>
     594:	08 95       	ret
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	49 f0       	breq	.+18     	; 0x5ac <start_game+0x24>
     59a:	83 30       	cpi	r24, 0x03	; 3
     59c:	b9 f4       	brne	.+46     	; 0x5cc <start_game+0x44>
     59e:	09 c0       	rjmp	.+18     	; 0x5b2 <start_game+0x2a>
		case START_SP_POINTS: 
			butterfly_print("enspiller poeng");
     5a0:	8c ea       	ldi	r24, 0xAC	; 172
     5a2:	91 e0       	ldi	r25, 0x01	; 1
     5a4:	08 c0       	rjmp	.+16     	; 0x5b6 <start_game+0x2e>
			break;
		case START_SP_ETERNAL: 
			butterfly_print("enspiller evig");
     5a6:	8c eb       	ldi	r24, 0xBC	; 188
     5a8:	91 e0       	ldi	r25, 0x01	; 1
     5aa:	05 c0       	rjmp	.+10     	; 0x5b6 <start_game+0x2e>
			break;
		case START_MP_POINTS: 	
			butterfly_print("versus poeng");
     5ac:	8b ec       	ldi	r24, 0xCB	; 203
     5ae:	91 e0       	ldi	r25, 0x01	; 1
     5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <start_game+0x2e>
			break;
		case START_MP_ETERNAL: 	
			butterfly_print("versus evig");	
     5b2:	88 ed       	ldi	r24, 0xD8	; 216
     5b4:	91 e0       	ldi	r25, 0x01	; 1
     5b6:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     5ba:	80 e2       	ldi	r24, 0x20	; 32
     5bc:	9e e4       	ldi	r25, 0x4E	; 78
     5be:	2a e7       	ldi	r18, 0x7A	; 122
     5c0:	30 e0       	ldi	r19, 0x00	; 0
     5c2:	f9 01       	movw	r30, r18
     5c4:	31 97       	sbiw	r30, 0x01	; 1
     5c6:	f1 f7       	brne	.-4      	; 0x5c4 <start_game+0x3c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     5c8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     5ca:	d9 f7       	brne	.-10     	; 0x5c2 <start_game+0x3a>
     5cc:	08 95       	ret

000005ce <butterfly_joystick_test>:
			}
		}
	}	
}

void butterfly_joystick_test(){
     5ce:	0f 93       	push	r16
     5d0:	1f 93       	push	r17
     5d2:	00 e3       	ldi	r16, 0x30	; 48
     5d4:	01 c0       	rjmp	.+2      	; 0x5d8 <butterfly_joystick_test+0xa>
     5d6:	01 2f       	mov	r16, r17
	char button = '0',last_button;

	while(1){
		last_button = button;
		
		button = butterfly_poll_joystick();
     5d8:	0e 94 8d 02 	call	0x51a	; 0x51a <butterfly_poll_joystick>
     5dc:	18 2f       	mov	r17, r24

		if(button != last_button){
     5de:	80 17       	cp	r24, r16
     5e0:	d1 f3       	breq	.-12     	; 0x5d6 <butterfly_joystick_test+0x8>
			switch(button) {
     5e2:	85 36       	cpi	r24, 0x65	; 101
     5e4:	c9 f0       	breq	.+50     	; 0x618 <butterfly_joystick_test+0x4a>
     5e6:	86 36       	cpi	r24, 0x66	; 102
     5e8:	28 f4       	brcc	.+10     	; 0x5f4 <butterfly_joystick_test+0x26>
     5ea:	80 33       	cpi	r24, 0x30	; 48
     5ec:	c1 f0       	breq	.+48     	; 0x61e <butterfly_joystick_test+0x50>
     5ee:	84 36       	cpi	r24, 0x64	; 100
     5f0:	c9 f4       	brne	.+50     	; 0x624 <butterfly_joystick_test+0x56>
     5f2:	0f c0       	rjmp	.+30     	; 0x612 <butterfly_joystick_test+0x44>
     5f4:	82 37       	cpi	r24, 0x72	; 114
     5f6:	39 f0       	breq	.+14     	; 0x606 <butterfly_joystick_test+0x38>
     5f8:	85 37       	cpi	r24, 0x75	; 117
     5fa:	41 f0       	breq	.+16     	; 0x60c <butterfly_joystick_test+0x3e>
     5fc:	8c 36       	cpi	r24, 0x6C	; 108
     5fe:	91 f4       	brne	.+36     	; 0x624 <butterfly_joystick_test+0x56>
				case 'l': butterfly_print("left");		break;
     600:	84 ee       	ldi	r24, 0xE4	; 228
     602:	91 e0       	ldi	r25, 0x01	; 1
     604:	11 c0       	rjmp	.+34     	; 0x628 <butterfly_joystick_test+0x5a>
				case 'r': butterfly_print("right");		break;
     606:	89 ee       	ldi	r24, 0xE9	; 233
     608:	91 e0       	ldi	r25, 0x01	; 1
     60a:	0e c0       	rjmp	.+28     	; 0x628 <butterfly_joystick_test+0x5a>
				case 'u': butterfly_print("up");		break;
     60c:	8f ee       	ldi	r24, 0xEF	; 239
     60e:	91 e0       	ldi	r25, 0x01	; 1
     610:	0b c0       	rjmp	.+22     	; 0x628 <butterfly_joystick_test+0x5a>
				case 'd': butterfly_print("down");		break;
     612:	82 ef       	ldi	r24, 0xF2	; 242
     614:	91 e0       	ldi	r25, 0x01	; 1
     616:	08 c0       	rjmp	.+16     	; 0x628 <butterfly_joystick_test+0x5a>
				case 'e': butterfly_print("enter");		break;
     618:	87 ef       	ldi	r24, 0xF7	; 247
     61a:	91 e0       	ldi	r25, 0x01	; 1
     61c:	05 c0       	rjmp	.+10     	; 0x628 <butterfly_joystick_test+0x5a>
				case '0': butterfly_print("center");	break;
     61e:	8d ef       	ldi	r24, 0xFD	; 253
     620:	91 e0       	ldi	r25, 0x01	; 1
     622:	02 c0       	rjmp	.+4      	; 0x628 <butterfly_joystick_test+0x5a>
				default:  butterfly_print("error");		break;
     624:	84 e0       	ldi	r24, 0x04	; 4
     626:	92 e0       	ldi	r25, 0x02	; 2
     628:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     62c:	d4 cf       	rjmp	.-88     	; 0x5d6 <butterfly_joystick_test+0x8>

0000062e <butterfly_menu>:

char butterfly_poll_joystick(void);

enum menu_state_enum {OVER_THE_TOP = -1, START_SP_POINTS, START_SP_ETERNAL, START_MP_POINTS, START_MP_ETERNAL, BELOW_THE_BOTTOM};

void butterfly_menu(){
     62e:	af 92       	push	r10
     630:	bf 92       	push	r11
     632:	cf 92       	push	r12
     634:	df 92       	push	r13
     636:	ff 92       	push	r15
     638:	0f 93       	push	r16
     63a:	1f 93       	push	r17
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
	enum menu_state_enum menu_state = OVER_THE_TOP;
	char button = '0',last_button;

	butterfly_print("Velkommen");
     640:	8a e0       	ldi	r24, 0x0A	; 10
     642:	92 e0       	ldi	r25, 0x02	; 2
     644:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     648:	1f ef       	ldi	r17, 0xFF	; 255
     64a:	20 e3       	ldi	r18, 0x30	; 48
     64c:	f2 2e       	mov	r15, r18
		last_button = button;
		
		button = butterfly_poll_joystick();

		if(button != last_button){
			printf("state for: %d\n", menu_state);
     64e:	94 e1       	ldi	r25, 0x14	; 20
     650:	a9 2e       	mov	r10, r25
     652:	92 e0       	ldi	r25, 0x02	; 2
     654:	b9 2e       	mov	r11, r25
				case 'd': menu_state++;				break;
				case 'e': start_game(menu_state);	break;
				case '0': 							continue;
				default:  butterfly_print("error");	break;
			}
			printf("state etter: %d\n", menu_state);
     656:	83 e2       	ldi	r24, 0x23	; 35
     658:	c8 2e       	mov	r12, r24
     65a:	82 e0       	ldi	r24, 0x02	; 2
     65c:	d8 2e       	mov	r13, r24
     65e:	02 c0       	rjmp	.+4      	; 0x664 <butterfly_menu+0x36>

void butterfly_menu(){
	enum menu_state_enum menu_state = OVER_THE_TOP;
	char button = '0',last_button;

	butterfly_print("Velkommen");
     660:	10 e0       	ldi	r17, 0x00	; 0
     662:	f0 2e       	mov	r15, r16

	while(1){
		last_button = button;
		
		button = butterfly_poll_joystick();
     664:	0e 94 8d 02 	call	0x51a	; 0x51a <butterfly_poll_joystick>
     668:	08 2f       	mov	r16, r24

		if(button != last_button){
     66a:	8f 15       	cp	r24, r15
     66c:	d1 f3       	breq	.-12     	; 0x662 <butterfly_menu+0x34>
			printf("state for: %d\n", menu_state);
     66e:	c1 2f       	mov	r28, r17
     670:	dd 27       	eor	r29, r29
     672:	c7 fd       	sbrc	r28, 7
     674:	d0 95       	com	r29
     676:	00 d0       	rcall	.+0      	; 0x678 <butterfly_menu+0x4a>
     678:	00 d0       	rcall	.+0      	; 0x67a <butterfly_menu+0x4c>
     67a:	ed b7       	in	r30, 0x3d	; 61
     67c:	fe b7       	in	r31, 0x3e	; 62
     67e:	b2 82       	std	Z+2, r11	; 0x02
     680:	a1 82       	std	Z+1, r10	; 0x01
     682:	d4 83       	std	Z+4, r29	; 0x04
     684:	c3 83       	std	Z+3, r28	; 0x03
     686:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>
			switch(button) {
     68a:	0f 90       	pop	r0
     68c:	0f 90       	pop	r0
     68e:	0f 90       	pop	r0
     690:	0f 90       	pop	r0
     692:	05 36       	cpi	r16, 0x65	; 101
     694:	91 f0       	breq	.+36     	; 0x6ba <butterfly_menu+0x8c>
     696:	06 36       	cpi	r16, 0x66	; 102
     698:	28 f4       	brcc	.+10     	; 0x6a4 <butterfly_menu+0x76>
     69a:	00 33       	cpi	r16, 0x30	; 48
     69c:	11 f3       	breq	.-60     	; 0x662 <butterfly_menu+0x34>
     69e:	04 36       	cpi	r16, 0x64	; 100
     6a0:	81 f4       	brne	.+32     	; 0x6c2 <butterfly_menu+0x94>
     6a2:	09 c0       	rjmp	.+18     	; 0x6b6 <butterfly_menu+0x88>
     6a4:	02 37       	cpi	r16, 0x72	; 114
     6a6:	e9 f2       	breq	.-70     	; 0x662 <butterfly_menu+0x34>
     6a8:	05 37       	cpi	r16, 0x75	; 117
     6aa:	19 f0       	breq	.+6      	; 0x6b2 <butterfly_menu+0x84>
     6ac:	0c 36       	cpi	r16, 0x6C	; 108
     6ae:	49 f4       	brne	.+18     	; 0x6c2 <butterfly_menu+0x94>
     6b0:	d8 cf       	rjmp	.-80     	; 0x662 <butterfly_menu+0x34>
				case 'l': 					
				case 'r': 							continue;
				case 'u': menu_state--;				break;
     6b2:	11 50       	subi	r17, 0x01	; 1
     6b4:	0a c0       	rjmp	.+20     	; 0x6ca <butterfly_menu+0x9c>
				case 'd': menu_state++;				break;
     6b6:	1f 5f       	subi	r17, 0xFF	; 255
     6b8:	08 c0       	rjmp	.+16     	; 0x6ca <butterfly_menu+0x9c>
				case 'e': start_game(menu_state);	break;
     6ba:	ce 01       	movw	r24, r28
     6bc:	0e 94 c4 02 	call	0x588	; 0x588 <start_game>
     6c0:	04 c0       	rjmp	.+8      	; 0x6ca <butterfly_menu+0x9c>
				case '0': 							continue;
				default:  butterfly_print("error");	break;
     6c2:	84 e0       	ldi	r24, 0x04	; 4
     6c4:	92 e0       	ldi	r25, 0x02	; 2
     6c6:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
			}
			printf("state etter: %d\n", menu_state);
     6ca:	00 d0       	rcall	.+0      	; 0x6cc <butterfly_menu+0x9e>
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <butterfly_menu+0xa0>
     6ce:	ed b7       	in	r30, 0x3d	; 61
     6d0:	fe b7       	in	r31, 0x3e	; 62
     6d2:	d2 82       	std	Z+2, r13	; 0x02
     6d4:	c1 82       	std	Z+1, r12	; 0x01
     6d6:	81 2f       	mov	r24, r17
     6d8:	99 27       	eor	r25, r25
     6da:	87 fd       	sbrc	r24, 7
     6dc:	90 95       	com	r25
     6de:	94 83       	std	Z+4, r25	; 0x04
     6e0:	83 83       	std	Z+3, r24	; 0x03
     6e2:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <printf>
			if (menu_state <= OVER_THE_TOP) menu_state = BELOW_THE_BOTTOM-1;
     6e6:	0f 90       	pop	r0
     6e8:	0f 90       	pop	r0
     6ea:	0f 90       	pop	r0
     6ec:	0f 90       	pop	r0
     6ee:	17 fd       	sbrc	r17, 7
     6f0:	1c c0       	rjmp	.+56     	; 0x72a <butterfly_menu+0xfc>
			if (menu_state >= BELOW_THE_BOTTOM) menu_state = OVER_THE_TOP+1;
     6f2:	14 30       	cpi	r17, 0x04	; 4
     6f4:	6c f4       	brge	.+26     	; 0x710 <butterfly_menu+0xe2>
			switch(menu_state) {
     6f6:	11 30       	cpi	r17, 0x01	; 1
     6f8:	81 f0       	breq	.+32     	; 0x71a <butterfly_menu+0xec>
     6fa:	12 30       	cpi	r17, 0x02	; 2
     6fc:	1c f4       	brge	.+6      	; 0x704 <butterfly_menu+0xd6>
     6fe:	11 23       	and	r17, r17
     700:	39 f0       	breq	.+14     	; 0x710 <butterfly_menu+0xe2>
     702:	ae cf       	rjmp	.-164    	; 0x660 <butterfly_menu+0x32>
     704:	12 30       	cpi	r17, 0x02	; 2
     706:	61 f0       	breq	.+24     	; 0x720 <butterfly_menu+0xf2>
     708:	13 30       	cpi	r17, 0x03	; 3
     70a:	09 f0       	breq	.+2      	; 0x70e <butterfly_menu+0xe0>
     70c:	a9 cf       	rjmp	.-174    	; 0x660 <butterfly_menu+0x32>
     70e:	0d c0       	rjmp	.+26     	; 0x72a <butterfly_menu+0xfc>
				case START_SP_POINTS: 	butterfly_print("1 Start enspiller poeng");		break;
     710:	84 e3       	ldi	r24, 0x34	; 52
     712:	92 e0       	ldi	r25, 0x02	; 2
     714:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     718:	a3 cf       	rjmp	.-186    	; 0x660 <butterfly_menu+0x32>
				case START_SP_ETERNAL: 	butterfly_print("2 Start enspiller evig");		break;
     71a:	8c e4       	ldi	r24, 0x4C	; 76
     71c:	92 e0       	ldi	r25, 0x02	; 2
     71e:	02 c0       	rjmp	.+4      	; 0x724 <butterfly_menu+0xf6>
				case START_MP_POINTS: 	butterfly_print("3 Start flersp poeng");		break;
     720:	83 e6       	ldi	r24, 0x63	; 99
     722:	92 e0       	ldi	r25, 0x02	; 2
     724:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     728:	9c cf       	rjmp	.-200    	; 0x662 <butterfly_menu+0x34>
				case START_MP_ETERNAL: 	butterfly_print("4 Start flersp evig");		break;
     72a:	88 e7       	ldi	r24, 0x78	; 120
     72c:	92 e0       	ldi	r25, 0x02	; 2
     72e:	0e 94 a2 02 	call	0x544	; 0x544 <butterfly_print>
     732:	13 e0       	ldi	r17, 0x03	; 3
     734:	96 cf       	rjmp	.-212    	; 0x662 <butterfly_menu+0x34>

00000736 <CAN_rx_status>:
}

uint8_t CAN_rx_status(void){
return 0;

}
     736:	80 e0       	ldi	r24, 0x00	; 0
     738:	08 95       	ret

0000073a <CAN_bit_modify>:
void CAN_bit_modify(uint8_t address, uint8_t mask, uint8_t data){
     73a:	ff 92       	push	r15
     73c:	0f 93       	push	r16
     73e:	1f 93       	push	r17
     740:	18 2f       	mov	r17, r24
     742:	06 2f       	mov	r16, r22
     744:	f4 2e       	mov	r15, r20
	SPI_SelectSlave(SPI_CAN);
     746:	83 e7       	ldi	r24, 0x73	; 115
     748:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>


	SPI_MasterTransmit((char)INS_BIT_MODIFY);	
     74c:	85 e0       	ldi	r24, 0x05	; 5
     74e:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     752:	81 2f       	mov	r24, r17
     754:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)mask);
     758:	80 2f       	mov	r24, r16
     75a:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)data);
     75e:	8f 2d       	mov	r24, r15
     760:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>

	SPI_NoSlave();
     764:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
}
     768:	1f 91       	pop	r17
     76a:	0f 91       	pop	r16
     76c:	ff 90       	pop	r15
     76e:	08 95       	ret

00000770 <CAN_rts>:

	SPI_NoSlave();
	printf("\n");
}

void CAN_rts(uint8_t tx){
     770:	1f 93       	push	r17
	if (tx == 0) tx = 1;
     772:	88 23       	and	r24, r24
     774:	11 f4       	brne	.+4      	; 0x77a <CAN_rts+0xa>
     776:	11 e0       	ldi	r17, 0x01	; 1
     778:	07 c0       	rjmp	.+14     	; 0x788 <CAN_rts+0x18>
	else if (tx == 1) tx = 2;
     77a:	81 30       	cpi	r24, 0x01	; 1
     77c:	11 f4       	brne	.+4      	; 0x782 <CAN_rts+0x12>
     77e:	12 e0       	ldi	r17, 0x02	; 2
     780:	03 c0       	rjmp	.+6      	; 0x788 <CAN_rts+0x18>
	else if (tx == 2) tx = 4;
     782:	82 30       	cpi	r24, 0x02	; 2
     784:	51 f4       	brne	.+20     	; 0x79a <CAN_rts+0x2a>
	else return;
     786:	14 e0       	ldi	r17, 0x04	; 4
	
	SPI_SelectSlave(SPI_CAN);
     788:	83 e7       	ldi	r24, 0x73	; 115
     78a:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
	//printf("Rts: 0x%x\n", (INS_RTS | tx));
	SPI_MasterTransmit(INS_RTS | tx);
     78e:	81 2f       	mov	r24, r17
     790:	80 68       	ori	r24, 0x80	; 128
     792:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>

	SPI_NoSlave();
     796:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
}
     79a:	1f 91       	pop	r17
     79c:	08 95       	ret

0000079e <CAN_write>:
	}
	
	SPI_NoSlave();
}

void CAN_write(char data, uint8_t address){
     79e:	0f 93       	push	r16
     7a0:	1f 93       	push	r17
     7a2:	08 2f       	mov	r16, r24
     7a4:	16 2f       	mov	r17, r22
	int i;
	SPI_SelectSlave(SPI_CAN);	
     7a6:	83 e7       	ldi	r24, 0x73	; 115
     7a8:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_WRITE);
     7ac:	82 e0       	ldi	r24, 0x02	; 2
     7ae:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     7b2:	81 2f       	mov	r24, r17
     7b4:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
		SPI_MasterTransmit(data);
     7b8:	80 2f       	mov	r24, r16
     7ba:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>

	SPI_NoSlave();
     7be:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>

}
     7c2:	1f 91       	pop	r17
     7c4:	0f 91       	pop	r16
     7c6:	08 95       	ret

000007c8 <CAN_reset>:
#include "mcp2515.h"
#include "spi.h"

// Reset the CAN chip
void CAN_reset(void){
	SPI_SelectSlave(SPI_CAN);
     7c8:	83 e7       	ldi	r24, 0x73	; 115
     7ca:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
	SPI_MasterTransmit(INS_RESET);
     7ce:	80 ec       	ldi	r24, 0xC0	; 192
     7d0:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_NoSlave();
     7d4:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
}
     7d8:	08 95       	ret

000007da <CAN_read_status>:
	SPI_MasterTransmit(INS_RTS | tx);

	SPI_NoSlave();
}

uint8_t CAN_read_status(void){
     7da:	1f 93       	push	r17
	char status;
	SPI_SelectSlave(SPI_CAN);
     7dc:	83 e7       	ldi	r24, 0x73	; 115
     7de:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_READ_STATUS);
     7e2:	80 ea       	ldi	r24, 0xA0	; 160
     7e4:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	status = SPI_MasterReceive();
     7e8:	0e 94 3d 01 	call	0x27a	; 0x27a <SPI_MasterReceive>
     7ec:	18 2f       	mov	r17, r24

	SPI_NoSlave();
     7ee:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
	
	return (uint8_t) status;

}
     7f2:	81 2f       	mov	r24, r17
     7f4:	1f 91       	pop	r17
     7f6:	08 95       	ret

000007f8 <CAN_read_rx>:

	SPI_NoSlave();

}

void CAN_read_rx(CAN_message* msg, uint8_t rx){
     7f8:	ef 92       	push	r14
     7fa:	ff 92       	push	r15
     7fc:	0f 93       	push	r16
     7fe:	1f 93       	push	r17
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	7c 01       	movw	r14, r24
	int i;
	if (rx>1)
     806:	62 30       	cpi	r22, 0x02	; 2
     808:	f0 f4       	brcc	.+60     	; 0x846 <CAN_read_rx+0x4e>
		return;
	if(rx == 0) rx = 1; //decode rx0 to word for "read from rxb0", standard frame
     80a:	66 23       	and	r22, r22
     80c:	11 f4       	brne	.+4      	; 0x812 <CAN_read_rx+0x1a>
     80e:	01 e0       	ldi	r16, 0x01	; 1
     810:	01 c0       	rjmp	.+2      	; 0x814 <CAN_read_rx+0x1c>
     812:	03 e0       	ldi	r16, 0x03	; 3
	else if(rx == 1) rx = 3; //decode rx1 to intruction for "read from rxb1", standard frame
	
	SPI_SelectSlave(SPI_CAN);	
     814:	83 e7       	ldi	r24, 0x73	; 115
     816:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
	SPI_MasterTransmit(INS_READ_RX | (rx<<1));
     81a:	00 0f       	add	r16, r16
     81c:	80 2f       	mov	r24, r16
     81e:	80 69       	ori	r24, 0x90	; 144
     820:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
     824:	c0 e0       	ldi	r28, 0x00	; 0
     826:	d0 e0       	ldi	r29, 0x00	; 0
	for (i = 0; i < 8; i++){
		msg->data[i] = SPI_MasterReceive();
     828:	f7 01       	movw	r30, r14
     82a:	03 81       	ldd	r16, Z+3	; 0x03
     82c:	14 81       	ldd	r17, Z+4	; 0x04
     82e:	0c 0f       	add	r16, r28
     830:	1d 1f       	adc	r17, r29
     832:	0e 94 3d 01 	call	0x27a	; 0x27a <SPI_MasterReceive>
     836:	f8 01       	movw	r30, r16
     838:	80 83       	st	Z, r24
	if(rx == 0) rx = 1; //decode rx0 to word for "read from rxb0", standard frame
	else if(rx == 1) rx = 3; //decode rx1 to intruction for "read from rxb1", standard frame
	
	SPI_SelectSlave(SPI_CAN);	
	SPI_MasterTransmit(INS_READ_RX | (rx<<1));
	for (i = 0; i < 8; i++){
     83a:	21 96       	adiw	r28, 0x01	; 1
     83c:	c8 30       	cpi	r28, 0x08	; 8
     83e:	d1 05       	cpc	r29, r1
     840:	99 f7       	brne	.-26     	; 0x828 <CAN_read_rx+0x30>
		msg->data[i] = SPI_MasterReceive();
	}
	
	SPI_NoSlave();
     842:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
}
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	ff 90       	pop	r15
     850:	ef 90       	pop	r14
     852:	08 95       	ret

00000854 <CAN_read>:
	SPI_MasterTransmit(INS_RESET);
	SPI_NoSlave();
}

// Read
void CAN_read(char* data, uint8_t address , int data_count){
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	1f 93       	push	r17
     85e:	cf 93       	push	r28
     860:	df 93       	push	r29
     862:	6c 01       	movw	r12, r24
     864:	16 2f       	mov	r17, r22
     866:	7a 01       	movw	r14, r20
	int i;
	SPI_SelectSlave(SPI_CAN);	
     868:	83 e7       	ldi	r24, 0x73	; 115
     86a:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>

	SPI_MasterTransmit(INS_READ);
     86e:	83 e0       	ldi	r24, 0x03	; 3
     870:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
	SPI_MasterTransmit((char)address);
     874:	81 2f       	mov	r24, r17
     876:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
     87a:	c0 e0       	ldi	r28, 0x00	; 0
     87c:	d0 e0       	ldi	r29, 0x00	; 0
     87e:	07 c0       	rjmp	.+14     	; 0x88e <CAN_read+0x3a>
	for(i = 0; i < data_count; i++){
		data[i] = SPI_MasterReceive();
     880:	0e 94 3d 01 	call	0x27a	; 0x27a <SPI_MasterReceive>
     884:	f6 01       	movw	r30, r12
     886:	ec 0f       	add	r30, r28
     888:	fd 1f       	adc	r31, r29
     88a:	80 83       	st	Z, r24
	int i;
	SPI_SelectSlave(SPI_CAN);	

	SPI_MasterTransmit(INS_READ);
	SPI_MasterTransmit((char)address);
	for(i = 0; i < data_count; i++){
     88c:	21 96       	adiw	r28, 0x01	; 1
     88e:	ce 15       	cp	r28, r14
     890:	df 05       	cpc	r29, r15
     892:	b4 f3       	brlt	.-20     	; 0x880 <CAN_read+0x2c>
		data[i] = SPI_MasterReceive();
	}

	SPI_NoSlave();
     894:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>

}
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	1f 91       	pop	r17
     89e:	ff 90       	pop	r15
     8a0:	ef 90       	pop	r14
     8a2:	df 90       	pop	r13
     8a4:	cf 90       	pop	r12
     8a6:	08 95       	ret

000008a8 <CAN_load_tx>:

	SPI_NoSlave();

}
//tx = "modul" (3 output "kanaler")
void CAN_load_tx(CAN_message* msg, uint8_t tx){
     8a8:	ef 92       	push	r14
     8aa:	ff 92       	push	r15
     8ac:	1f 93       	push	r17
     8ae:	cf 93       	push	r28
     8b0:	df 93       	push	r29
     8b2:	7c 01       	movw	r14, r24
	int i;
	if (tx>2 || msg->length > 8)
     8b4:	63 30       	cpi	r22, 0x03	; 3
     8b6:	50 f5       	brcc	.+84     	; 0x90c <CAN_load_tx+0x64>
     8b8:	dc 01       	movw	r26, r24
     8ba:	12 96       	adiw	r26, 0x02	; 2
     8bc:	8c 91       	ld	r24, X
     8be:	89 30       	cpi	r24, 0x09	; 9
     8c0:	28 f5       	brcc	.+74     	; 0x90c <CAN_load_tx+0x64>
		return;
	tx = (tx+1)*2 - 1; //convert to abc-format as explained in table 12-5
     8c2:	16 2f       	mov	r17, r22
     8c4:	11 0f       	add	r17, r17
     8c6:	1e 5f       	subi	r17, 0xFE	; 254
	SPI_SelectSlave(SPI_CAN);
     8c8:	83 e7       	ldi	r24, 0x73	; 115
     8ca:	0e 94 45 01 	call	0x28a	; 0x28a <SPI_SelectSlave>
	
	SPI_MasterTransmit(INS_LOAD_TX | tx);
     8ce:	11 50       	subi	r17, 0x01	; 1
     8d0:	81 2f       	mov	r24, r17
     8d2:	80 64       	ori	r24, 0x40	; 64
     8d4:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
     8d8:	c0 e0       	ldi	r28, 0x00	; 0
     8da:	d0 e0       	ldi	r29, 0x00	; 0
     8dc:	0b c0       	rjmp	.+22     	; 0x8f4 <CAN_load_tx+0x4c>
	for(i = 0; i < msg->length; i++){
		//printf("%c", data[i]);
		SPI_MasterTransmit(msg->data[i]);
     8de:	d7 01       	movw	r26, r14
     8e0:	13 96       	adiw	r26, 0x03	; 3
     8e2:	ed 91       	ld	r30, X+
     8e4:	fc 91       	ld	r31, X
     8e6:	14 97       	sbiw	r26, 0x04	; 4
     8e8:	ec 0f       	add	r30, r28
     8ea:	fd 1f       	adc	r31, r29
     8ec:	80 81       	ld	r24, Z
     8ee:	0e 94 39 01 	call	0x272	; 0x272 <SPI_MasterTransmit>
		return;
	tx = (tx+1)*2 - 1; //convert to abc-format as explained in table 12-5
	SPI_SelectSlave(SPI_CAN);
	
	SPI_MasterTransmit(INS_LOAD_TX | tx);
	for(i = 0; i < msg->length; i++){
     8f2:	21 96       	adiw	r28, 0x01	; 1
     8f4:	f7 01       	movw	r30, r14
     8f6:	82 81       	ldd	r24, Z+2	; 0x02
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	c8 17       	cp	r28, r24
     8fc:	d9 07       	cpc	r29, r25
     8fe:	7c f3       	brlt	.-34     	; 0x8de <CAN_load_tx+0x36>
		//printf("%c", data[i]);
		SPI_MasterTransmit(msg->data[i]);
	}

	SPI_NoSlave();
     900:	0e 94 4d 01 	call	0x29a	; 0x29a <SPI_NoSlave>
	printf("\n");
     904:	8a e0       	ldi	r24, 0x0A	; 10
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	0e 94 ed 04 	call	0x9da	; 0x9da <putchar>
}
     90c:	df 91       	pop	r29
     90e:	cf 91       	pop	r28
     910:	1f 91       	pop	r17
     912:	ff 90       	pop	r15
     914:	ef 90       	pop	r14
     916:	08 95       	ret

00000918 <fdevopen>:
     918:	0f 93       	push	r16
     91a:	1f 93       	push	r17
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	8c 01       	movw	r16, r24
     922:	eb 01       	movw	r28, r22
     924:	00 97       	sbiw	r24, 0x00	; 0
     926:	31 f4       	brne	.+12     	; 0x934 <fdevopen+0x1c>
     928:	61 15       	cp	r22, r1
     92a:	71 05       	cpc	r23, r1
     92c:	19 f4       	brne	.+6      	; 0x934 <fdevopen+0x1c>
     92e:	20 e0       	ldi	r18, 0x00	; 0
     930:	30 e0       	ldi	r19, 0x00	; 0
     932:	38 c0       	rjmp	.+112    	; 0x9a4 <fdevopen+0x8c>
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	6e e0       	ldi	r22, 0x0E	; 14
     93a:	70 e0       	ldi	r23, 0x00	; 0
     93c:	0e 94 06 07 	call	0xe0c	; 0xe0c <calloc>
     940:	fc 01       	movw	r30, r24
     942:	9c 01       	movw	r18, r24
     944:	00 97       	sbiw	r24, 0x00	; 0
     946:	71 f1       	breq	.+92     	; 0x9a4 <fdevopen+0x8c>
     948:	80 e8       	ldi	r24, 0x80	; 128
     94a:	83 83       	std	Z+3, r24	; 0x03
     94c:	20 97       	sbiw	r28, 0x00	; 0
     94e:	71 f0       	breq	.+28     	; 0x96c <fdevopen+0x54>
     950:	d3 87       	std	Z+11, r29	; 0x0b
     952:	c2 87       	std	Z+10, r28	; 0x0a
     954:	81 e8       	ldi	r24, 0x81	; 129
     956:	83 83       	std	Z+3, r24	; 0x03
     958:	80 91 92 02 	lds	r24, 0x0292
     95c:	90 91 93 02 	lds	r25, 0x0293
     960:	89 2b       	or	r24, r25
     962:	21 f4       	brne	.+8      	; 0x96c <fdevopen+0x54>
     964:	f0 93 93 02 	sts	0x0293, r31
     968:	e0 93 92 02 	sts	0x0292, r30
     96c:	01 15       	cp	r16, r1
     96e:	11 05       	cpc	r17, r1
     970:	c9 f0       	breq	.+50     	; 0x9a4 <fdevopen+0x8c>
     972:	11 87       	std	Z+9, r17	; 0x09
     974:	00 87       	std	Z+8, r16	; 0x08
     976:	83 81       	ldd	r24, Z+3	; 0x03
     978:	82 60       	ori	r24, 0x02	; 2
     97a:	83 83       	std	Z+3, r24	; 0x03
     97c:	80 91 94 02 	lds	r24, 0x0294
     980:	90 91 95 02 	lds	r25, 0x0295
     984:	89 2b       	or	r24, r25
     986:	71 f4       	brne	.+28     	; 0x9a4 <fdevopen+0x8c>
     988:	f0 93 95 02 	sts	0x0295, r31
     98c:	e0 93 94 02 	sts	0x0294, r30
     990:	80 91 96 02 	lds	r24, 0x0296
     994:	90 91 97 02 	lds	r25, 0x0297
     998:	89 2b       	or	r24, r25
     99a:	21 f4       	brne	.+8      	; 0x9a4 <fdevopen+0x8c>
     99c:	f0 93 97 02 	sts	0x0297, r31
     9a0:	e0 93 96 02 	sts	0x0296, r30
     9a4:	c9 01       	movw	r24, r18
     9a6:	df 91       	pop	r29
     9a8:	cf 91       	pop	r28
     9aa:	1f 91       	pop	r17
     9ac:	0f 91       	pop	r16
     9ae:	08 95       	ret

000009b0 <printf>:
     9b0:	a0 e0       	ldi	r26, 0x00	; 0
     9b2:	b0 e0       	ldi	r27, 0x00	; 0
     9b4:	ee ed       	ldi	r30, 0xDE	; 222
     9b6:	f4 e0       	ldi	r31, 0x04	; 4
     9b8:	0c 94 00 09 	jmp	0x1200	; 0x1200 <__prologue_saves__+0x20>
     9bc:	fe 01       	movw	r30, r28
     9be:	35 96       	adiw	r30, 0x05	; 5
     9c0:	61 91       	ld	r22, Z+
     9c2:	71 91       	ld	r23, Z+
     9c4:	80 91 94 02 	lds	r24, 0x0294
     9c8:	90 91 95 02 	lds	r25, 0x0295
     9cc:	af 01       	movw	r20, r30
     9ce:	0e 94 29 05 	call	0xa52	; 0xa52 <vfprintf>
     9d2:	20 96       	adiw	r28, 0x00	; 0
     9d4:	e2 e0       	ldi	r30, 0x02	; 2
     9d6:	0c 94 1c 09 	jmp	0x1238	; 0x1238 <__epilogue_restores__+0x20>

000009da <putchar>:
     9da:	60 91 94 02 	lds	r22, 0x0294
     9de:	70 91 95 02 	lds	r23, 0x0295
     9e2:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     9e6:	08 95       	ret

000009e8 <puts>:
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	8c 01       	movw	r16, r24
     9f2:	e0 91 94 02 	lds	r30, 0x0294
     9f6:	f0 91 95 02 	lds	r31, 0x0295
     9fa:	83 81       	ldd	r24, Z+3	; 0x03
     9fc:	81 ff       	sbrs	r24, 1
     9fe:	21 c0       	rjmp	.+66     	; 0xa42 <puts+0x5a>
     a00:	c0 e0       	ldi	r28, 0x00	; 0
     a02:	d0 e0       	ldi	r29, 0x00	; 0
     a04:	0d c0       	rjmp	.+26     	; 0xa20 <puts+0x38>
     a06:	e0 91 94 02 	lds	r30, 0x0294
     a0a:	f0 91 95 02 	lds	r31, 0x0295
     a0e:	20 85       	ldd	r18, Z+8	; 0x08
     a10:	31 85       	ldd	r19, Z+9	; 0x09
     a12:	bf 01       	movw	r22, r30
     a14:	f9 01       	movw	r30, r18
     a16:	09 95       	icall
     a18:	89 2b       	or	r24, r25
     a1a:	11 f0       	breq	.+4      	; 0xa20 <puts+0x38>
     a1c:	cf ef       	ldi	r28, 0xFF	; 255
     a1e:	df ef       	ldi	r29, 0xFF	; 255
     a20:	f8 01       	movw	r30, r16
     a22:	81 91       	ld	r24, Z+
     a24:	8f 01       	movw	r16, r30
     a26:	88 23       	and	r24, r24
     a28:	71 f7       	brne	.-36     	; 0xa06 <puts+0x1e>
     a2a:	e0 91 94 02 	lds	r30, 0x0294
     a2e:	f0 91 95 02 	lds	r31, 0x0295
     a32:	20 85       	ldd	r18, Z+8	; 0x08
     a34:	31 85       	ldd	r19, Z+9	; 0x09
     a36:	8a e0       	ldi	r24, 0x0A	; 10
     a38:	bf 01       	movw	r22, r30
     a3a:	f9 01       	movw	r30, r18
     a3c:	09 95       	icall
     a3e:	89 2b       	or	r24, r25
     a40:	11 f0       	breq	.+4      	; 0xa46 <puts+0x5e>
     a42:	cf ef       	ldi	r28, 0xFF	; 255
     a44:	df ef       	ldi	r29, 0xFF	; 255
     a46:	ce 01       	movw	r24, r28
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <vfprintf>:
     a52:	ab e0       	ldi	r26, 0x0B	; 11
     a54:	b0 e0       	ldi	r27, 0x00	; 0
     a56:	ef e2       	ldi	r30, 0x2F	; 47
     a58:	f5 e0       	ldi	r31, 0x05	; 5
     a5a:	0c 94 f0 08 	jmp	0x11e0	; 0x11e0 <__prologue_saves__>
     a5e:	3c 01       	movw	r6, r24
     a60:	2b 01       	movw	r4, r22
     a62:	5a 01       	movw	r10, r20
     a64:	fc 01       	movw	r30, r24
     a66:	17 82       	std	Z+7, r1	; 0x07
     a68:	16 82       	std	Z+6, r1	; 0x06
     a6a:	83 81       	ldd	r24, Z+3	; 0x03
     a6c:	81 fd       	sbrc	r24, 1
     a6e:	03 c0       	rjmp	.+6      	; 0xa76 <vfprintf+0x24>
     a70:	6f ef       	ldi	r22, 0xFF	; 255
     a72:	7f ef       	ldi	r23, 0xFF	; 255
     a74:	c6 c1       	rjmp	.+908    	; 0xe02 <vfprintf+0x3b0>
     a76:	9a e0       	ldi	r25, 0x0A	; 10
     a78:	89 2e       	mov	r8, r25
     a7a:	1e 01       	movw	r2, r28
     a7c:	08 94       	sec
     a7e:	21 1c       	adc	r2, r1
     a80:	31 1c       	adc	r3, r1
     a82:	f3 01       	movw	r30, r6
     a84:	23 81       	ldd	r18, Z+3	; 0x03
     a86:	f2 01       	movw	r30, r4
     a88:	23 fd       	sbrc	r18, 3
     a8a:	85 91       	lpm	r24, Z+
     a8c:	23 ff       	sbrs	r18, 3
     a8e:	81 91       	ld	r24, Z+
     a90:	2f 01       	movw	r4, r30
     a92:	88 23       	and	r24, r24
     a94:	09 f4       	brne	.+2      	; 0xa98 <vfprintf+0x46>
     a96:	b2 c1       	rjmp	.+868    	; 0xdfc <vfprintf+0x3aa>
     a98:	85 32       	cpi	r24, 0x25	; 37
     a9a:	39 f4       	brne	.+14     	; 0xaaa <vfprintf+0x58>
     a9c:	23 fd       	sbrc	r18, 3
     a9e:	85 91       	lpm	r24, Z+
     aa0:	23 ff       	sbrs	r18, 3
     aa2:	81 91       	ld	r24, Z+
     aa4:	2f 01       	movw	r4, r30
     aa6:	85 32       	cpi	r24, 0x25	; 37
     aa8:	29 f4       	brne	.+10     	; 0xab4 <vfprintf+0x62>
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	b3 01       	movw	r22, r6
     aae:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     ab2:	e7 cf       	rjmp	.-50     	; 0xa82 <vfprintf+0x30>
     ab4:	98 2f       	mov	r25, r24
     ab6:	ff 24       	eor	r15, r15
     ab8:	ee 24       	eor	r14, r14
     aba:	99 24       	eor	r9, r9
     abc:	ff e1       	ldi	r31, 0x1F	; 31
     abe:	ff 15       	cp	r31, r15
     ac0:	d0 f0       	brcs	.+52     	; 0xaf6 <vfprintf+0xa4>
     ac2:	9b 32       	cpi	r25, 0x2B	; 43
     ac4:	69 f0       	breq	.+26     	; 0xae0 <vfprintf+0x8e>
     ac6:	9c 32       	cpi	r25, 0x2C	; 44
     ac8:	28 f4       	brcc	.+10     	; 0xad4 <vfprintf+0x82>
     aca:	90 32       	cpi	r25, 0x20	; 32
     acc:	59 f0       	breq	.+22     	; 0xae4 <vfprintf+0x92>
     ace:	93 32       	cpi	r25, 0x23	; 35
     ad0:	91 f4       	brne	.+36     	; 0xaf6 <vfprintf+0xa4>
     ad2:	0e c0       	rjmp	.+28     	; 0xaf0 <vfprintf+0x9e>
     ad4:	9d 32       	cpi	r25, 0x2D	; 45
     ad6:	49 f0       	breq	.+18     	; 0xaea <vfprintf+0x98>
     ad8:	90 33       	cpi	r25, 0x30	; 48
     ada:	69 f4       	brne	.+26     	; 0xaf6 <vfprintf+0xa4>
     adc:	41 e0       	ldi	r20, 0x01	; 1
     ade:	24 c0       	rjmp	.+72     	; 0xb28 <vfprintf+0xd6>
     ae0:	52 e0       	ldi	r21, 0x02	; 2
     ae2:	f5 2a       	or	r15, r21
     ae4:	84 e0       	ldi	r24, 0x04	; 4
     ae6:	f8 2a       	or	r15, r24
     ae8:	28 c0       	rjmp	.+80     	; 0xb3a <vfprintf+0xe8>
     aea:	98 e0       	ldi	r25, 0x08	; 8
     aec:	f9 2a       	or	r15, r25
     aee:	25 c0       	rjmp	.+74     	; 0xb3a <vfprintf+0xe8>
     af0:	e0 e1       	ldi	r30, 0x10	; 16
     af2:	fe 2a       	or	r15, r30
     af4:	22 c0       	rjmp	.+68     	; 0xb3a <vfprintf+0xe8>
     af6:	f7 fc       	sbrc	r15, 7
     af8:	29 c0       	rjmp	.+82     	; 0xb4c <vfprintf+0xfa>
     afa:	89 2f       	mov	r24, r25
     afc:	80 53       	subi	r24, 0x30	; 48
     afe:	8a 30       	cpi	r24, 0x0A	; 10
     b00:	70 f4       	brcc	.+28     	; 0xb1e <vfprintf+0xcc>
     b02:	f6 fe       	sbrs	r15, 6
     b04:	05 c0       	rjmp	.+10     	; 0xb10 <vfprintf+0xbe>
     b06:	98 9c       	mul	r9, r8
     b08:	90 2c       	mov	r9, r0
     b0a:	11 24       	eor	r1, r1
     b0c:	98 0e       	add	r9, r24
     b0e:	15 c0       	rjmp	.+42     	; 0xb3a <vfprintf+0xe8>
     b10:	e8 9c       	mul	r14, r8
     b12:	e0 2c       	mov	r14, r0
     b14:	11 24       	eor	r1, r1
     b16:	e8 0e       	add	r14, r24
     b18:	f0 e2       	ldi	r31, 0x20	; 32
     b1a:	ff 2a       	or	r15, r31
     b1c:	0e c0       	rjmp	.+28     	; 0xb3a <vfprintf+0xe8>
     b1e:	9e 32       	cpi	r25, 0x2E	; 46
     b20:	29 f4       	brne	.+10     	; 0xb2c <vfprintf+0xda>
     b22:	f6 fc       	sbrc	r15, 6
     b24:	6b c1       	rjmp	.+726    	; 0xdfc <vfprintf+0x3aa>
     b26:	40 e4       	ldi	r20, 0x40	; 64
     b28:	f4 2a       	or	r15, r20
     b2a:	07 c0       	rjmp	.+14     	; 0xb3a <vfprintf+0xe8>
     b2c:	9c 36       	cpi	r25, 0x6C	; 108
     b2e:	19 f4       	brne	.+6      	; 0xb36 <vfprintf+0xe4>
     b30:	50 e8       	ldi	r21, 0x80	; 128
     b32:	f5 2a       	or	r15, r21
     b34:	02 c0       	rjmp	.+4      	; 0xb3a <vfprintf+0xe8>
     b36:	98 36       	cpi	r25, 0x68	; 104
     b38:	49 f4       	brne	.+18     	; 0xb4c <vfprintf+0xfa>
     b3a:	f2 01       	movw	r30, r4
     b3c:	23 fd       	sbrc	r18, 3
     b3e:	95 91       	lpm	r25, Z+
     b40:	23 ff       	sbrs	r18, 3
     b42:	91 91       	ld	r25, Z+
     b44:	2f 01       	movw	r4, r30
     b46:	99 23       	and	r25, r25
     b48:	09 f0       	breq	.+2      	; 0xb4c <vfprintf+0xfa>
     b4a:	b8 cf       	rjmp	.-144    	; 0xabc <vfprintf+0x6a>
     b4c:	89 2f       	mov	r24, r25
     b4e:	85 54       	subi	r24, 0x45	; 69
     b50:	83 30       	cpi	r24, 0x03	; 3
     b52:	18 f0       	brcs	.+6      	; 0xb5a <vfprintf+0x108>
     b54:	80 52       	subi	r24, 0x20	; 32
     b56:	83 30       	cpi	r24, 0x03	; 3
     b58:	38 f4       	brcc	.+14     	; 0xb68 <vfprintf+0x116>
     b5a:	44 e0       	ldi	r20, 0x04	; 4
     b5c:	50 e0       	ldi	r21, 0x00	; 0
     b5e:	a4 0e       	add	r10, r20
     b60:	b5 1e       	adc	r11, r21
     b62:	5f e3       	ldi	r21, 0x3F	; 63
     b64:	59 83       	std	Y+1, r21	; 0x01
     b66:	0f c0       	rjmp	.+30     	; 0xb86 <vfprintf+0x134>
     b68:	93 36       	cpi	r25, 0x63	; 99
     b6a:	31 f0       	breq	.+12     	; 0xb78 <vfprintf+0x126>
     b6c:	93 37       	cpi	r25, 0x73	; 115
     b6e:	79 f0       	breq	.+30     	; 0xb8e <vfprintf+0x13c>
     b70:	93 35       	cpi	r25, 0x53	; 83
     b72:	09 f0       	breq	.+2      	; 0xb76 <vfprintf+0x124>
     b74:	56 c0       	rjmp	.+172    	; 0xc22 <vfprintf+0x1d0>
     b76:	20 c0       	rjmp	.+64     	; 0xbb8 <vfprintf+0x166>
     b78:	f5 01       	movw	r30, r10
     b7a:	80 81       	ld	r24, Z
     b7c:	89 83       	std	Y+1, r24	; 0x01
     b7e:	42 e0       	ldi	r20, 0x02	; 2
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	a4 0e       	add	r10, r20
     b84:	b5 1e       	adc	r11, r21
     b86:	61 01       	movw	r12, r2
     b88:	01 e0       	ldi	r16, 0x01	; 1
     b8a:	10 e0       	ldi	r17, 0x00	; 0
     b8c:	12 c0       	rjmp	.+36     	; 0xbb2 <vfprintf+0x160>
     b8e:	f5 01       	movw	r30, r10
     b90:	c0 80       	ld	r12, Z
     b92:	d1 80       	ldd	r13, Z+1	; 0x01
     b94:	f6 fc       	sbrc	r15, 6
     b96:	03 c0       	rjmp	.+6      	; 0xb9e <vfprintf+0x14c>
     b98:	6f ef       	ldi	r22, 0xFF	; 255
     b9a:	7f ef       	ldi	r23, 0xFF	; 255
     b9c:	02 c0       	rjmp	.+4      	; 0xba2 <vfprintf+0x150>
     b9e:	69 2d       	mov	r22, r9
     ba0:	70 e0       	ldi	r23, 0x00	; 0
     ba2:	42 e0       	ldi	r20, 0x02	; 2
     ba4:	50 e0       	ldi	r21, 0x00	; 0
     ba6:	a4 0e       	add	r10, r20
     ba8:	b5 1e       	adc	r11, r21
     baa:	c6 01       	movw	r24, r12
     bac:	0e 94 39 08 	call	0x1072	; 0x1072 <strnlen>
     bb0:	8c 01       	movw	r16, r24
     bb2:	5f e7       	ldi	r21, 0x7F	; 127
     bb4:	f5 22       	and	r15, r21
     bb6:	14 c0       	rjmp	.+40     	; 0xbe0 <vfprintf+0x18e>
     bb8:	f5 01       	movw	r30, r10
     bba:	c0 80       	ld	r12, Z
     bbc:	d1 80       	ldd	r13, Z+1	; 0x01
     bbe:	f6 fc       	sbrc	r15, 6
     bc0:	03 c0       	rjmp	.+6      	; 0xbc8 <vfprintf+0x176>
     bc2:	6f ef       	ldi	r22, 0xFF	; 255
     bc4:	7f ef       	ldi	r23, 0xFF	; 255
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <vfprintf+0x17a>
     bc8:	69 2d       	mov	r22, r9
     bca:	70 e0       	ldi	r23, 0x00	; 0
     bcc:	42 e0       	ldi	r20, 0x02	; 2
     bce:	50 e0       	ldi	r21, 0x00	; 0
     bd0:	a4 0e       	add	r10, r20
     bd2:	b5 1e       	adc	r11, r21
     bd4:	c6 01       	movw	r24, r12
     bd6:	0e 94 27 08 	call	0x104e	; 0x104e <strnlen_P>
     bda:	8c 01       	movw	r16, r24
     bdc:	50 e8       	ldi	r21, 0x80	; 128
     bde:	f5 2a       	or	r15, r21
     be0:	f3 fe       	sbrs	r15, 3
     be2:	07 c0       	rjmp	.+14     	; 0xbf2 <vfprintf+0x1a0>
     be4:	1a c0       	rjmp	.+52     	; 0xc1a <vfprintf+0x1c8>
     be6:	80 e2       	ldi	r24, 0x20	; 32
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	b3 01       	movw	r22, r6
     bec:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     bf0:	ea 94       	dec	r14
     bf2:	8e 2d       	mov	r24, r14
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	08 17       	cp	r16, r24
     bf8:	19 07       	cpc	r17, r25
     bfa:	a8 f3       	brcs	.-22     	; 0xbe6 <vfprintf+0x194>
     bfc:	0e c0       	rjmp	.+28     	; 0xc1a <vfprintf+0x1c8>
     bfe:	f6 01       	movw	r30, r12
     c00:	f7 fc       	sbrc	r15, 7
     c02:	85 91       	lpm	r24, Z+
     c04:	f7 fe       	sbrs	r15, 7
     c06:	81 91       	ld	r24, Z+
     c08:	6f 01       	movw	r12, r30
     c0a:	90 e0       	ldi	r25, 0x00	; 0
     c0c:	b3 01       	movw	r22, r6
     c0e:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     c12:	e1 10       	cpse	r14, r1
     c14:	ea 94       	dec	r14
     c16:	01 50       	subi	r16, 0x01	; 1
     c18:	10 40       	sbci	r17, 0x00	; 0
     c1a:	01 15       	cp	r16, r1
     c1c:	11 05       	cpc	r17, r1
     c1e:	79 f7       	brne	.-34     	; 0xbfe <vfprintf+0x1ac>
     c20:	ea c0       	rjmp	.+468    	; 0xdf6 <vfprintf+0x3a4>
     c22:	94 36       	cpi	r25, 0x64	; 100
     c24:	11 f0       	breq	.+4      	; 0xc2a <vfprintf+0x1d8>
     c26:	99 36       	cpi	r25, 0x69	; 105
     c28:	69 f5       	brne	.+90     	; 0xc84 <vfprintf+0x232>
     c2a:	f7 fe       	sbrs	r15, 7
     c2c:	08 c0       	rjmp	.+16     	; 0xc3e <vfprintf+0x1ec>
     c2e:	f5 01       	movw	r30, r10
     c30:	20 81       	ld	r18, Z
     c32:	31 81       	ldd	r19, Z+1	; 0x01
     c34:	42 81       	ldd	r20, Z+2	; 0x02
     c36:	53 81       	ldd	r21, Z+3	; 0x03
     c38:	84 e0       	ldi	r24, 0x04	; 4
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	0a c0       	rjmp	.+20     	; 0xc52 <vfprintf+0x200>
     c3e:	f5 01       	movw	r30, r10
     c40:	80 81       	ld	r24, Z
     c42:	91 81       	ldd	r25, Z+1	; 0x01
     c44:	9c 01       	movw	r18, r24
     c46:	44 27       	eor	r20, r20
     c48:	37 fd       	sbrc	r19, 7
     c4a:	40 95       	com	r20
     c4c:	54 2f       	mov	r21, r20
     c4e:	82 e0       	ldi	r24, 0x02	; 2
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	a8 0e       	add	r10, r24
     c54:	b9 1e       	adc	r11, r25
     c56:	9f e6       	ldi	r25, 0x6F	; 111
     c58:	f9 22       	and	r15, r25
     c5a:	57 ff       	sbrs	r21, 7
     c5c:	09 c0       	rjmp	.+18     	; 0xc70 <vfprintf+0x21e>
     c5e:	50 95       	com	r21
     c60:	40 95       	com	r20
     c62:	30 95       	com	r19
     c64:	21 95       	neg	r18
     c66:	3f 4f       	sbci	r19, 0xFF	; 255
     c68:	4f 4f       	sbci	r20, 0xFF	; 255
     c6a:	5f 4f       	sbci	r21, 0xFF	; 255
     c6c:	e0 e8       	ldi	r30, 0x80	; 128
     c6e:	fe 2a       	or	r15, r30
     c70:	ca 01       	movw	r24, r20
     c72:	b9 01       	movw	r22, r18
     c74:	a1 01       	movw	r20, r2
     c76:	2a e0       	ldi	r18, 0x0A	; 10
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	0e 94 70 08 	call	0x10e0	; 0x10e0 <__ultoa_invert>
     c7e:	d8 2e       	mov	r13, r24
     c80:	d2 18       	sub	r13, r2
     c82:	40 c0       	rjmp	.+128    	; 0xd04 <vfprintf+0x2b2>
     c84:	95 37       	cpi	r25, 0x75	; 117
     c86:	29 f4       	brne	.+10     	; 0xc92 <vfprintf+0x240>
     c88:	1f 2d       	mov	r17, r15
     c8a:	1f 7e       	andi	r17, 0xEF	; 239
     c8c:	2a e0       	ldi	r18, 0x0A	; 10
     c8e:	30 e0       	ldi	r19, 0x00	; 0
     c90:	1d c0       	rjmp	.+58     	; 0xccc <vfprintf+0x27a>
     c92:	1f 2d       	mov	r17, r15
     c94:	19 7f       	andi	r17, 0xF9	; 249
     c96:	9f 36       	cpi	r25, 0x6F	; 111
     c98:	61 f0       	breq	.+24     	; 0xcb2 <vfprintf+0x260>
     c9a:	90 37       	cpi	r25, 0x70	; 112
     c9c:	20 f4       	brcc	.+8      	; 0xca6 <vfprintf+0x254>
     c9e:	98 35       	cpi	r25, 0x58	; 88
     ca0:	09 f0       	breq	.+2      	; 0xca4 <vfprintf+0x252>
     ca2:	ac c0       	rjmp	.+344    	; 0xdfc <vfprintf+0x3aa>
     ca4:	0f c0       	rjmp	.+30     	; 0xcc4 <vfprintf+0x272>
     ca6:	90 37       	cpi	r25, 0x70	; 112
     ca8:	39 f0       	breq	.+14     	; 0xcb8 <vfprintf+0x266>
     caa:	98 37       	cpi	r25, 0x78	; 120
     cac:	09 f0       	breq	.+2      	; 0xcb0 <vfprintf+0x25e>
     cae:	a6 c0       	rjmp	.+332    	; 0xdfc <vfprintf+0x3aa>
     cb0:	04 c0       	rjmp	.+8      	; 0xcba <vfprintf+0x268>
     cb2:	28 e0       	ldi	r18, 0x08	; 8
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	0a c0       	rjmp	.+20     	; 0xccc <vfprintf+0x27a>
     cb8:	10 61       	ori	r17, 0x10	; 16
     cba:	14 fd       	sbrc	r17, 4
     cbc:	14 60       	ori	r17, 0x04	; 4
     cbe:	20 e1       	ldi	r18, 0x10	; 16
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	04 c0       	rjmp	.+8      	; 0xccc <vfprintf+0x27a>
     cc4:	14 fd       	sbrc	r17, 4
     cc6:	16 60       	ori	r17, 0x06	; 6
     cc8:	20 e1       	ldi	r18, 0x10	; 16
     cca:	32 e0       	ldi	r19, 0x02	; 2
     ccc:	17 ff       	sbrs	r17, 7
     cce:	08 c0       	rjmp	.+16     	; 0xce0 <vfprintf+0x28e>
     cd0:	f5 01       	movw	r30, r10
     cd2:	60 81       	ld	r22, Z
     cd4:	71 81       	ldd	r23, Z+1	; 0x01
     cd6:	82 81       	ldd	r24, Z+2	; 0x02
     cd8:	93 81       	ldd	r25, Z+3	; 0x03
     cda:	44 e0       	ldi	r20, 0x04	; 4
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	08 c0       	rjmp	.+16     	; 0xcf0 <vfprintf+0x29e>
     ce0:	f5 01       	movw	r30, r10
     ce2:	80 81       	ld	r24, Z
     ce4:	91 81       	ldd	r25, Z+1	; 0x01
     ce6:	bc 01       	movw	r22, r24
     ce8:	80 e0       	ldi	r24, 0x00	; 0
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	42 e0       	ldi	r20, 0x02	; 2
     cee:	50 e0       	ldi	r21, 0x00	; 0
     cf0:	a4 0e       	add	r10, r20
     cf2:	b5 1e       	adc	r11, r21
     cf4:	a1 01       	movw	r20, r2
     cf6:	0e 94 70 08 	call	0x10e0	; 0x10e0 <__ultoa_invert>
     cfa:	d8 2e       	mov	r13, r24
     cfc:	d2 18       	sub	r13, r2
     cfe:	8f e7       	ldi	r24, 0x7F	; 127
     d00:	f8 2e       	mov	r15, r24
     d02:	f1 22       	and	r15, r17
     d04:	f6 fe       	sbrs	r15, 6
     d06:	0b c0       	rjmp	.+22     	; 0xd1e <vfprintf+0x2cc>
     d08:	5e ef       	ldi	r21, 0xFE	; 254
     d0a:	f5 22       	and	r15, r21
     d0c:	d9 14       	cp	r13, r9
     d0e:	38 f4       	brcc	.+14     	; 0xd1e <vfprintf+0x2cc>
     d10:	f4 fe       	sbrs	r15, 4
     d12:	07 c0       	rjmp	.+14     	; 0xd22 <vfprintf+0x2d0>
     d14:	f2 fc       	sbrc	r15, 2
     d16:	05 c0       	rjmp	.+10     	; 0xd22 <vfprintf+0x2d0>
     d18:	8f ee       	ldi	r24, 0xEF	; 239
     d1a:	f8 22       	and	r15, r24
     d1c:	02 c0       	rjmp	.+4      	; 0xd22 <vfprintf+0x2d0>
     d1e:	1d 2d       	mov	r17, r13
     d20:	01 c0       	rjmp	.+2      	; 0xd24 <vfprintf+0x2d2>
     d22:	19 2d       	mov	r17, r9
     d24:	f4 fe       	sbrs	r15, 4
     d26:	0d c0       	rjmp	.+26     	; 0xd42 <vfprintf+0x2f0>
     d28:	fe 01       	movw	r30, r28
     d2a:	ed 0d       	add	r30, r13
     d2c:	f1 1d       	adc	r31, r1
     d2e:	80 81       	ld	r24, Z
     d30:	80 33       	cpi	r24, 0x30	; 48
     d32:	19 f4       	brne	.+6      	; 0xd3a <vfprintf+0x2e8>
     d34:	99 ee       	ldi	r25, 0xE9	; 233
     d36:	f9 22       	and	r15, r25
     d38:	08 c0       	rjmp	.+16     	; 0xd4a <vfprintf+0x2f8>
     d3a:	1f 5f       	subi	r17, 0xFF	; 255
     d3c:	f2 fe       	sbrs	r15, 2
     d3e:	05 c0       	rjmp	.+10     	; 0xd4a <vfprintf+0x2f8>
     d40:	03 c0       	rjmp	.+6      	; 0xd48 <vfprintf+0x2f6>
     d42:	8f 2d       	mov	r24, r15
     d44:	86 78       	andi	r24, 0x86	; 134
     d46:	09 f0       	breq	.+2      	; 0xd4a <vfprintf+0x2f8>
     d48:	1f 5f       	subi	r17, 0xFF	; 255
     d4a:	0f 2d       	mov	r16, r15
     d4c:	f3 fc       	sbrc	r15, 3
     d4e:	14 c0       	rjmp	.+40     	; 0xd78 <vfprintf+0x326>
     d50:	f0 fe       	sbrs	r15, 0
     d52:	0f c0       	rjmp	.+30     	; 0xd72 <vfprintf+0x320>
     d54:	1e 15       	cp	r17, r14
     d56:	10 f0       	brcs	.+4      	; 0xd5c <vfprintf+0x30a>
     d58:	9d 2c       	mov	r9, r13
     d5a:	0b c0       	rjmp	.+22     	; 0xd72 <vfprintf+0x320>
     d5c:	9d 2c       	mov	r9, r13
     d5e:	9e 0c       	add	r9, r14
     d60:	91 1a       	sub	r9, r17
     d62:	1e 2d       	mov	r17, r14
     d64:	06 c0       	rjmp	.+12     	; 0xd72 <vfprintf+0x320>
     d66:	80 e2       	ldi	r24, 0x20	; 32
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	b3 01       	movw	r22, r6
     d6c:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     d70:	1f 5f       	subi	r17, 0xFF	; 255
     d72:	1e 15       	cp	r17, r14
     d74:	c0 f3       	brcs	.-16     	; 0xd66 <vfprintf+0x314>
     d76:	04 c0       	rjmp	.+8      	; 0xd80 <vfprintf+0x32e>
     d78:	1e 15       	cp	r17, r14
     d7a:	10 f4       	brcc	.+4      	; 0xd80 <vfprintf+0x32e>
     d7c:	e1 1a       	sub	r14, r17
     d7e:	01 c0       	rjmp	.+2      	; 0xd82 <vfprintf+0x330>
     d80:	ee 24       	eor	r14, r14
     d82:	04 ff       	sbrs	r16, 4
     d84:	0f c0       	rjmp	.+30     	; 0xda4 <vfprintf+0x352>
     d86:	80 e3       	ldi	r24, 0x30	; 48
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	b3 01       	movw	r22, r6
     d8c:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     d90:	02 ff       	sbrs	r16, 2
     d92:	1d c0       	rjmp	.+58     	; 0xdce <vfprintf+0x37c>
     d94:	01 fd       	sbrc	r16, 1
     d96:	03 c0       	rjmp	.+6      	; 0xd9e <vfprintf+0x34c>
     d98:	88 e7       	ldi	r24, 0x78	; 120
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	0e c0       	rjmp	.+28     	; 0xdba <vfprintf+0x368>
     d9e:	88 e5       	ldi	r24, 0x58	; 88
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0b c0       	rjmp	.+22     	; 0xdba <vfprintf+0x368>
     da4:	80 2f       	mov	r24, r16
     da6:	86 78       	andi	r24, 0x86	; 134
     da8:	91 f0       	breq	.+36     	; 0xdce <vfprintf+0x37c>
     daa:	01 ff       	sbrs	r16, 1
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <vfprintf+0x360>
     dae:	8b e2       	ldi	r24, 0x2B	; 43
     db0:	01 c0       	rjmp	.+2      	; 0xdb4 <vfprintf+0x362>
     db2:	80 e2       	ldi	r24, 0x20	; 32
     db4:	f7 fc       	sbrc	r15, 7
     db6:	8d e2       	ldi	r24, 0x2D	; 45
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	b3 01       	movw	r22, r6
     dbc:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     dc0:	06 c0       	rjmp	.+12     	; 0xdce <vfprintf+0x37c>
     dc2:	80 e3       	ldi	r24, 0x30	; 48
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	b3 01       	movw	r22, r6
     dc8:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     dcc:	9a 94       	dec	r9
     dce:	d9 14       	cp	r13, r9
     dd0:	c0 f3       	brcs	.-16     	; 0xdc2 <vfprintf+0x370>
     dd2:	da 94       	dec	r13
     dd4:	f1 01       	movw	r30, r2
     dd6:	ed 0d       	add	r30, r13
     dd8:	f1 1d       	adc	r31, r1
     dda:	80 81       	ld	r24, Z
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	b3 01       	movw	r22, r6
     de0:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     de4:	dd 20       	and	r13, r13
     de6:	a9 f7       	brne	.-22     	; 0xdd2 <vfprintf+0x380>
     de8:	06 c0       	rjmp	.+12     	; 0xdf6 <vfprintf+0x3a4>
     dea:	80 e2       	ldi	r24, 0x20	; 32
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	b3 01       	movw	r22, r6
     df0:	0e 94 44 08 	call	0x1088	; 0x1088 <fputc>
     df4:	ea 94       	dec	r14
     df6:	ee 20       	and	r14, r14
     df8:	c1 f7       	brne	.-16     	; 0xdea <vfprintf+0x398>
     dfa:	43 ce       	rjmp	.-890    	; 0xa82 <vfprintf+0x30>
     dfc:	f3 01       	movw	r30, r6
     dfe:	66 81       	ldd	r22, Z+6	; 0x06
     e00:	77 81       	ldd	r23, Z+7	; 0x07
     e02:	cb 01       	movw	r24, r22
     e04:	2b 96       	adiw	r28, 0x0b	; 11
     e06:	e2 e1       	ldi	r30, 0x12	; 18
     e08:	0c 94 0c 09 	jmp	0x1218	; 0x1218 <__epilogue_restores__>

00000e0c <calloc>:
     e0c:	0f 93       	push	r16
     e0e:	1f 93       	push	r17
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	68 9f       	mul	r22, r24
     e16:	80 01       	movw	r16, r0
     e18:	69 9f       	mul	r22, r25
     e1a:	10 0d       	add	r17, r0
     e1c:	78 9f       	mul	r23, r24
     e1e:	10 0d       	add	r17, r0
     e20:	11 24       	eor	r1, r1
     e22:	c8 01       	movw	r24, r16
     e24:	0e 94 22 07 	call	0xe44	; 0xe44 <malloc>
     e28:	ec 01       	movw	r28, r24
     e2a:	00 97       	sbiw	r24, 0x00	; 0
     e2c:	29 f0       	breq	.+10     	; 0xe38 <calloc+0x2c>
     e2e:	60 e0       	ldi	r22, 0x00	; 0
     e30:	70 e0       	ldi	r23, 0x00	; 0
     e32:	a8 01       	movw	r20, r16
     e34:	0e 94 32 08 	call	0x1064	; 0x1064 <memset>
     e38:	ce 01       	movw	r24, r28
     e3a:	df 91       	pop	r29
     e3c:	cf 91       	pop	r28
     e3e:	1f 91       	pop	r17
     e40:	0f 91       	pop	r16
     e42:	08 95       	ret

00000e44 <malloc>:
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	bc 01       	movw	r22, r24
     e4a:	82 30       	cpi	r24, 0x02	; 2
     e4c:	91 05       	cpc	r25, r1
     e4e:	10 f4       	brcc	.+4      	; 0xe54 <malloc+0x10>
     e50:	62 e0       	ldi	r22, 0x02	; 2
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	a0 91 9a 02 	lds	r26, 0x029A
     e58:	b0 91 9b 02 	lds	r27, 0x029B
     e5c:	ed 01       	movw	r28, r26
     e5e:	e0 e0       	ldi	r30, 0x00	; 0
     e60:	f0 e0       	ldi	r31, 0x00	; 0
     e62:	40 e0       	ldi	r20, 0x00	; 0
     e64:	50 e0       	ldi	r21, 0x00	; 0
     e66:	21 c0       	rjmp	.+66     	; 0xeaa <malloc+0x66>
     e68:	88 81       	ld	r24, Y
     e6a:	99 81       	ldd	r25, Y+1	; 0x01
     e6c:	86 17       	cp	r24, r22
     e6e:	97 07       	cpc	r25, r23
     e70:	69 f4       	brne	.+26     	; 0xe8c <malloc+0x48>
     e72:	8a 81       	ldd	r24, Y+2	; 0x02
     e74:	9b 81       	ldd	r25, Y+3	; 0x03
     e76:	30 97       	sbiw	r30, 0x00	; 0
     e78:	19 f0       	breq	.+6      	; 0xe80 <malloc+0x3c>
     e7a:	93 83       	std	Z+3, r25	; 0x03
     e7c:	82 83       	std	Z+2, r24	; 0x02
     e7e:	04 c0       	rjmp	.+8      	; 0xe88 <malloc+0x44>
     e80:	90 93 9b 02 	sts	0x029B, r25
     e84:	80 93 9a 02 	sts	0x029A, r24
     e88:	fe 01       	movw	r30, r28
     e8a:	34 c0       	rjmp	.+104    	; 0xef4 <malloc+0xb0>
     e8c:	68 17       	cp	r22, r24
     e8e:	79 07       	cpc	r23, r25
     e90:	38 f4       	brcc	.+14     	; 0xea0 <malloc+0x5c>
     e92:	41 15       	cp	r20, r1
     e94:	51 05       	cpc	r21, r1
     e96:	19 f0       	breq	.+6      	; 0xe9e <malloc+0x5a>
     e98:	84 17       	cp	r24, r20
     e9a:	95 07       	cpc	r25, r21
     e9c:	08 f4       	brcc	.+2      	; 0xea0 <malloc+0x5c>
     e9e:	ac 01       	movw	r20, r24
     ea0:	fe 01       	movw	r30, r28
     ea2:	8a 81       	ldd	r24, Y+2	; 0x02
     ea4:	9b 81       	ldd	r25, Y+3	; 0x03
     ea6:	9c 01       	movw	r18, r24
     ea8:	e9 01       	movw	r28, r18
     eaa:	20 97       	sbiw	r28, 0x00	; 0
     eac:	e9 f6       	brne	.-70     	; 0xe68 <malloc+0x24>
     eae:	41 15       	cp	r20, r1
     eb0:	51 05       	cpc	r21, r1
     eb2:	a9 f1       	breq	.+106    	; 0xf1e <malloc+0xda>
     eb4:	ca 01       	movw	r24, r20
     eb6:	86 1b       	sub	r24, r22
     eb8:	97 0b       	sbc	r25, r23
     eba:	04 97       	sbiw	r24, 0x04	; 4
     ebc:	08 f4       	brcc	.+2      	; 0xec0 <malloc+0x7c>
     ebe:	ba 01       	movw	r22, r20
     ec0:	e0 e0       	ldi	r30, 0x00	; 0
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	2a c0       	rjmp	.+84     	; 0xf1a <malloc+0xd6>
     ec6:	8d 91       	ld	r24, X+
     ec8:	9c 91       	ld	r25, X
     eca:	11 97       	sbiw	r26, 0x01	; 1
     ecc:	84 17       	cp	r24, r20
     ece:	95 07       	cpc	r25, r21
     ed0:	f9 f4       	brne	.+62     	; 0xf10 <malloc+0xcc>
     ed2:	64 17       	cp	r22, r20
     ed4:	75 07       	cpc	r23, r21
     ed6:	81 f4       	brne	.+32     	; 0xef8 <malloc+0xb4>
     ed8:	12 96       	adiw	r26, 0x02	; 2
     eda:	8d 91       	ld	r24, X+
     edc:	9c 91       	ld	r25, X
     ede:	13 97       	sbiw	r26, 0x03	; 3
     ee0:	30 97       	sbiw	r30, 0x00	; 0
     ee2:	19 f0       	breq	.+6      	; 0xeea <malloc+0xa6>
     ee4:	93 83       	std	Z+3, r25	; 0x03
     ee6:	82 83       	std	Z+2, r24	; 0x02
     ee8:	04 c0       	rjmp	.+8      	; 0xef2 <malloc+0xae>
     eea:	90 93 9b 02 	sts	0x029B, r25
     eee:	80 93 9a 02 	sts	0x029A, r24
     ef2:	fd 01       	movw	r30, r26
     ef4:	32 96       	adiw	r30, 0x02	; 2
     ef6:	4f c0       	rjmp	.+158    	; 0xf96 <malloc+0x152>
     ef8:	ca 01       	movw	r24, r20
     efa:	86 1b       	sub	r24, r22
     efc:	97 0b       	sbc	r25, r23
     efe:	fd 01       	movw	r30, r26
     f00:	e8 0f       	add	r30, r24
     f02:	f9 1f       	adc	r31, r25
     f04:	61 93       	st	Z+, r22
     f06:	71 93       	st	Z+, r23
     f08:	02 97       	sbiw	r24, 0x02	; 2
     f0a:	8d 93       	st	X+, r24
     f0c:	9c 93       	st	X, r25
     f0e:	43 c0       	rjmp	.+134    	; 0xf96 <malloc+0x152>
     f10:	fd 01       	movw	r30, r26
     f12:	82 81       	ldd	r24, Z+2	; 0x02
     f14:	93 81       	ldd	r25, Z+3	; 0x03
     f16:	9c 01       	movw	r18, r24
     f18:	d9 01       	movw	r26, r18
     f1a:	10 97       	sbiw	r26, 0x00	; 0
     f1c:	a1 f6       	brne	.-88     	; 0xec6 <malloc+0x82>
     f1e:	80 91 98 02 	lds	r24, 0x0298
     f22:	90 91 99 02 	lds	r25, 0x0299
     f26:	89 2b       	or	r24, r25
     f28:	41 f4       	brne	.+16     	; 0xf3a <malloc+0xf6>
     f2a:	80 91 8e 02 	lds	r24, 0x028E
     f2e:	90 91 8f 02 	lds	r25, 0x028F
     f32:	90 93 99 02 	sts	0x0299, r25
     f36:	80 93 98 02 	sts	0x0298, r24
     f3a:	40 91 90 02 	lds	r20, 0x0290
     f3e:	50 91 91 02 	lds	r21, 0x0291
     f42:	41 15       	cp	r20, r1
     f44:	51 05       	cpc	r21, r1
     f46:	41 f4       	brne	.+16     	; 0xf58 <malloc+0x114>
     f48:	4d b7       	in	r20, 0x3d	; 61
     f4a:	5e b7       	in	r21, 0x3e	; 62
     f4c:	80 91 8c 02 	lds	r24, 0x028C
     f50:	90 91 8d 02 	lds	r25, 0x028D
     f54:	48 1b       	sub	r20, r24
     f56:	59 0b       	sbc	r21, r25
     f58:	20 91 98 02 	lds	r18, 0x0298
     f5c:	30 91 99 02 	lds	r19, 0x0299
     f60:	24 17       	cp	r18, r20
     f62:	35 07       	cpc	r19, r21
     f64:	b0 f4       	brcc	.+44     	; 0xf92 <malloc+0x14e>
     f66:	ca 01       	movw	r24, r20
     f68:	82 1b       	sub	r24, r18
     f6a:	93 0b       	sbc	r25, r19
     f6c:	86 17       	cp	r24, r22
     f6e:	97 07       	cpc	r25, r23
     f70:	80 f0       	brcs	.+32     	; 0xf92 <malloc+0x14e>
     f72:	ab 01       	movw	r20, r22
     f74:	4e 5f       	subi	r20, 0xFE	; 254
     f76:	5f 4f       	sbci	r21, 0xFF	; 255
     f78:	84 17       	cp	r24, r20
     f7a:	95 07       	cpc	r25, r21
     f7c:	50 f0       	brcs	.+20     	; 0xf92 <malloc+0x14e>
     f7e:	42 0f       	add	r20, r18
     f80:	53 1f       	adc	r21, r19
     f82:	50 93 99 02 	sts	0x0299, r21
     f86:	40 93 98 02 	sts	0x0298, r20
     f8a:	f9 01       	movw	r30, r18
     f8c:	61 93       	st	Z+, r22
     f8e:	71 93       	st	Z+, r23
     f90:	02 c0       	rjmp	.+4      	; 0xf96 <malloc+0x152>
     f92:	e0 e0       	ldi	r30, 0x00	; 0
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	cf 01       	movw	r24, r30
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <free>:
     f9e:	cf 93       	push	r28
     fa0:	df 93       	push	r29
     fa2:	00 97       	sbiw	r24, 0x00	; 0
     fa4:	09 f4       	brne	.+2      	; 0xfa8 <free+0xa>
     fa6:	50 c0       	rjmp	.+160    	; 0x1048 <free+0xaa>
     fa8:	ec 01       	movw	r28, r24
     faa:	22 97       	sbiw	r28, 0x02	; 2
     fac:	1b 82       	std	Y+3, r1	; 0x03
     fae:	1a 82       	std	Y+2, r1	; 0x02
     fb0:	a0 91 9a 02 	lds	r26, 0x029A
     fb4:	b0 91 9b 02 	lds	r27, 0x029B
     fb8:	10 97       	sbiw	r26, 0x00	; 0
     fba:	09 f1       	breq	.+66     	; 0xffe <free+0x60>
     fbc:	40 e0       	ldi	r20, 0x00	; 0
     fbe:	50 e0       	ldi	r21, 0x00	; 0
     fc0:	ac 17       	cp	r26, r28
     fc2:	bd 07       	cpc	r27, r29
     fc4:	08 f1       	brcs	.+66     	; 0x1008 <free+0x6a>
     fc6:	bb 83       	std	Y+3, r27	; 0x03
     fc8:	aa 83       	std	Y+2, r26	; 0x02
     fca:	fe 01       	movw	r30, r28
     fcc:	21 91       	ld	r18, Z+
     fce:	31 91       	ld	r19, Z+
     fd0:	e2 0f       	add	r30, r18
     fd2:	f3 1f       	adc	r31, r19
     fd4:	ae 17       	cp	r26, r30
     fd6:	bf 07       	cpc	r27, r31
     fd8:	79 f4       	brne	.+30     	; 0xff8 <free+0x5a>
     fda:	8d 91       	ld	r24, X+
     fdc:	9c 91       	ld	r25, X
     fde:	11 97       	sbiw	r26, 0x01	; 1
     fe0:	28 0f       	add	r18, r24
     fe2:	39 1f       	adc	r19, r25
     fe4:	2e 5f       	subi	r18, 0xFE	; 254
     fe6:	3f 4f       	sbci	r19, 0xFF	; 255
     fe8:	39 83       	std	Y+1, r19	; 0x01
     fea:	28 83       	st	Y, r18
     fec:	12 96       	adiw	r26, 0x02	; 2
     fee:	8d 91       	ld	r24, X+
     ff0:	9c 91       	ld	r25, X
     ff2:	13 97       	sbiw	r26, 0x03	; 3
     ff4:	9b 83       	std	Y+3, r25	; 0x03
     ff6:	8a 83       	std	Y+2, r24	; 0x02
     ff8:	41 15       	cp	r20, r1
     ffa:	51 05       	cpc	r21, r1
     ffc:	71 f4       	brne	.+28     	; 0x101a <free+0x7c>
     ffe:	d0 93 9b 02 	sts	0x029B, r29
    1002:	c0 93 9a 02 	sts	0x029A, r28
    1006:	20 c0       	rjmp	.+64     	; 0x1048 <free+0xaa>
    1008:	12 96       	adiw	r26, 0x02	; 2
    100a:	8d 91       	ld	r24, X+
    100c:	9c 91       	ld	r25, X
    100e:	13 97       	sbiw	r26, 0x03	; 3
    1010:	ad 01       	movw	r20, r26
    1012:	00 97       	sbiw	r24, 0x00	; 0
    1014:	11 f0       	breq	.+4      	; 0x101a <free+0x7c>
    1016:	dc 01       	movw	r26, r24
    1018:	d3 cf       	rjmp	.-90     	; 0xfc0 <free+0x22>
    101a:	fa 01       	movw	r30, r20
    101c:	d3 83       	std	Z+3, r29	; 0x03
    101e:	c2 83       	std	Z+2, r28	; 0x02
    1020:	21 91       	ld	r18, Z+
    1022:	31 91       	ld	r19, Z+
    1024:	e2 0f       	add	r30, r18
    1026:	f3 1f       	adc	r31, r19
    1028:	ce 17       	cp	r28, r30
    102a:	df 07       	cpc	r29, r31
    102c:	69 f4       	brne	.+26     	; 0x1048 <free+0xaa>
    102e:	88 81       	ld	r24, Y
    1030:	99 81       	ldd	r25, Y+1	; 0x01
    1032:	28 0f       	add	r18, r24
    1034:	39 1f       	adc	r19, r25
    1036:	2e 5f       	subi	r18, 0xFE	; 254
    1038:	3f 4f       	sbci	r19, 0xFF	; 255
    103a:	fa 01       	movw	r30, r20
    103c:	31 83       	std	Z+1, r19	; 0x01
    103e:	20 83       	st	Z, r18
    1040:	8a 81       	ldd	r24, Y+2	; 0x02
    1042:	9b 81       	ldd	r25, Y+3	; 0x03
    1044:	93 83       	std	Z+3, r25	; 0x03
    1046:	82 83       	std	Z+2, r24	; 0x02
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	08 95       	ret

0000104e <strnlen_P>:
    104e:	fc 01       	movw	r30, r24
    1050:	05 90       	lpm	r0, Z+
    1052:	61 50       	subi	r22, 0x01	; 1
    1054:	70 40       	sbci	r23, 0x00	; 0
    1056:	01 10       	cpse	r0, r1
    1058:	d8 f7       	brcc	.-10     	; 0x1050 <strnlen_P+0x2>
    105a:	80 95       	com	r24
    105c:	90 95       	com	r25
    105e:	8e 0f       	add	r24, r30
    1060:	9f 1f       	adc	r25, r31
    1062:	08 95       	ret

00001064 <memset>:
    1064:	dc 01       	movw	r26, r24
    1066:	01 c0       	rjmp	.+2      	; 0x106a <memset+0x6>
    1068:	6d 93       	st	X+, r22
    106a:	41 50       	subi	r20, 0x01	; 1
    106c:	50 40       	sbci	r21, 0x00	; 0
    106e:	e0 f7       	brcc	.-8      	; 0x1068 <memset+0x4>
    1070:	08 95       	ret

00001072 <strnlen>:
    1072:	fc 01       	movw	r30, r24
    1074:	61 50       	subi	r22, 0x01	; 1
    1076:	70 40       	sbci	r23, 0x00	; 0
    1078:	01 90       	ld	r0, Z+
    107a:	01 10       	cpse	r0, r1
    107c:	d8 f7       	brcc	.-10     	; 0x1074 <strnlen+0x2>
    107e:	80 95       	com	r24
    1080:	90 95       	com	r25
    1082:	8e 0f       	add	r24, r30
    1084:	9f 1f       	adc	r25, r31
    1086:	08 95       	ret

00001088 <fputc>:
    1088:	0f 93       	push	r16
    108a:	1f 93       	push	r17
    108c:	cf 93       	push	r28
    108e:	df 93       	push	r29
    1090:	8c 01       	movw	r16, r24
    1092:	eb 01       	movw	r28, r22
    1094:	8b 81       	ldd	r24, Y+3	; 0x03
    1096:	81 ff       	sbrs	r24, 1
    1098:	1b c0       	rjmp	.+54     	; 0x10d0 <fputc+0x48>
    109a:	82 ff       	sbrs	r24, 2
    109c:	0d c0       	rjmp	.+26     	; 0x10b8 <fputc+0x30>
    109e:	2e 81       	ldd	r18, Y+6	; 0x06
    10a0:	3f 81       	ldd	r19, Y+7	; 0x07
    10a2:	8c 81       	ldd	r24, Y+4	; 0x04
    10a4:	9d 81       	ldd	r25, Y+5	; 0x05
    10a6:	28 17       	cp	r18, r24
    10a8:	39 07       	cpc	r19, r25
    10aa:	64 f4       	brge	.+24     	; 0x10c4 <fputc+0x3c>
    10ac:	e8 81       	ld	r30, Y
    10ae:	f9 81       	ldd	r31, Y+1	; 0x01
    10b0:	01 93       	st	Z+, r16
    10b2:	f9 83       	std	Y+1, r31	; 0x01
    10b4:	e8 83       	st	Y, r30
    10b6:	06 c0       	rjmp	.+12     	; 0x10c4 <fputc+0x3c>
    10b8:	e8 85       	ldd	r30, Y+8	; 0x08
    10ba:	f9 85       	ldd	r31, Y+9	; 0x09
    10bc:	80 2f       	mov	r24, r16
    10be:	09 95       	icall
    10c0:	89 2b       	or	r24, r25
    10c2:	31 f4       	brne	.+12     	; 0x10d0 <fputc+0x48>
    10c4:	8e 81       	ldd	r24, Y+6	; 0x06
    10c6:	9f 81       	ldd	r25, Y+7	; 0x07
    10c8:	01 96       	adiw	r24, 0x01	; 1
    10ca:	9f 83       	std	Y+7, r25	; 0x07
    10cc:	8e 83       	std	Y+6, r24	; 0x06
    10ce:	02 c0       	rjmp	.+4      	; 0x10d4 <fputc+0x4c>
    10d0:	0f ef       	ldi	r16, 0xFF	; 255
    10d2:	1f ef       	ldi	r17, 0xFF	; 255
    10d4:	c8 01       	movw	r24, r16
    10d6:	df 91       	pop	r29
    10d8:	cf 91       	pop	r28
    10da:	1f 91       	pop	r17
    10dc:	0f 91       	pop	r16
    10de:	08 95       	ret

000010e0 <__ultoa_invert>:
    10e0:	fa 01       	movw	r30, r20
    10e2:	aa 27       	eor	r26, r26
    10e4:	28 30       	cpi	r18, 0x08	; 8
    10e6:	51 f1       	breq	.+84     	; 0x113c <__ultoa_invert+0x5c>
    10e8:	20 31       	cpi	r18, 0x10	; 16
    10ea:	81 f1       	breq	.+96     	; 0x114c <__ultoa_invert+0x6c>
    10ec:	e8 94       	clt
    10ee:	6f 93       	push	r22
    10f0:	6e 7f       	andi	r22, 0xFE	; 254
    10f2:	6e 5f       	subi	r22, 0xFE	; 254
    10f4:	7f 4f       	sbci	r23, 0xFF	; 255
    10f6:	8f 4f       	sbci	r24, 0xFF	; 255
    10f8:	9f 4f       	sbci	r25, 0xFF	; 255
    10fa:	af 4f       	sbci	r26, 0xFF	; 255
    10fc:	b1 e0       	ldi	r27, 0x01	; 1
    10fe:	3e d0       	rcall	.+124    	; 0x117c <__ultoa_invert+0x9c>
    1100:	b4 e0       	ldi	r27, 0x04	; 4
    1102:	3c d0       	rcall	.+120    	; 0x117c <__ultoa_invert+0x9c>
    1104:	67 0f       	add	r22, r23
    1106:	78 1f       	adc	r23, r24
    1108:	89 1f       	adc	r24, r25
    110a:	9a 1f       	adc	r25, r26
    110c:	a1 1d       	adc	r26, r1
    110e:	68 0f       	add	r22, r24
    1110:	79 1f       	adc	r23, r25
    1112:	8a 1f       	adc	r24, r26
    1114:	91 1d       	adc	r25, r1
    1116:	a1 1d       	adc	r26, r1
    1118:	6a 0f       	add	r22, r26
    111a:	71 1d       	adc	r23, r1
    111c:	81 1d       	adc	r24, r1
    111e:	91 1d       	adc	r25, r1
    1120:	a1 1d       	adc	r26, r1
    1122:	20 d0       	rcall	.+64     	; 0x1164 <__ultoa_invert+0x84>
    1124:	09 f4       	brne	.+2      	; 0x1128 <__ultoa_invert+0x48>
    1126:	68 94       	set
    1128:	3f 91       	pop	r19
    112a:	2a e0       	ldi	r18, 0x0A	; 10
    112c:	26 9f       	mul	r18, r22
    112e:	11 24       	eor	r1, r1
    1130:	30 19       	sub	r19, r0
    1132:	30 5d       	subi	r19, 0xD0	; 208
    1134:	31 93       	st	Z+, r19
    1136:	de f6       	brtc	.-74     	; 0x10ee <__ultoa_invert+0xe>
    1138:	cf 01       	movw	r24, r30
    113a:	08 95       	ret
    113c:	46 2f       	mov	r20, r22
    113e:	47 70       	andi	r20, 0x07	; 7
    1140:	40 5d       	subi	r20, 0xD0	; 208
    1142:	41 93       	st	Z+, r20
    1144:	b3 e0       	ldi	r27, 0x03	; 3
    1146:	0f d0       	rcall	.+30     	; 0x1166 <__ultoa_invert+0x86>
    1148:	c9 f7       	brne	.-14     	; 0x113c <__ultoa_invert+0x5c>
    114a:	f6 cf       	rjmp	.-20     	; 0x1138 <__ultoa_invert+0x58>
    114c:	46 2f       	mov	r20, r22
    114e:	4f 70       	andi	r20, 0x0F	; 15
    1150:	40 5d       	subi	r20, 0xD0	; 208
    1152:	4a 33       	cpi	r20, 0x3A	; 58
    1154:	18 f0       	brcs	.+6      	; 0x115c <__ultoa_invert+0x7c>
    1156:	49 5d       	subi	r20, 0xD9	; 217
    1158:	31 fd       	sbrc	r19, 1
    115a:	40 52       	subi	r20, 0x20	; 32
    115c:	41 93       	st	Z+, r20
    115e:	02 d0       	rcall	.+4      	; 0x1164 <__ultoa_invert+0x84>
    1160:	a9 f7       	brne	.-22     	; 0x114c <__ultoa_invert+0x6c>
    1162:	ea cf       	rjmp	.-44     	; 0x1138 <__ultoa_invert+0x58>
    1164:	b4 e0       	ldi	r27, 0x04	; 4
    1166:	a6 95       	lsr	r26
    1168:	97 95       	ror	r25
    116a:	87 95       	ror	r24
    116c:	77 95       	ror	r23
    116e:	67 95       	ror	r22
    1170:	ba 95       	dec	r27
    1172:	c9 f7       	brne	.-14     	; 0x1166 <__ultoa_invert+0x86>
    1174:	00 97       	sbiw	r24, 0x00	; 0
    1176:	61 05       	cpc	r22, r1
    1178:	71 05       	cpc	r23, r1
    117a:	08 95       	ret
    117c:	9b 01       	movw	r18, r22
    117e:	ac 01       	movw	r20, r24
    1180:	0a 2e       	mov	r0, r26
    1182:	06 94       	lsr	r0
    1184:	57 95       	ror	r21
    1186:	47 95       	ror	r20
    1188:	37 95       	ror	r19
    118a:	27 95       	ror	r18
    118c:	ba 95       	dec	r27
    118e:	c9 f7       	brne	.-14     	; 0x1182 <__ultoa_invert+0xa2>
    1190:	62 0f       	add	r22, r18
    1192:	73 1f       	adc	r23, r19
    1194:	84 1f       	adc	r24, r20
    1196:	95 1f       	adc	r25, r21
    1198:	a0 1d       	adc	r26, r0
    119a:	08 95       	ret

0000119c <__udivmodsi4>:
    119c:	a1 e2       	ldi	r26, 0x21	; 33
    119e:	1a 2e       	mov	r1, r26
    11a0:	aa 1b       	sub	r26, r26
    11a2:	bb 1b       	sub	r27, r27
    11a4:	fd 01       	movw	r30, r26
    11a6:	0d c0       	rjmp	.+26     	; 0x11c2 <__udivmodsi4_ep>

000011a8 <__udivmodsi4_loop>:
    11a8:	aa 1f       	adc	r26, r26
    11aa:	bb 1f       	adc	r27, r27
    11ac:	ee 1f       	adc	r30, r30
    11ae:	ff 1f       	adc	r31, r31
    11b0:	a2 17       	cp	r26, r18
    11b2:	b3 07       	cpc	r27, r19
    11b4:	e4 07       	cpc	r30, r20
    11b6:	f5 07       	cpc	r31, r21
    11b8:	20 f0       	brcs	.+8      	; 0x11c2 <__udivmodsi4_ep>
    11ba:	a2 1b       	sub	r26, r18
    11bc:	b3 0b       	sbc	r27, r19
    11be:	e4 0b       	sbc	r30, r20
    11c0:	f5 0b       	sbc	r31, r21

000011c2 <__udivmodsi4_ep>:
    11c2:	66 1f       	adc	r22, r22
    11c4:	77 1f       	adc	r23, r23
    11c6:	88 1f       	adc	r24, r24
    11c8:	99 1f       	adc	r25, r25
    11ca:	1a 94       	dec	r1
    11cc:	69 f7       	brne	.-38     	; 0x11a8 <__udivmodsi4_loop>
    11ce:	60 95       	com	r22
    11d0:	70 95       	com	r23
    11d2:	80 95       	com	r24
    11d4:	90 95       	com	r25
    11d6:	9b 01       	movw	r18, r22
    11d8:	ac 01       	movw	r20, r24
    11da:	bd 01       	movw	r22, r26
    11dc:	cf 01       	movw	r24, r30
    11de:	08 95       	ret

000011e0 <__prologue_saves__>:
    11e0:	2f 92       	push	r2
    11e2:	3f 92       	push	r3
    11e4:	4f 92       	push	r4
    11e6:	5f 92       	push	r5
    11e8:	6f 92       	push	r6
    11ea:	7f 92       	push	r7
    11ec:	8f 92       	push	r8
    11ee:	9f 92       	push	r9
    11f0:	af 92       	push	r10
    11f2:	bf 92       	push	r11
    11f4:	cf 92       	push	r12
    11f6:	df 92       	push	r13
    11f8:	ef 92       	push	r14
    11fa:	ff 92       	push	r15
    11fc:	0f 93       	push	r16
    11fe:	1f 93       	push	r17
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	ca 1b       	sub	r28, r26
    120a:	db 0b       	sbc	r29, r27
    120c:	0f b6       	in	r0, 0x3f	; 63
    120e:	f8 94       	cli
    1210:	de bf       	out	0x3e, r29	; 62
    1212:	0f be       	out	0x3f, r0	; 63
    1214:	cd bf       	out	0x3d, r28	; 61
    1216:	09 94       	ijmp

00001218 <__epilogue_restores__>:
    1218:	2a 88       	ldd	r2, Y+18	; 0x12
    121a:	39 88       	ldd	r3, Y+17	; 0x11
    121c:	48 88       	ldd	r4, Y+16	; 0x10
    121e:	5f 84       	ldd	r5, Y+15	; 0x0f
    1220:	6e 84       	ldd	r6, Y+14	; 0x0e
    1222:	7d 84       	ldd	r7, Y+13	; 0x0d
    1224:	8c 84       	ldd	r8, Y+12	; 0x0c
    1226:	9b 84       	ldd	r9, Y+11	; 0x0b
    1228:	aa 84       	ldd	r10, Y+10	; 0x0a
    122a:	b9 84       	ldd	r11, Y+9	; 0x09
    122c:	c8 84       	ldd	r12, Y+8	; 0x08
    122e:	df 80       	ldd	r13, Y+7	; 0x07
    1230:	ee 80       	ldd	r14, Y+6	; 0x06
    1232:	fd 80       	ldd	r15, Y+5	; 0x05
    1234:	0c 81       	ldd	r16, Y+4	; 0x04
    1236:	1b 81       	ldd	r17, Y+3	; 0x03
    1238:	aa 81       	ldd	r26, Y+2	; 0x02
    123a:	b9 81       	ldd	r27, Y+1	; 0x01
    123c:	ce 0f       	add	r28, r30
    123e:	d1 1d       	adc	r29, r1
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	de bf       	out	0x3e, r29	; 62
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	cd bf       	out	0x3d, r28	; 61
    124a:	ed 01       	movw	r28, r26
    124c:	08 95       	ret

0000124e <_exit>:
    124e:	f8 94       	cli

00001250 <__stop_program>:
    1250:	ff cf       	rjmp	.-2      	; 0x1250 <__stop_program>
